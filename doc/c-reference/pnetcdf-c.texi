\input texinfo @c -*-texinfo-*-
@c $Id$
@c %**start of header
@setfilename pnetcdf-c.info
@settitle PnetCDF C Interface Guide
@c @setcontentsaftertitlepage
@c Combine the variable, concept, and function indices.
@synindex vr cp
@synindex fn cp
@c %**end of header

@include version-c.texi
@include defines.texi

@ifinfo
@dircategory netCDF scientific data format
@direntry
* pnetcdf-c: (pnetcdf-c).         @value{c-man}
@end direntry
@end ifinfo

@titlepage
@title @value{c-man}
@subtitle PnetCDF Version @value{VERSION}
@subtitle Last Updated @value{UPDATED}
@author Wei-keng Liao
@author Northwestern University
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@ifnottex
@node Top, Use of the PnetCDF Library, (dir), (dir)
@top @value{c-man}
@end ifnottex

@comment This document describes the C interface to the PnetCDF library.
@comment  it applies to PnetCDF @value{VERSION} and later versions.
@comment  and was last updated on @value{UPDATED}.

@c For a complete description of the netCDF format and utilities see @ref{Top, @value{n-man},, pnetcdf, @value{n-man}}.

@menu
Table of contents
* Use of the PnetCDF Library::   General guide of using PnetCDF APIs
* Files::                        APIs for operating netCDF files
* Dimensions::                   APIs for dimension objects
* Variables::                    APIs for accessing variables
* Attributes::                   APIs for accessing attributes
* Run-time Environment Variables:: Tuning I/O performance, debugging
* Utility programs::             ncmpidiff, cdfdiff, pnetcdf_version, ncoffsets, pnetcdf-config, ncvalidator
* Summary of C Interface::     List of C APIs
* Summary of Fortran 77 Interface::     List of Fortran 77 APIs
* Summary of Fortran 90 Interface::     List of Fortran 90 APIs
* Error Codes::                List of error codes and their meanings
* Combined Index::
* CDF-1 file format specification::
* CDF-2 file format specification::
* CDF-5 file format specification::

@detailmenu
@c --- The Detailed Node Listing ---
Use of the PnetCDF Library
* Creating::                    Creating a NetCDF file
* Reading Known ::              Reading a NetCDF file with known names
* Reading Unknown ::            Reading a netCDF file with Unknown Names
* Adding::                      Adding new dimensions, variables, attributes
* Nonblocking Write::           Nonblocking write to one or more variables
* Nonblocking Read::            Nonblocking read from one or more variables
* Errors::                      Error handling
* Compiling::                   Compiling and linking with the PnetCDF library

Files
* Interface Descriptions::      What's in the Function Documentation
* ncmpi_strerror::              Get error string from error code
* ncmpi_strerrno::              Get string name of an error code (1.8.0 and later)
* ncmpi_inq_libvers::           Get netCDF library version
* ncmpi_create::                Create a file (collective)
@comment * ncmpi__create::               Not implemented
* ncmpi_open::                  Open a file (collective)
@comment * ncmpi__open::                 Not implemented
* ncmpi_redef::                 Put a file into Define Mode (collective)
* ncmpi_enddef::                Leave Define Mode (collective)
* ncmpi__enddef::               Leave Define Mode with Performance Tuning (1.5.0 and later) (collective)
* ncmpi_close::                 Close a file (collective)
* ncmpi_inq Family::            Inquire about a file
* ncmpi_sync::                  Synchronize a file to Disk (collective)
* ncmpi_abort::                 Back Out of Recent Definitions (collective)
* ncmpi_set_fill::              Set fill mode for a file (1.6.1 and later) (collective)
* ncmpi_set_default_format::    Set/change the default output format (1.6.1 and later)
* ncmpi_begin_indep_data::      Enter independent parallel data access mode (collective)
* ncmpi_end_indep_data::        Exit independent data mode (collective)
* ncmpi_inq_put_size::          Inquire the amount of data written to file so far (1.4.0 and later)
* ncmpi_inq_get_size::          Inquire the amount of data read from file so far (1.4.0 and later)
* ncmpi_inq_header_size::       Inquire the size of the file header (1.4.0 and later)
* ncmpi_inq_header_extent::     Inquire the file header extent (1.4.0 and later)
* ncmpi_sync_numrecs::          Synchronize the number of records (1.4.0 and later) (collective)
* ncmpi_delete::                Delete a file
* ncmpi_inq_file_info::         Obtain the MPI Info object that contains all the I/O hints currently used (1.5.0 and later)
* ncmpi_get_file_info::         (deprecated)
* ncmpi_inq_files_opened::      Reports the number of files that are currently opened (1.5.0 and later)

Dimensions
* Dimensions Introduction::     Rules for Dimensions
* ncmpi_def_dim::               Create a Dimension (collective)
* ncmpi_inq_dimid::             Get a Dimension ID from Its Name
* ncmpi_inq_dim Family::        Inquire about a Dimension
* ncmpi_rename_dim::            Rename a Dimension (collective)

Variables
* Variable Introduction::       What are Variables?
* Variable Types::              Floating point, integer, and all that
* ncmpi_def_var::               Create a Variable (collective)
* ncmpi_def_var_fill::          Set fill mode for a Variable (1.6.1 and later) (collective)
* ncmpi_inq_var_fill::          Inquire fill mode of a Variable (1.6.1 and later)
* ncmpi_fill_var_rec::          Fill a record of a record variable (1.6.1 and later) (collective)
* ncmpi_inq_varid::             Get a Variable ID from Its Name
* ncmpi_inq_var Family::        Get Information about a Variable from Its ID
* ncmpi_put_var1_@var{<type>}:: Write a Single Data Value
* ncmpi_put_var_@var{<type>}::  Write an Entire Variable
* ncmpi_put_vara_@var{<type>}:: Write an Array of Values
* ncmpi_put_vars_@var{<type>}:: Write a Subsampled Array of Values
* ncmpi_put_varm_@var{<type>}:: Write a Mapped Array of Values
* ncmpi_put_varn_@var{<type>}:: Write a List of Subarrays of Values (1.4.0 and later)
* ncmpi_put_vard::              Write an Array of Values using filetype (1.6.0 and later)
* ncmpi_get_var1_@var{<type>}:: Read a Single Data Value
* ncmpi_get_var_@var{<type>}::  Read an Entire Variable
* ncmpi_get_vara_@var{<type>}:: Read an Array of Values
* ncmpi_get_vars_@var{<type>}:: Read a Subsampled Array of Values
* ncmpi_get_varm_@var{<type>}:: Read a Mapped Array of Values
* ncmpi_get_varn_@var{<type>}:: Read a List of Subarrays of Values (1.4.0 and later)
* ncmpi_get_vard::              read an Array of Values using filetype (1.6.0 and later)
* Strings::                     Reading and Writing Character String Values
* Fill Values::                 What's Written Where there's No Data?
* ncmpi_rename_var::            Rename a Variable (collective)
* ncmpi_iput_var@var{<kind>}_@var{<type>}:: Non-blocking APIs for Writing a Subarray
* ncmpi_iget_var@var{<kind>}_@var{<type>}:: Non-blocking APIs for Reading a Subarray
* ncmpi_iput_varn_@var{<type>}:: Non-blocking APIs for Writing a List of Subarrays (1.6.0 and later)
* ncmpi_iget_varn_@var{<type>}:: Non-blocking APIs for Reading a List of Subarrays (1.6.0 and later)
* ncmpi_bput_var@var{<kind>}_@var{<type>}:: Non-blocking Buffered-version APIs for Writing a Subarray (1.3.0 and later)
* ncmpi_bput_varn_@var{<type>}:: Non-blocking Buffered-version APIs for Writing a List of subarrays (1.6.0 and later)
* ncmpi_wait/wait_all::         Wait function for Non-blocking APIs
* ncmpi_inq_nreqs::             inquire number of pending nonblocking requests (1.4.0 and later)
* ncmpi_inq_buffer Family::     inquire information about the attached buffer used by buffered put APIs
* ncmpi_cancel::                cancel one or more pending nonblocking requests

Attributes
* Attributes Introduction::     What are Attributes?
* ncmpi_put_att_@var{<type>}::  Write an Attribute (collective)
* ncmpi_inq_att Family::        Get Information about an Attribute
* ncmpi_get_att_@var{<type>}::  Read an Attribute
* ncmpi_copy_att::              Copy an Attribute (collective)
* ncmpi_rename_att::            Rename an Attribute (collective)
* ncmpi_del_att::               Delete an Attribute (collective)

Run-time Environment Variables
* PNETCDF_SAFE_MODE::     Enable/disable checking for data consistency (1.4.0 and later)
* PNETCDF_VERBOSE_DEBUG_MODE::     Enable/disable printing verbose debugging messages (1.7.0 and later)
* PNETCDF_HINTS::         I/O hints for performance improvement (1.4.0 and later)

Utility programs
* ncmpidiff::       Compare two netCDF files and report differences
* cdfdiff::         A serial version of ncmpidiff (1.12.0 and later)
* pnetcdf_version:: Report version information of PnetCDF library (1.5.0 and later)
* ncoffsets::       Report starting/ending file offsets of netCDF variables (1.7.0 and later)
* ncvalidator::  Validates a classic netCDF file against CDF file formats (1.9.0 and later)
* pnetcdf-config::  Report configure options used to build PnetCDF library (1.8.0 and later)
@end detailmenu
@end menu

@node Use of the PnetCDF Library, Files, Top, Top
@chapter Use of the PnetCDF Library
@findex ncmpi_create, typical use
@findex ncmpi_def_dim, typical use
@findex ncmpi_def_var, typical use
@findex ncmpi_put_att, typical use
@findex ncmpi_enddef, typical use
@findex ncmpi_put_var, typical use
@findex ncmpi_close, typical use
@cindex creating a file
@cindex abnormal termination
@cindex call sequence, typical
@cindex templates, code
@cindex code templates

You can use the PnetCDF library without knowing about all of the PnetCDF
interface. If you are creating a netCDF file, only a handful of
routines are required to define the necessary dimensions, variables,
and attributes, and to write the data to the netCDF file. (Even
less are needed if you use the ncmpigen utility to create the file
before running a program using PnetCDF library calls to write data.)
Similarly, if you are writing software to access data stored in a
particular netCDF object, only a small subset of the PnetCDF library is
required to open the netCDF file and access the data. Authors of
generic applications that access arbitrary netCDF files need to be
familiar with more of the PnetCDF library.

In this chapter we provide templates of common sequences of PnetCDF
calls needed for common uses. For clarity we present only the names of
routines; omit declarations and error checking; omit the type-specific
suffixes of routine names for variables and attributes; indent
statements that are typically invoked multiple times; and use ... to
represent arbitrary sequences of other statements. Full parameter
lists are described in later chapters.

@menu
* Creating::                    Creating a NetCDF file
* Reading Known ::              Reading a NetCDF file with Known Names
* Reading Unknown ::            Reading a netCDF file with Unknown Names
* Adding::                      Adding New Dimensions, Variables, Attributes
* Nonblocking Write::           Nonblocking write to one or more variables
* Nonblocking Read::            Nonblocking read from one or more variables
* Errors::                      Error Handling
* Compiling::                   Compiling and Linking with the PnetCDF Library
@end menu

@node Creating, Reading Known , Use of the PnetCDF Library, Use of the PnetCDF Library
@section Creating a NetCDF file
@findex ncmpi_create, typical use
@findex ncmpi_enddef, typical use
@findex ncmpi_begin_indep_data, typical use
@findex ncmpi_end_indep_data, typical use
@findex ncmpi_close, typical use
@cindex creating a new netCDF file

Here is a typical sequence of PnetCDF calls to create a new netCDF file:

@example
ncmpi_create                     /* create netCDF file and enter define mode (collective) */
       ...
ncmpi_def_dim                    /* define dimensions: from name and length (collective) */
       ...
ncmpi_def_var                    /* define variables: from name, type, ... (collective) */
       ...
ncmpi_put_att                    /* put attribute: assign attribute values (collective) */
       ...
ncmpi_enddef                     /* end definitions: leave define mode (collective) */
       ...
ncmpi_put_var@var{<kind>}_@var{<type>}_all   /* (collectively) write values of a variable (collective) */
       ...
ncmpi_begin_indep_data           /* enter independent data mode (collective) */
       ...
ncmpi_put_var@var{<kind>}_@var{<type>}       /* write values of a variable (independent) */
       ...
ncmpi_end_indep_data             /* exiting independent data mode (collective) */
       ...
ncmpi_close                      /* close: save new netCDF file (collective) */
@end example

Only one call is needed to create a netCDF file, at which point you
will be in the first of two netCDF modes. When accessing an open
netCDF file, it is in either define mode or data mode. In define
mode, you can create dimensions, variables, and new attributes, but
you cannot read or write variable data. In data mode, you can access
data and change existing attributes, but you are not permitted to
create new dimensions, variables, or attributes.

One call to ncmpi_def_dim is needed for each dimension
created. Similarly, one call to ncmpi_def_var is needed for each variable
creation, and one call to a member of the ncmpi_put_att family is needed
for each attribute defined and assigned a value. To leave define mode
and enter data mode, call ncmpi_enddef.

Once in data mode, you can add new data to variables, change old
values, and change values of existing attributes (so long as the
attribute changes do not require more storage space). Single values
may be written to a netCDF variable with one of the members of the
ncmpi_put_var1 family, depending on what type of data you have to
write. All the values of a variable may be written at once with one of
the members of the ncmpi_put_var family. Arrays or array cross-sections
of a variable may be written using members of the ncmpi_put_vara
family. Subsampled array sections may be written using members of the
ncmpi_put_vars family. Mapped array sections may be written using members
of the ncmpi_put_varm family. (Subsampled and mapped access are general
forms of data access that are explained later.)

Finally, you should explicitly close all netCDF files that have
been opened for writing by calling ncmpi_close. PnetCDF might cache file
header locally. If a program terminates
abnormally with netCDF files open for writing, your most recent
modifications may be lost.

@node Reading Known , Reading Unknown , Creating, Use of the PnetCDF Library
@section Reading a NetCDF file with Known Names
@findex ncmpi_inq_dimid, typical use
@findex ncmpi_inq_varid, typical use
@findex ncmpi_get_att, typical use
@findex ncmpi_get_var, typical use
@cindex reading netCDF file with known names

Here we consider the case where you know the names of not only the
netCDF files, but also the names of their dimensions, variables,
and attributes. (Otherwise you would have to do "inquire" calls.) The
order of typical C calls to read data from those variables in a netCDF
file is:

@example
ncmpi_open                       /* open existing netCDF file (collective) */
    ...
ncmpi_inq_dimid                  /* use file ID to get dimension IDs (independent) */
    ...
ncmpi_inq_varid                  /* use file ID to get variable IDs (independent) */
    ...
ncmpi_get_att                    /* use variable ID to get the variable's attribute values (independent) */
    ...
ncmpi_inq_varndims               /* get the number of dimensions of variable (independent) */
    ...
ncmpi_inq_vardimid               /* get the dimension IDs of the variable (independent) */
    ...
ncmpi_inq_dimlen                 /* for each dimension ID, get the dimension size (independent) */
    ...
/* use the variable's dimension information to allocate read buffer */
    ...
ncmpi_get_var@var{<kind>}_@var{<type>}_all   /* read values of a variable (collective) */
    ...
ncmpi_close                      /* close netCDF file (collective) */
@end example

First, a single call opens the netCDF file, given the file name,
and returns a netCDF ID that is used to refer to the opened netCDF
file in all subsequent calls.
Next, one can make a call to ncmpi_inq_dimid to inquire the dimension ID of a
given known dimension name.
Similarly, each required
variable ID is determined from its name by a call to ncmpi_inq_varid. Once
variable IDs are known, variable attribute values can be retrieved
using the netCDF ID, the variable ID, and the desired attribute name
as input to a member of the ncmpi_get_att family (typically
ncmpi_get_att_text or ncmpi_get_att_double) for each desired attribute.
The IDs of dimensions used to defined a variable can be obtained by calling ncmpi_inq_vardimid.
Together with ncmpi_inq_dimlen, which returns the size of a dimension, the dimension shape and size can be known and a read buffer can be allocated.
Variable data values can be directly accessed from the
netCDF file with calls to members of the ncmpi_get_var1 family for
single values, the ncmpi_get_var family for entire variables, or various
other members of the ncmpi_get_vara, ncmpi_get_vars, or ncmpi_get_varm families
for array, subsampled or mapped access.

Finally, the netCDF file is closed with ncmpi_close.
Close the file even if it is opened only for reading.

@heading Full example C program
@itemize
@item
@url{https://github.com/Parallel-NetCDF/PnetCDF/tree/master/examples/C/get_vara.c, get_vara.c}
@end itemize

@node Reading Unknown , Adding, Reading Known , Use of the PnetCDF Library
@section Reading a netCDF file with Unknown Names
@findex ncmpi_inq, typical use
@findex ncmpi_inq_dim, typical use
@findex ncmpi_inq_var, typical use
@findex ncmpi_inq_att, typical use
@findex ncmpi_get_att, typical use
@findex ncmpi_get_attname, typical use
@findex ncmpi_get_var, typical use
@cindex reading netCDF file with unknown names

It is possible to write programs (e.g., generic software) which do
such things as processing every variable, without needing to know in
advance the names of these variables. Similarly, the names of
dimensions and attributes may be unknown.

Names and other information about netCDF objects may be obtained from
netCDF files by calling inquire functions. These return information
about a whole netCDF file, a dimension, a variable, or an
attribute. The following template illustrates how they are used:

@example
    ncmpi_open                          /* open existing netCDF file */
      ...
    ncmpi_inq                           /* find out what is in it */
         ...
       ncmpi_inq_dim                    /* get dimension names, lengths */
         ...
       ncmpi_inq_var                    /* get variable names, types, shapes */
            ...
          ncmpi_inq_attname             /* get attribute names */
            ...
          ncmpi_inq_att                 /* get attribute types and lengths */
            ...
          ncmpi_get_att                 /* get attribute values */
            ...
       ncmpi_get_var@var{<kind>}_@var{<type>}_all   /* (collectively) read values of a variable */
         ...
    ncmpi_close                         /* close netCDF file */
@end example

As in the previous example, a single call opens the existing netCDF
file, returning a netCDF ID. This netCDF ID is given to the ncmpi_inq
routine, which returns the number of dimensions, the number of
variables, the number of global attributes, and the ID of the
unlimited dimension, if there is one.

All the inquire functions are inexpensive to use and require no I/O,
since the information they provide is stored in memory when a netCDF
file is first opened.

Dimension IDs use consecutive integers, beginning at 0. Also
dimensions, once created, cannot be deleted. Therefore, knowing the
number of dimension IDs in a netCDF file means knowing all the
dimension IDs: they are the integers 0, 1, 2, ... up to the number of
dimensions. For each dimension ID, a call to the inquire function
ncmpi_inq_dim returns the dimension name and length.

Variable IDs are also assigned from consecutive integers 0, 1, 2,
... up to the number of variables. These can be used in ncmpi_inq_var
calls to find out the names, types, shapes, and the number of
attributes assigned to each variable.

Once the number of attributes for a variable is known, successive
calls to ncmpi_inq_attname return the name for each attribute given the
netCDF ID, variable ID, and attribute number. Armed with the attribute
name, a call to ncmpi_inq_att returns its type and length. Given the type
and length, you can allocate enough space to hold the attribute
values. Then a call to a member of the ncmpi_get_att family returns the
attribute values.

Once the IDs and shapes of netCDF variables are known, data values can
be accessed by calling a member of the ncmpi_get_var1 family for single
values, or members of the ncmpi_get_var, ncmpi_get_vara, ncmpi_get_vars, or
ncmpi_get_varm for various kinds of array access.

@heading Full example C program
@itemize
@item
@url{https://github.com/Parallel-NetCDF/PnetCDF/tree/master/examples/tutorial/pnetcdf-read-standard.c, pnetcdf-read-standard.c}
@end itemize


@node Adding, Nonblocking Write, Reading Unknown , Use of the PnetCDF Library
@section Adding New Dimensions, Variables, Attributes
@findex ncmpi_redef, typical use
@findex ncmpi_def_dim, typical use
@findex ncmpi_put_att, typical use
@cindex dimensions, adding
@cindex variables, adding
@cindex attributes, adding
@cindex aborting define mode
@cindex aborting definitions
@cindex adding dimensions
@cindex adding attributes
@cindex adding variables
@cindex attributes, deleting, introduction

An existing netCDF file can be extensively altered. New dimensions,
variables, and attributes can be added or existing ones renamed, and
existing attributes can be deleted. Existing dimensions, variables,
and attributes can be renamed. The following code template lists a
typical sequence of calls to add new netCDF components to an existing
file:

@example
    ncmpi_open             /* open existing netCDF file */
      ...
    ncmpi_redef            /* put it into define mode */
        ...
      ncmpi_def_dim        /* define additional dimensions (if any) */
        ...
      ncmpi_def_var        /* define additional variables (if any) */
        ...
      ncmpi_put_att        /* define additional attributes (if any) */
        ...
    ncmpi_enddef           /* check definitions, leave define mode */
        ...
      ncmpi_put_var        /* provide values for new variables */
        ...
    ncmpi_close            /* close netCDF file */
@end example

A netCDF file is first opened by the ncmpi_open call. This call puts
the opened file in data mode, which means existing data values can be
accessed and changed, existing attributes can be changed (so long as
they do not grow), but nothing can be added. To add new netCDF
dimensions, variables, or attributes you must enter define mode, by
calling ncmpi_redef. In define mode, call ncmpi_def_dim to define new
dimensions, ncmpi_def_var to define new variables, and a member of the
ncmpi_put_att family to assign new attributes to variables or enlarge old
attributes.

You can leave define mode and reenter data mode, checking all the new
definitions for consistency and committing the changes to disk, by
calling ncmpi_enddef. If you do not wish to reenter data mode, just call
ncmpi_close, which will have the effect of first calling ncmpi_enddef.

Until the ncmpi_enddef call, you may back out of all the redefinitions
made in define mode and restore the previous state of the netCDF
file by calling ncmpi_abort. You may also use the ncmpi_abort call to
restore the netCDF file to a consistent state if the call to
ncmpi_enddef fails. If you have called ncmpi_close from definition mode and
the implied call to ncmpi_enddef fails, ncmpi_abort will automatically be
called to close the netCDF file and leave it in its previous
consistent state (before you entered define mode).

@node Nonblocking Write, Nonblocking Read, Adding, Use of the PnetCDF Library
@section Nonblocking Write
@findex ncmpi_iput_var, typical use
@findex ncmpi_bput_var, typical use
@findex ncmpi_wait_all, typical use
@findex ncmpi_buffer_attach, typical use
@findex ncmpi_buffer_detach, typical use
@cindex nonblocking write to a netCDF variable

PnetCDF nonblocking APIs allow users to first post multiple requests and later
flush them altogether in order to achieve a better performance. A common
practice is writing (or reading) subarrays to (from) multiple variables, e.g.
one or more subarrays for each variable defined in the NetCDF file. Without the
need of immediate commitment of each request, nonblocking APIs allows PnetCDF
to aggregate the posted requests (often noncontiguous and relatively of small
size) into a contiguous large one, which is handled more efficiently by the
underneath MPI-IO library and file systems. Programming of nonblocking APIs
consists of two parts: posting the nonblocking requests and later flushing the
pending requests. APIs ncmpi_wait_all and ncmpi_wait flush the pending requests
by aggregating them into a single MPI-IO call. Here is a typical sequence of
PnetCDF API calls to use nonblocking APIs to write to a netCDF file:

@example
    ncmpi_create                        /* create netCDF file and enter define mode */
         ...
    ncmpi_enddef                        /* end definitions: leave define mode */
         ...
       ncmpi_iput_var@var{<kind>}_@var{<type>}      /* post a nonblocking write request to a variable */
         ...
       ncmpi_iput_var@var{<kind>}_@var{<type>}      /* post another nonblocking write request to the same or a different variable */
         ...
       ncmpi_wait_all                   /* commit the posted nonblocking requests */
         ...
       ncmpi_buffer_attach              /* tell PnetCDF the amount of space for write request cache */
         ...
       ncmpi_bput_var@var{<kind>}_@var{<type>}      /* post a buffered nonblocking write request to a variable */
         ...
       ncmpi_bput_var@var{<kind>}_@var{<type>}      /* post another buffered nonblocking write request to a variable */
         ...
       ncmpi_wait_all                   /* commit the posted nonblocking requests */
         ...
       ncmpi_buffer_detach              /* tell PnetCDF to free the write cache */
         ...
    ncmpi_close                         /* close: save new netCDF file */
@end example

Nonblocking APIs are not collective. They can be called in either collective or
independent data mode. Starting from 1.7.0, the nonblocking APIs can also be
called in define mode. Multiple nonblocking I/O requests can be posted and the
number of nonblocking requests can be different among MPI processes.

There are two wait APIs for committing the pending nonblocking requests:
ncmpi_wait_all() to be called in the collective data mode and
ncmpi_wait() in the independent data mode.

@heading Limitations
For write operations, there are also two kinds of nonblocking APIs, one with
the name "iput" and the other "bput".  For "iput" APIs, users should not alter
the contents of the write buffer once the request is posted until the wait API
is returned. Any change to the buffer contents in between will result in
unexpected error.

The write buffer used in one "iput" call should not be reused in another
"put/get" API call (blocking or nonblocking) and buffers used in different
"iput/put/iget/get" API calls should not overlap. Currently, PnetCDF does not
detect whether user buffers are reused or overlapped.

To alleviate the above limitation, the "bput" API family can be used to save a
copy of the request into an internal memory cache. Thus, once a bput
nonblocking request is posted, users are free to change the contents of the
write buffer. Before using "bput" APIs, users are required to tell PnetCDF the
amount of space (the high water mark, not total) allowed to cache the write
requests. The two APIs that tell PnetCDF to allocate the cache amount and
to free the space are ncmpi_buffer_attach() and ncmpi_buffer_detach(),
respectively.

@heading Examples
Using ncmpi_iput_var<kind>:
@example
int req[NUM_VARS], statuses[NUM_VARS];

/* write to one variable at a time using iput */
for (i=0; i<NUM_VARS; i++) @{
     err = @ref{ncmpi_iput_var@var{<kind>}_@var{<type>}, ncmpi_iput_vara_int}(ncid, varids[i], starts, counts, buf[i], &req[i]);
     handle_error(err);
@}
/* Note the data contents in write buffer buf[i] should not be touched */

/* wait for the nonblocking writes to complete */
err = @ref{ncmpi_wait/wait_all, ncmpi_wait_all}(ncid, NUM_VARS, req, statuses);
if (err != NC_NOERR) @{
    handle_error(err);

    /* check errors for individual requests */
    for (i=0; i<NUM_VARS; i++)
        handle_error(statuses[i]);
@}
/* Only after ncmpi_wait_all returns, the contents in buf[i] can be changed */
@end example

Using ncmpi_bput_var<kind>:
@example
int req[NUM_VARS], statuses[NUM_VARS];

/* attach an internal buffer of size equal to the sum of all requests */
err = @ref{ncmpi_bput_var@var{<kind>}_@var{<type>}, ncmpi_buffer_attach}(ncid, SUM_OF_ALL_REQUESTS);
if (err != NC_NOERR) handle_error(err);

/* write to one variable at a time using bput */
for (i=0; i<NUM_VARS; i++) @{
     err = @ref{ncmpi_bput_var@var{<kind>}_@var{<type>}, ncmpi_bput_vara_int}(ncid, varids[i], starts, counts, buf[i], &req[i]);
     handle_error(err);
@}
/* Note the data contents of write buffer buf[i] can be freely changed, because
 * they have been copied to a PnetCDF internal memory buffer of size set in the
 * call to ncmpi_buffer_attach(), Any content change to buf[i] after bput call
 * returns will not appear in the file..*/

/* wait for the nonblocking writes to complete */
err = @ref{ncmpi_wait/wait_all, ncmpi_wait_all}(ncid, NUM_VARS, req, statuses);
if (err != NC_NOERR) @{
    handle_error(err);

    /* check errors for individual requests */
    for (i=0; i<NUM_VARS; i++)
        handle_error(statuses[i]);
@}

/* release the internal buffer */
err = @ref{ncmpi_bput_var@var{<kind>}_@var{<type>}, ncmpi_buffer_detach}(ncid);
handle_error(err);
@end example

@node Nonblocking Read, Errors, Nonblocking Write, Use of the PnetCDF Library
@section Nonblocking Read
@findex ncmpi_iget_var, typical use
@findex ncmpi_wait_all, typical use
@cindex nonblocking read from a netCDF variable

PnetCDF nonblocking APIs allow users to aggregate multiple (small) requests
into a single large one, and hence to achieve a better I/O performance.
Programming of nonblocking APIs consists of two parts: posting the nonblocking
requests and later committing the requests. APIs ncmpi_wait_all and
ncmpi_wait commit the pending requests by aggregating them into a single MPI-IO
call. Here is a typical sequence of PnetCDF API calls to use nonblocking APIs
to read from a netCDF file:

@example
    ncmpi_open                          /* open an existing netCDF file: enter data mode */
         ...
       ncmpi_iget_var@var{<kind>}_@var{<type>}      /* post a nonblocking read request to a variable */
         ...
       ncmpi_iget_var@var{<kind>}_@var{<type>}      /* post another nonblocking read request to the same or a different variable */
         ...
       ncmpi_wait_all                   /* commit the posted nonblocking requests */
         ...
    ncmpi_close                         /* close the netCDF file */
@end example

Nonblocking APIs are not collective. They can be called in either collective or
independent data mode. Starting from 1.7.0, the nonblocking APIs can be called
in define mode as well. Multiple nonblocking I/O requests can be posted and the
number of nonblocking requests can be different among MPI processes.

There are two wait APIs: ncmpi_wait_all() is to be called in the collective
data mode and ncmpi_wait() in the independent data mode.

@heading Limitations
For "iget" APIs, users should not alter the contents of the read buffer once
the request is posted until the wait API call is returned. Any change to the
buffer in between will result in unexpected error.

The read buffer used in one "iget" call should not be reused in another
"get/put" API call (blocking or nonblocking) and two buffers used in different
"iget/get/iput/put" API calls should not overlap. Currently, PnetCDF does not
detect whether user buffers are reused or overlapped.

@heading Examples

@example
int req[NUM_VARS], statuses[NUM_VARS];

/* read from one variable at a time using iget */
for (i=0; i<NUM_VARS; i++) @{
     err = @ref{ncmpi_iget_var@var{<kind>}_@var{<type>}, ncmpi_iget_vara_int}(ncid, varids[i], starts, counts, buf[i], &req[i]);
     handle_error(err);
@}

/* wait for the nonblocking reads to complete */
err = @ref{ncmpi_wait/wait_all, ncmpi_wait_all}(ncid, NUM_VARS, req, statuses);
if (err != NC_NOERR) @{
    handle_error(err);

    /* check errors for individual requests */
    for (i=0; i<NUM_VARS; i++)
        handle_error(statuses[i]);
@}
@end example

@node Errors, Compiling, Nonblocking Read, Use of the PnetCDF Library
@section Error Handling
@findex ncmpi_strerror, introduction
@cindex error handling
@cindex write errors

The netCDF library provides the facilities needed to handle errors in
a flexible way. Each PnetCDF function returns an integer status
value. If the returned status value indicates an error, you may handle
it in any way desired, from printing an associated error message and
exiting to ignoring the error indication and proceeding (not
recommended!). For simplicity, the examples in this guide check the
error status and call a separate function, handle_err(), to handle any
errors. One possible definition of handle_err() can be found within the
documentation of ncmpi_strerror (@pxref{ncmpi_strerror}).

The ncmpi_strerror function is available to convert a returned integer
error status into an error message string.

Occasionally, low-level I/O errors may occur in a layer below the
PnetCDF library. For example, if a write operation causes you to exceed
disk quotas or to attempt to write to a device that is no longer
available, you may get an error from a layer below the PnetCDF library,
but the resulting write error will still be reflected in the returned
status value.

@node Compiling,  , Errors, Use of the PnetCDF Library
@section Compiling and Linking with the PnetCDF Library
@cindex linking to PnetCDF library
@cindex compiling with PnetCDF library

Details of how to compile and link a program that uses the PnetCDF C or
FORTRAN interfaces differ, depending on the operating system, the
available compilers, and where the PnetCDF library and include files
are installed. Nevertheless, we provide here examples of how to
compile and link a program that uses the PnetCDF library on a Unix
platform, so that you can adjust these examples to fit your
installation.

@heading Building and Installing PnetCDF Library
Full instructions of building and installing PnetCDF library are described in
the file named INSTALL come with every release of
@url{https://parallel-netcdf.github.io/wiki/Download.html, PnetCDF source codes}.
An example configure command and output are given below.
@example
% ./configure --prefix=$HOME/PnetCDF/1.12.0 --enable-shared --with-mpi=/usr

------------------------------------------------------------------------------

   PnetCDF Version 1.12.0

   Features:  Build static libraries                      - yes
              Build shared libraries                      - yes
              Build Fortran APIs                          - yes
              Build C++ APIs                              - yes

   Compilers: MPICC    = /usr/bin/mpicc
              MPICXX   = /usr/bin/mpicxx
              MPIF77   = /usr/bin/mpif77
              MPIF90   = /usr/bin/mpif90
              CFLAGS   = -g -O2
              CXXFLAGS = -g -O2
              FFLAGS   = -g -O2
              FCFLAGS  = -g -O2

   Now run 'make' to build the library and utility tools.
   Then run 'make [<target>]' for testing and installation, where the
   optional <target> can be:
              tests    - build all test programs (build only, no run)
              check    - run sequential test programs
              ptest    - run parallel test programs on 4 MPI processes
              ptests   - run parallel test programs on 3,4,6,8 MPI processes
              install  - install PnetCDF library in $HOME/PnetCDF/1.12.0

------------------------------------------------------------------------------
@end example
In this example, configure command uses the MPI compilers installed under the
folder of /usr, where the MPI header files can be found under /usr/include,
MPI compiler commands and utility programs can be found under /usr/bin, and
MPI library files can be found under /usr/lib.
The location of PnetCDF library to be install is is specified by option
--prefix which is the folder PnetCDF/1.12.0 under the user's home folder.

Command to build PnetCDF library is
@example
% make
@end example
Command to install PnetCDF library is
@example
% make install
@end example
At the end of installation process, the following message should appear.
@example
+----------------------------------------------------------------------------+
|
|  PnetCDF has been successfully installed under
|          $HOME/PnetCDF/1.12.0
|
|  * PnetCDF header files have been installed in
|          $HOME/PnetCDF/1.12.0/include
|  * PnetCDF library files have been installed in
|          $HOME/PnetCDF/1.12.0/lib
|  * PnetCDF utility programs have been installed in
|          $HOME/PnetCDF/1.12.0/bin
|  * PnetCDF man pages have been installed in
|          $HOME/PnetCDF/1.12.0/share/man
|
|  To compile your PnetCDF programs, please add the following to the command
|  line, so the compiler can find the PnetCDF header files:
|      -I$HOME/PnetCDF/1.12.0/include
|
|  Add the following line to link your program to PnetCDF library:
|      -L$HOME/PnetCDF/1.12.0/lib -lpnetcdf
|
|  Add the following to your run-time environment variable LD_LIBRARY_PATH,
|  when linking your executable with the PnetCDF shared libraries.
|      $HOME/PnetCDF/1.12.0/lib
|
|
|  PnetCDF is jointly developed by a team at Northwestern University and
|  Argonne National Laboratory.
|
|  Visit PnetCDF project web site for more information
|      https://parallel-netcdf.github.io
|
+----------------------------------------------------------------------------+
@end example

@heading Compiling Your User Programs
Every C file that references PnetCDF functions or constants must
contain an appropriate #include statement before the first such
reference:

@example
#include <pnetcdf.h>
@end example

For Fortran programs, the header file is pnetcdf.inc for Fortran 77
and the module file is pnetcdf.mod for Fortran 90 and later.
The following code statement should be used in the user programs.
For Fortran 77
@example
include "pnetcdf.inc"
@end example
For Fortran 90 and later
@example
use pnetcdf
@end example

These three files pnetcdf.h, pnetcdf.inc, and pnetcdf.mod are installed in the
same location. Unless they are installed in a standard directory where the C
and Fortran compilers always look, you must use the -I option when invoking the
compiler, to specify a directory where pnetcdf.h is installed, for example:
@example
/usr/bin/mpicc -O2 -c -I$HOME/PnetCDF/1.12.0/include myprogram.c
@end example
or for Fortran
@example
/usr/bin/mpifort -O2 -c -I$HOME/PnetCDF/1.12.0/include myprogram.f
@end example

Unless the PnetCDF library is installed in a standard directory where
the linker always looks, you must use the -L and -l options to link an
object file that uses the PnetCDF library. For example:
@example
/usr/bin/mpicc -O2 -o myprogram myprogram.o -L$HOME/PnetCDF/1.12.0/lib -lpnetcdf
@end example
or for Fortran
@example
/usr/bin/mpifort -O2 -o myprogram myprogram.o -L$HOME/PnetCDF/1.12.0/lib -lpnetcdf
@end example

@heading Running Your User Program
If PnetCDF is configured with --enable-shared option, then one may need to add
the installation path of PnetCDF to the environment variable before running.
For bash shell,
@example
export LD_LIBRARY_PATH=$HOME/PnetCDF/1.12.0/lib
@end example
For csh or tcsh shell,
@example
setenv LD_LIBRARY_PATH $HOME/PnetCDF/1.12.0/lib
@end example
If PnetCDF is configured and built with static library only (default), then
one can skip the above setting for environment variable LD_LIBRARY_PATH.

An example command to run the user program in parallel using 4 MPI processes
is shown below.
@example
/usr/bin/mpiexec -n 4 ./myprogram
@end example

@node Files, Dimensions, Use of the PnetCDF Library, Top
@chapter Files
@cindex files, overview

This chapter presents the interfaces of the PnetCDF functions that deal
with a netCDF file or the whole PnetCDF library.

A netCDF file that has not yet been opened can only be referred to
by its file name. Once a netCDF dataset is opened, it is referred
to by a netCDF ID, which is a small non-negative integer returned when
you create or open the file. A netCDF ID is much like a file
descriptor in C or a logical unit number in FORTRAN. In any single
program, the netCDF IDs of distinct opened netCDF files are
distinct. A single netCDF file may be opened multiple times and
will then have multiple distinct netCDF IDs; however at most one of
the open instances of a single netCDF file should permit
writing. When an opened netCDF file is closed, the ID is no longer
associated with a netCDF file.

Functions that deal with the PnetCDF library include:
@itemize

@item
Get version of library.

@item
Get error message corresponding to a returned error code.
@end itemize

The operations supported on a netCDF file as a single object are:
@itemize

@item
Create, given file name and whether to overwrite or not.

@item
Open for access, given file name and read or write intent.

@item
Put into define mode, to add dimensions, variables, or attributes.

@item
Take out of define mode, checking consistency of additions.

@item
Close, writing to disk if required.

@item
Inquire about the number of dimensions, number of variables, number of
global attributes, and ID of the unlimited dimension, if any.

@item
Synchronize to disk to make sure it is current.

@item
Set and unset nofill mode for optimized sequential writes.

@item
After a summary of conventions used in describing the PnetCDF
interfaces, the rest of this chapter presents a detailed description
of the interfaces for these operations.
@end itemize

@menu
* Interface Descriptions::      What's in the Function Documentation
* ncmpi_strerror::                 Get error string from error code
* ncmpi_strerrno::                 Get string name of an error code (1.8.0 and later)
* ncmpi_inq_libvers::              Get PnetCDF library version
* ncmpi_create::                   Create a File
* ncmpi__create::                  Create a File with Performance Tuning (not implemented)
* ncmpi_open::                     Open a File
* ncmpi__open::                    Open a File with Performance Tuning (not implemented)
* ncmpi_redef::                    Put a File into Define Mode
* ncmpi_enddef::                   Leave Define Mode
* ncmpi__enddef::                  Leave Define Mode with Performance Tuning (1.5.0 and later)
* ncmpi_close::                    Close a File
* ncmpi_inq Family::               Inquire about a File
* ncmpi_sync::                     Synchronize a File to Disk
* ncmpi_abort::                    Back Out of Recent Definitions
* ncmpi_set_fill::                 Set Fill Mode for Writes (1.6.1 and later)
* ncmpi_set_default_format::       Change the default output format (1.6.1 and later)
* ncmpi_begin_indep_data::         Enter independent parallel data access mode
* ncmpi_end_indep_data::           Exit independent data mode
* ncmpi_inq_put_size::             Inquire the amount of data put to file so far (1.4.0 and later)
* ncmpi_inq_get_size::             Inquire the amount of data got from file so far (1.4.0 and later)
* ncmpi_inq_header_size::          Inquire the size of the file header (1.4.0 and later)
* ncmpi_inq_header_extent::        Inquire the file header extent (1.4.0 and later)
* ncmpi_sync_numrecs::             Synchronize the number of records (1.4.0 and later)
* ncmpi_delete::                   Delete a file
* ncmpi_inq_file_info::            Obtain the MPI Info object that contains all the I/O hints currently used (1.5.0 and later)
* ncmpi_get_file_info::            Obtain the MPI Info object that contains all the I/O hints currently used (deprecated)
* ncmpi_inq_files_opened::         Reports the number of files that are currently opened (1.5.0 and later)
@end menu

@node Interface Descriptions, ncmpi_strerror, Files, Files
@section PnetCDF Library Interface Descriptions
@cindex interface descriptions

Each interface description for a particular PnetCDF function in this
and later chapters contains:

@itemize

@item
a description of the purpose of the function (API);

@item
whether the API is called while the file is in define or data mode;

@item
whether the API is collective (to be called by all processes opening the same file) or independent (to be called independently from other processes);

@item
a C function prototype that presents the type and order of the formal
parameters to the function;

@item
a description of each formal parameter in the C interface;

@item
a list of possible error conditions; and

@item
an example of a C program fragment calling the PnetCDF function (and
perhaps other PnetCDF functions).
@end itemize

The examples follow a simple convention for error handling, always
checking the error status returned from each PnetCDF function call and
calling a handle_error function in case an error was detected. For an
example of such a function, see @ref{ncmpi_strerror}.

@node ncmpi_strerror, ncmpi_strerrno, Interface Descriptions, Files
@section Get error message corresponding to error status: ncmpi_strerror
@findex ncmpi_strerror
@findex handle_err
@cindex error codes
@cindex ncmpi_strerror, example

The function ncmpi_strerror returns a static reference to an error
message string corresponding to an integer netCDF error status or to a
system error number, presumably returned by a previous call to some
other PnetCDF function. The list of netCDF error status codes is
available in the appropriate include file for each language binding.

@heading Operational Mode
This API is not associated to any opened file and hence can be called anytime.

@heading Usage
@example
const char * ncmpi_strerror(int ncerr);
@end example

@table @code
@item ncerr
An error status that might have been returned from a previous call to
some PnetCDF function.
@end table

@heading Errors

If you provide an invalid integer error status that does not
correspond to any netCDF error message or or to any system error
message (as understood by the system strerror function), ncmpi_strerror
returns a string indicating that there is no such error status.

@heading Example

Here is an example of a simple error handling function that uses
ncmpi_strerror to print the error message corresponding to the netCDF
error status returned from any PnetCDF function call and then abort the MPI program:

@example
#include <pnetcdf.h>
   ...
void handle_error(int status) @{
    if (status != NC_NOERR) @{
        fprintf(stderr, "%s\n", @ref{ncmpi_strerror}(status));
        MPI_Abort(MPI_COMM_WORLD, -1);
    @}
@}
@end example

@node ncmpi_strerrno, ncmpi_inq_libvers, ncmpi_strerror, Files
@section Get the string name of a NC error code: ncmpi_strerrno
@findex ncmpi_strerrno
@cindex error codes
@cindex ncmpi_strerrno, example

The function ncmpi_strerrno returns a character string containing the
name of the NC error code.
For instance, ncmpi_strerrno(NC_EBADID) returns string "NC_EBADID".

@heading Operational Mode
This API is not associated to any opened file and hence can be called anytime.

@heading Usage
@example
const char * ncmpi_strerrno(int ncerr);
@end example

@table @code
@item ncerr
An error status that might have been returned from a previous call to
some PnetCDF function.
@end table

@heading Errors

If you provide an invalid integer error status that does not
correspond to any netCDF error message or or to any system error
message (as understood by the system strerror function), ncmpi_strerrno
returns a string indicating that there is no such error status.

@heading Example

Here is an example of a simple error handling function that uses
ncmpi_strerrno to print the error code name of a netCDF
error code returned from any PnetCDF function call.

@example
#include <pnetcdf.h>
   ...
void handle_error(int err) @{
    if (err != NC_NOERR) @{
        fprintf(stderr, "NC error code name: %s\n", @ref{ncmpi_strerrno}(err));
        MPI_Abort(MPI_COMM_WORLD, -1);
    @}
@}
@end example

@node ncmpi_inq_libvers, ncmpi_create, ncmpi_strerrno, Files
@section Get PnetCDF library version: ncmpi_inq_libvers
@findex ncmpi_inq_libvers
@cindex version of netCDF, discovering
@cindex PnetCDF library version
@cindex ncmpi_inq_libvers, example

The function ncmpi_inq_libvers returns a string identifying the version
of the PnetCDF library, and when it was built.

@heading Operational Mode
This API is not associated to any opened file and hence can be called anytime.

@heading Usage
@example
const char * ncmpi_inq_libvers(void);
@end example

@heading Errors

This function takes no arguments, and thus no errors are possible in
its invocation.

@heading Example

Here is an example using ncmpi_inq_libvers to print the version of the
PnetCDF library with which the program is linked:

@example
#include <pnetcdf.h>
  ...
printf("%s\n", @ref{ncmpi_inq_libvers}());
@end example
Example output:
@example
1.5.0 of 8 July 2014
@end example

@node ncmpi_create, ncmpi__create, ncmpi_inq_libvers, Files
@section Create a NetCDF File: ncmpi_create
@findex ncmpi_create
@cindex ncmpi_create, example
@cindex ncmpi_create, flags
@vindex NC_NOCLOBBER
@vindex NC_CLOBBER
@vindex NC_64BIT_OFFSET
@vindex NC_64BIT_DATA
@vindex nc_header_align_size
@vindex nc_var_align_size
@vindex nc_record_align_size
@vindex nc_header_read_chunk_size

This function creates a new netCDF file, returning a netCDF ID that
can subsequently be used to refer to the netCDF file in other
PnetCDF function calls. The new netCDF file opened for write access
and placed in define mode, ready for you to add dimensions, variables,
and attributes.

A creation mode flag specifies:
@itemize
@item
whether to overwrite any existing file with the same name,
@item
whether access to the file is shared,
@item
whether this file should be in netCDF classic format (the default), 64-bit offset format, or 64-bit data format.
@end itemize

@heading Operational Mode
This API is a collective routine.
All processes must provide the same value for cmode, and all processes must provide filenames that reference the same file. (Values for info may vary.)

@heading Usage

@example
int ncmpi_create (MPI_Comm    comm,
                  const char *path,
                  int         cmode,
                  MPI_Info    info,
                  int        *ncidp);
@end example

@table @code
@item comm
An MPI communicator and must be an MPI intracommunicator.

@item path
The file name of the new netCDF file.

@item cmode
The creation mode flag. The following flags are available:
NC_NOCLOBBER, NC_64BIT_OFFSET, and NC_64BIT_DATA.

Setting NC_NOCLOBBER means you do not want to clobber (overwrite) an
existing file; an error (NC_EEXIST) is returned if the specified
file already exists.

Setting NC_64BIT_OFFSET causes PnetCDF to create a 64-bit offset format file (CDF-2), instead of a netCDF classic format file. The 64-bit offset format imposes far fewer restrictions on large (i.e. over 2 GB) data files.
@c @xref{Large File Support,,, pnetcdf, @value{n-man}}.

Setting NC_64BIT_DATA causes PnetCDF to create a 64-bit data format file (CDF-5). The 64-bit data format allows define variables with more than 4 billion array elements.

It is illegal to set a cmode with both NC_64BIT_OFFSET and NC_64BIT_DATA. Error code NC_EINVAL_CMODE will be returned in this case.

A zero value (defined for convenience as NC_CLOBBER) specifies the
default behavior: overwrite any existing file with the same file
name and buffer and cache accesses for efficiency. The file will be
in netCDF classic format. @xref{NetCDF Classic Format Limitations,,,
netcdf, @value{n-man}}.

The following modes available in netCDF are not yet supported: NC_DISKLESS, NC_MMAP, NC_CLASSIC_MODEL, NC_NETCDF4, NC_MPIPOSIX, and NC_INMEMORY.

The following modes available in netCDF are ignored: NC_SHARE and NC_MPIIO.

@item info
An MPI info object that provides file access hints,including existing MPI hints
as well as PnetCDF hints. For MPI hints, users are referred to MPI user guide
for further information. Starting from version 1.3.1, the following
@ref{PNETCDF_HINTS,PnetCDF hints} are available:

@table @code
@item nc_header_align_size
This hint allows some extra space between the end of the header describing the
entire file and the first variable. If you have an application that
periodically wishes to add more variables or attributes to an already existing
file, expanding the file header size may result in an expensive move of the
entire data file to make room for the definition of the new metadata. Hence,
setting this hint to a value that is big enough to accommodate any additional
variables means you may leave your application code as-is and yet still see
tremendous performance improvements.

@item nc_var_align_size
If you are writing to a block-based parallel file system, such as IBM's GPFS or
Lustre, then an application's write request will be divided into several blocks
(file stripes) and each is sent to a file server based on the file striping
setting. If a write straddles two blocks, then locks must be acquired for both
blocks. Aligning the start of a variable to a block boundary, combined with
collective I/O optimizations in the MPI-IO library can often eliminate all
unaligned file system accesses.
Starting from version 1.13.0, this hint will only align the starting offset of
the entire data section, rather than individual fixed-size variables.

@item nc_record_align_size
This hint specifies the alignment size for the starting file offset of the
record variable section. Note this is not the alignment for individual record
variables.

@item nc_header_read_chunk_size
PnetCDF reads the file headers in chunks. This hint indicates the chunk size
(in bytes). The default is 256 KB.

@end table

Note the alignment hints set in the run-time environment variable
"PNETCDF_HINTS" have the highest priority, which overwrite the alignment hints
set in ncmpi__enddef(), which overwrite the alignment hints set in this
MPI_Info object.

@item ncidp
Pointer to location where returned netCDF ID is to be stored.
@end table

@heading Return Error Codes
ncmpi_create returns the value NC_NOERR if no errors occurred. Possible
causes of errors include:
@itemize
@item NC_EBAD_FILE: Invalid file name, file name too long, or the directory does not exist.
@item NC_EINVAL_CMODE: Invalid values used in file create mode. Note it is illegal to set a cmode with both NC_64BIT_OFFSET and NC_64BIT_DATA.
@item NC_EEXIST: Specifying a file name of a file that exists and also specifying NC_NOCLOBBER.
@item NC_EPERM: Attempting to create a netCDF file in a directory where you do not have permission to create files.
@item NC_ESMALL: size of MPI_Offset on the running system is too small for the file format (CDF-2 or CDF-5) in request
@item NC_ENOMEM: unable to allocate memory
@item NC_ENFILE: Too many files open
@item NC_EQUOTA: Quota exceeded
@item NC_ENO_SPACE: Not enough space
@item NC_EFILE: other unknown I/O error, including unable to clobber the file
@item NC_EMULTIDEFINE_CMODE: inconsistent file create modes among processes.
@item NC_EMULTIDEFINE_FNC_ARGS: one or more arguments are inconsistent among processes
@end itemize

@heading Examples

In this example we create a netCDF file named foo.nc; we want the
file to be created in the current directory only if a dataset with
that name does not already exist:

@example
#include <pnetcdf.h>
   ...
int err, ncid, cmode = NC_NOCLOBBER;
MPI_Info info;
   ...
MPI_Info_create (&info);
MPI_Info_set (info, "romio_no_indep_rw",    "true");
MPI_Info_set (info, "nc_header_align_size", "4194304");
MPI_Info_set (info, "nc_var_align_size",    "1048576");

err = @strong{ncmpi_create}(MPI_COMM_WORLD, "foo.nc", cmode, info, &ncid);
if (err != NC_NOERR) printf("Error: %s\n",ncmpi_strerror(err));
MPI_Info_free(&info);
@end example

The following example creates a netCDF file named foo_large.nc.
The new file will be in the 64-bit data format.

@example
#include <pnetcdf.h>
   ...
int err, cmode = NC_NOCLOBBER | NC_64BIT_DATA;
MPI_Info info = MPI_INFO_NULL;
   ...
err = @ref{ncmpi_create}(MPI_COMM_WORLD, "foo_large.nc", cmode, info, &ncid);
if (err != NC_NOERR) printf("Error: %s\n",ncmpi_strerror(err));
@end example

@node ncmpi__create, ncmpi_open, ncmpi_create, Files
@section Create a NetCDF File With Performance Options: ncmpi__create
This API is not implemented in PnetCDF.

@node ncmpi_open, ncmpi__open, ncmpi__create, Files
@section Open a NetCDF File for Access: ncmpi_open
@findex ncmpi_open
@cindex ncmpi_open, example
@vindex NC_NOWRITE
@vindex NC_WRITE
@vindex nc_header_read_chunk_size

The function ncmpi_open opens an existing netCDF file for access.

@heading Operational Mode
This API is a collective routine: all processes must provide the same value for cmode, and all processes must provide filenames that reference the same file. (Values for info may vary.)

@heading Usage

@example
int ncmpi_open (MPI_Comm    comm,
                const char *path,
                int         omode,
                MPI_Info    info,
                int        *ncidp);
@end example

@table @code

@item comm
An MPI communicator and must be an MPI intracommunicator.

@item path
File name for netCDF file to be opened.

@item omode
Either NC_NOWRITE or NC_WRITE.
@itemize @bullet
@item NC_NOWRITE specifies the default behavior: open the file with read-only access.
@item NC_WRITE is to open the file with read-write access. ("Writing" means any kind of change to the dataset, including appending or changing data, adding or renaming dimensions, variables, and attributes, or deleting attributes.)
@end itemize

The following modes available in netCDF are not yet supported: NC_DISKLESS, NC_MMAP, NC_CLASSIC_MODEL, NC_NETCDF4, NC_MPIPOSIX, and NC_INMEMORY.

The following modes available in netCDF are ignored: NC_SHARE and NC_MPIIO.

@item info
An MPI info object that provides information regarding file access patterns and file system specifics (see MPI user guide for further information).Starting from version 1.3.1, the following PnetCDF hints are available:
@table @code
@item nc_header_read_chunk_size
 PnetCDF reads the file headers in chunks. This hint indicates the chunk size (in bytes). The default is 256 KB.
@end table
The constant MPI_INFO_NULL can be used when no info needs to be specified.

@item ncidp
Pointer to location where returned netCDF ID is to be stored.
@end table

@heading Return Error Codes
ncmpi_open returns the value NC_NOERR if no errors occurred. Otherwise,
the returned status indicates an error. Possible causes of errors include:
@itemize
@item NC_ENOENT: The specified netCDF file does not exist.
@item NC_EBAD_FILE: Invalid file name, file name too long, or the directory does not exist.
@item NC_EINVAL_OMODE: invalid value used in open mode.
@item NC_EPERM: Attempting to create a netCDF file in a directory where you do not have permission to open files.
@item NC_ESMALL: size of MPI_Offset on the running system is too small for the file format (CDF-2 or CDF-5) in request
@item NC_ENOMEM: unable to allocate memory
@item NC_ENFILE: Too many files open
@item NC_EFILE: other unknown I/O error, including unable to clobber the file
@item NC_EMULTIDEFINE_OMODE: inconsistent file open modes among processes.
@item NC_EMULTIDEFINE_FNC_ARGS: one or more arguments are inconsistent among processes
@end itemize

@heading Example
Below is an example using ncmpi_open to open an existing netCDF file
named foo.nc for read-only.

@example
#include <pnetcdf.h>
   ...
int err, ncid;
MPI_Info info;
    ...
MPI_Info_create (&info);
MPI_Info_set (info, "romio_no_indep_rw", "true");
MPI_Info_set (info, "nc_header_read_chunk_size", "1024");
    ...
err = @ref{ncmpi_open}(MPI_COMM_WORLD, "foo.nc", NC_NOWRITE, info,  &ncid);
if (err != NC_NOERR) printf("Error: %s\n",ncmpi_strerror(err));
MPI_Info_free(&info);
@end example

@node ncmpi__open, ncmpi_redef, ncmpi_open, Files
@section Open a NetCDF File for Access with Performance Tuning: ncmpi__open

This API is not implemented in PnetCDF.

@node ncmpi_redef, ncmpi_enddef, ncmpi__open, Files
@section Put Open NetCDF File into Define Mode: ncmpi_redef
@findex ncmpi_redef
@cindex ncmpi_redef, example
@cindex adding dimensions using ncmpi_redef
@cindex adding variables using ncmpi_redef
@cindex adding attributes using ncmpi_redef

The function ncmpi_redef puts an opened netCDF file into define mode, so
dimensions, variables, and attributes can be added or renamed and
attributes can be deleted.

@heading Operational Mode
This API is a collective routine: all processes must provide the same value for ncid.

This API must be called while the file is in data mode, either collective or independent.

@heading Usage

@example
int ncmpi_redef(int ncid);
@end example

@table @code
@item ncid
netCDF ID, from a previous call to ncmpi_open or ncmpi_create.
@end table

@heading Return Error Codes
ncmpi_redef returns the value NC_NOERR if no errors occurred. Otherwise,
the returned status indicates an error. Possible causes of errors include:
@itemize
@item NC_EBADID: The specified netCDF ID does not refer to an opened netCDF file.
@item NC_EPERM: The specified netCDF file was opened for read-only.
@item NC_EINDEFINE: The specified netCDF file is already in define mode.
@comment @xref{Large File Support,,, netcdf, @value{n-man}}.
@end itemize

@heading Example
Here is an example using ncmpi_open to open an existing netCDF file
named foo.nc and calling ncmpi_redef to enter the define mode:

@example
#include <pnetcdf.h>
   ...
int err, ncid;
   ...
err = @ref{ncmpi_open}(MPI_COMM_WORLD, "foo.nc", NC_WRITE, MPI_INFO_NULL, &ncid);
if (err != NC_NOERR) printf("Error: %s\n",ncmpi_strerror(err));
   ...
err = @ref{ncmpi_redef}(ncid); /* enter define mode */
if (err != NC_NOERR) printf("Error: %s\n",ncmpi_strerror(err));
@end example

@node ncmpi_enddef, ncmpi__enddef, ncmpi_redef, Files
@section Leave Define Mode: ncmpi_enddef
@findex ncmpi_enddef
@cindex ncmpi_enddef, example

The function ncmpi_enddef takes an opened netCDF file out of define
mode. The changes made to the netCDF file while it was in define
mode are checked and committed to disk if no problems
occurred. Non-record variables may be initialized to a "fill value" as
well. @xref{ncmpi_set_fill}. The netCDF file is then placed in data
mode, so variable data can be read or written.

This call may involve moving (shifting) data under some circumstances. For
instance, when opening an existing file and entering redefine more to add more
metadata which causes file header to expands, all fixed-size and record
variables will be moved to higher file offsets to make room for the new file
header. Such operations can be very expensive. Users are encouraged to use
PnetCDF hint @ref{PNETCDF_HINTS,nc_header_align_size} to reserve a sufficient
large space for file header if it is expected to expand.

@heading Operational Mode
This API is a collective routine: all processes must provide the same value for ncid.

This API must be called while the file is in define mode.

@heading Usage

@example
int ncmpi_enddef(int ncid);
@end example

@table @code
@item ncid
NetCDF ID, from a previous call to ncmpi_open or ncmpi_create.
@end table

@heading Return Error Codes
ncmpi_enddef returns the value NC_NOERR if no errors occurred. Otherwise,
the returned status indicates an error. Possible causes of errors include:
@itemize
@item NC_EBADID: The specified netCDF ID does not refer to an opened netCDF file.
@item NC_ENOTINDEFINE: Operation not allowed in data mode.
@item NC_EVARSIZE: The size of one or more variables exceed the size constraints for whichever variant of the file format is in use.
@item NC_EMULTIDEFINE: File header is inconsistent among processes.
@comment @xref{Large File Support,,, netcdf, @value{n-man}}.
@end itemize

@heading Example

Here is an example using ncmpi_enddef to finish the definitions of a new
netCDF file named foo.nc and put it into data mode:

@example
#include <pnetcdf.h>
   ...
int err, ncid, cmode = NC_NOCLOBBER | NC_64BIT_DATA;
     ...
err = @ref{ncmpi_create}(MPI_COMM_WORLD, "foo.nc", cmode, MPI_INFO_NULL, &ncid);
if (err != NC_NOERR) printf("Error: %s\n",ncmpi_strerror(err));

     ...       /* create dimensions, variables, attributes */

err = @ref{ncmpi_enddef}(ncid);  /*leave define mode and enter data mode */
if (err != NC_NOERR) printf("Error: %s\n",ncmpi_strerror(err));
@end example

@node ncmpi__enddef, ncmpi_close, ncmpi_enddef, Files
@section Leave Define Mode with Performance Tuning: ncmpi__enddef
@findex ncmpi__enddef
@cindex ncmpi__enddef, example

The function ncmpi__enddef takes an opened netCDF file out of define
mode. The changes made to the netCDF file while it was in define
mode are checked and committed to disk if no problems
occurred. Non-record variables may be initialized to a "fill value" as
well. @xref{ncmpi_set_fill}. The netCDF file is then placed in data
mode, so variable data can be read or written.

This call may involve moving (shifting) data under some circumstances.
For instance, when opening an existing file and entering redefine more to add
more metadata which causes file header to expands, all fixed and record
variables will be moved to higher file offsets to make room for the new file
header. Such operations can be very expensive. Users are encouraged to set
h_minfree to reserve a sufficient large space for file header if it is expected
to expand.

The current netcdf file format has three sections, the "header"
section, the data section for fixed-size variables, and the data
section for variables which have an unlimited dimension (record
variables).

The header begins at the beginning of the file. The index (offset) of
the beginning of the other two sections is contained in the
header. Typically, there is no space between the sections. This causes
copying (moving) overhead to accrue if one wishes to change the size of the
sections, as may happen when changing names of things, text attribute
values, adding attributes or adding variables.

The minfree parameters allow one to control costs of future calls to
ncmpi_redef, ncmpi_enddef by requesting that minfree bytes be available at
the end of the section.

The align parameters allow one to set the alignment of the beginning
of the corresponding sections. The beginning of the section is rounded
up to an index which is a multiple of the align parameter.

The file format requires a 4-byte alignment, so the align parameters
are silently rounded up to multiples of 4.

The usual call of

@example
ncmpi_enddef(ncid);
@end example

is equivalent to

@example
ncmpi__enddef(ncid, 0, 0, 0, 0);
@end example

The file format does not contain a "record size" value, this is
calculated from the sizes of the record variables. This unfortunate
fact prevents us from providing minfree and alignment control of the
"records" in a netcdf file. If you add a variable which has an
unlimited dimension, the third section will always be copied with the
new variable added.

Note the alignment hints set in the environment variable "PNETCDF_HINTS" have
the highest precedence, which overwrite the alignment hints set in the MPI_Info
object used in the call of ncmpi_create() and ncmpi_open(), which overwrite the
alignment arguments, i.e. v_align and r_align, used in the call to
ncmpi__enddef().

@heading Operational Mode
This API is a collective routine: all processes must provide the same values
for all arguments.

This API must be called while the file is in define mode.

@heading Usage

@example
int ncmpi__enddef(int        ncid,
                  MPI_Offset h_minfree,
                  MPI_Offset v_align,
                  MPI_Offset v_minfree,
                  MPI_Offset r_align);
@end example

@table @code

@item ncid
NetCDF ID, from a previous call to ncmpi_open or ncmpi_create.

@item h_minfree
Sets the pad at the end of the "header" section.

@item v_align
Controls the alignment of the beginning of the data section for fixed-size
variables. 1 means no alignment. 0 means to let PnetCDF chose the best value.
This value is ignored if the PnetCDF hint @ref{PNETCDF_HINTS,
nc_header_align_size} is set.

@item v_minfree
Sets the pad at the end of the data section for fixed-size variables.

@item r_align
Controls the alignment of the beginning of the data section for variables which
have an unlimited dimension (record variables).  1 means no alignment. 0 means
to let PnetCDF chose the best value. This value can be set at the run time
using PnetCDF hint environment variable
@ref{PNETCDF_HINTS,nc_record_align_size}.

@end table

@heading Return Error Codes
ncmpi__enddef returns the value NC_NOERR if no errors occurred. Otherwise,
the returned status indicates an error. Possible causes of errors include:
@itemize
@item NC_EBADID: The specified netCDF ID does not refer to an opened netCDF file.
@item NC_ENOTINDEFINE: Operation not allowed in data mode.
@item NC_EVARSIZE: The size of one or more variables exceed the size constraints for whichever variant of the file format is in use.
@item NC_EMULTIDEFINE_FNC_ARGS: Inconsistent function arguments used in collective API.
@item NC_EMULTIDEFINE: File header is inconsistent among processes.
@comment @xref{Large File Support,,, netcdf, @value{n-man}}.
@end itemize

@heading Example

Here is an example using ncmpi__enddef to finish the definitions of a new
netCDF file named foo.nc and put it into data mode:

@example
#include <pnetcdf.h>
   ...
int err, ncid, cmode = NC_NOCLOBBER | NC_64BIT_DATA;
MPI_Offset header_size, header_extent;
MPI_Offset h_minfree, v_align, v_minfree, r_align;
   ...
err = @ref{ncmpi_create}(MPI_COMM_WORLD, "foo.nc", cmode, MPI_INFO_NULL, &ncid);
if (err != NC_NOERR) printf("Error: %s\n",ncmpi_strerror(err));

   ...       /* create dimensions, variables, attributes */

h_minfree = 4194304;  /* 4 MB */
v_align   = 1048576;  /* 1 MB */
v_minfree = 4194304;  /* 4 MB */
r_align   = 1048576;  /* 1 MB */
err = @ref{ncmpi__enddef}(ncid, h_minfree, v_align, v_minfree, r_align);  /*leave define mode*/
if (err != NC_NOERR) printf("Error: %s\n",ncmpi_strerror(err));

err = @ref{ncmpi_inq_header_size}(ncid, &header_size);
if (err != NC_NOERR) printf("Error: %s\n",ncmpi_strerror(err));

err = @ref{ncmpi_inq_header_extent}(ncid, &header_extent);
if (err != NC_NOERR) printf("Error: %s\n",ncmpi_strerror(err));

/* check if minimum free space for file header is honored */
assert(header_extent - header_size >= h_minfree);

@end example

@node ncmpi_close, ncmpi_inq Family, ncmpi__enddef, Files
@section Close an Open NetCDF File: ncmpi_close
@findex ncmpi_close
@cindex ncmpi_close, example

The function ncmpi_close closes an opened netCDF file. If the dataset is
in define mode, ncmpi_enddef will be called before closing. (In this
case, if ncmpi_enddef returns an error, ncmpi_abort will automatically be
called to restore the file to the consistent state before define
mode was last entered.) After an opened netCDF file is closed, its
netCDF ID may be reassigned to the next netCDF file that is opened
or created.

@heading Operational Mode
This API is a collective subroutine (must be called by all MPI processes that open the file.)

This API can be called while the file is in either define or data mode (collective or independent).

@heading Usage
@example
int ncmpi_close(int ncid);
@end example

@table @code
@item ncid
NetCDF ID, from a previous call to ncmpi_open or ncmpi_create.
@end table

@heading Return Error Codes
ncmpi_close returns the value NC_NOERR if no errors occurred. Otherwise,
the returned status indicates an error. Possible causes of errors include:
@itemize
@item When the program is in define mode, ncmpi_enddef will be called automatically.  In this case, error codes from ncmpi_enddef will be returned if ncmpi_enddef failed.  (@pxref{ncmpi_enddef}).
@item NC_EBADID: The specified netCDF ID does not refer to an opened netCDF file.
@end itemize

@heading Example

Here is an example using ncmpi_close to finish the definitions of a new
netCDF file named foo.nc and release its netCDF ID:

@example
#include <pnetcdf.h>
   ...
int err, ncid, cmode = NC_NOCLOBBER | NC_64BIT_DATA;
   ...
err = @ref{ncmpi_create}(MPI_COMM_WORLD, "foo.nc", cmode, MPI_INFO_NULL, &ncid);
if (err != NC_NOERR) printf("Error: %s\n",ncmpi_strerror(err));

   ...       /* create dimensions, variables, attributes, write/read variables */

err = @ref{ncmpi_close}(ncid);       /* close netCDF file */
if (err != NC_NOERR) printf("Error: %s\n",ncmpi_strerror(err));
@end example

@node ncmpi_inq Family, ncmpi_sync, ncmpi_close, Files
@section Inquire about an Open NetCDF File: ncmpi_inq Family
@findex ncmpi_inq Family
@findex ncmpi_inq_ndims
@findex ncmpi_inq_nvars
@findex ncmpi_inq_natts
@findex ncmpi_inq_unlimdim
@findex ncmpi_inq_format
@findex ncmpi_inq_version
@findex ncmpi_inq_file_format
@findex ncmpi_inq_striping
@findex ncmpi_inq_num_rec_vars
@findex ncmpi_inq_num_fix_vars
@findex ncmpi_inq_recsize
@findex ncmpi_inq_path
@cindex attributes, number of
@cindex variables, number of
@cindex dimensions, number of
@cindex format version
@cindex version, format
@cindex record size
@cindex number of record variables
@cindex number of fixed-size variables
@cindex ncmpi_inq Family, example

Members of the ncmpi_inq family of functions return information about an opened
netCDF file, given its netCDF ID. These inquiry functions may be called from
either define mode or data mode. The first function, ncmpi_inq, returns values
for the number of dimensions, the number of variables, the number of global
attributes, and the dimension ID of the dimension defined with unlimited
length, if any. Other functions in the family each return just single items of
information.

No file I/O is actually performed when these functions are called, because the
information in request is stored in the file header which is already cached in
memory.

@heading Operational Mode
These APIs are independent subroutines.

They can be called in either define or data mode (collective or independent).

@heading Usage
@example
int ncmpi_inq             (int ncid, int *ndimsp, int *nvarsp, int *ngattsp, int *unlimdimidp);
int ncmpi_inq_ndims       (int ncid, int *ndimsp);
int ncmpi_inq_nvars       (int ncid, int *nvarsp);
int ncmpi_inq_natts       (int ncid, int *ngattsp);
int ncmpi_inq_unlimdim    (int ncid, int *unlimdimidp);
int ncmpi_inq_format      (int ncid, int *formatp);

int ncmpi_inq_version     (int ncid, int *nc_mode);
int ncmpi_inq_file_format (const char *filename, int *formatp);
int ncmpi_inq_path        (int ncid, int *pathlen, char *path);                 (1.8.0 and later)
int ncmpi_inq_striping    (int ncid, int *striping_size, int *striping_count);  (1.5.0 and later)
int ncmpi_inq_num_rec_vars(int ncid, int *num_rec_varsp);                       (1.6.0 and later)
int ncmpi_inq_num_fix_vars(int ncid, int *num_fix_varsp);                       (1.6.0 and later)
int ncmpi_inq_recsize     (int ncid, MPI_Offset *recsize);                      (1.6.0 and later)
@end example

@table @code
@item ncid
NetCDF ID, from a previous call to ncmpi_open or ncmpi_create.

@item ndimsp
Pointer to location for returned number of dimensions defined for this
netCDF file.

@item nvarsp
Pointer to location for returned number of variables defined for this
netCDF file.

@item ngattsp
Pointer to location for returned number of global attributes defined
for this netCDF file.

@item unlimdimidp
Pointer to location for returned ID of the unlimited dimension, if
there is one for this netCDF file. If no unlimited length dimension
has been defined, -1 is returned.

@item formatp
Pointer to location for returned format version, one of the following constants define in the header file pnetcdf.h.
@itemize
@item NC_FORMAT_CLASSIC (CDF-1 format),
@item NC_FORMAT_CDF2 (CDF-2 format),
@item NC_FORMAT_64BIT_OFFSET (alias of NC_FORMAT_CDF2, also CDF-2 format),
@item NC_FORMAT_64BIT(alias of NC_FORMAT_CDF2, also CDF-2 format),
@item NC_FORMAT_CDF5 (CDF-5 format),
@item NC_FORMAT_64BIT_DATA (alias of NC_FORMAT_CDF5, also CDF-5 format).
@item NC_FORMAT_NETCDF4 (HDF-based NetCDF-4 format).
@item NC_FORMAT_BP (BP format).
@end itemize
Note the names of the returned constants are different from the ones returned by
ncmpi_inq_version().

@item nc_mode
Pointer to location for returned format version, one of
NC_CLASSIC_MODEL, NC_64BIT_OFFSET, NC_64BIT_DATA,
NC_NETCDF4, (NC_NETCDF4 | NC_CLASSIC_MODEL), and NC_BP.
Note the names of the returned constants are different from the ones returned by
ncmpi_inq_format().

@item filename
A char string specifies the name of file in inquiry.

@item path
Pointer where path name will be copied. Space must already be allocated.
Ignored if NULL. ncmpi_inq_path can be used to obtain the file path name, given
a ncid.

@item pathlen
Pointer where length of path will be returned. Ignored if NULL.

@item striping_size
File system striping size. This argument can be NULL.

@item striping_count
(version 1.5.0 and later) File system striping count. This argument can be NULL.

@item num_rec_varsp
(version 1.6.0, and later) Pointer to location for returned number of record variables defined for this netCDF file.

@item num_fix_varsp
(version 1.6.0, and later) Pointer to location for returned number of fixed-size variables defined for this netCDF file.

@item recsize
(version 1.6.0, and later) Pointer to location for returned size of record block, sum of individual record sizes (one record each) of all record variables, for this netCDF file.

@end table

@heading Return Error Codes
All members of the ncmpi_inq family return the value NC_NOERR if no
errors occurred. Otherwise, the returned status indicates an
error. Possible causes of errors include:
@itemize
@item NC_EBADID: The specified netCDF ID does not refer to an opened netCDF file.
@item NC_ENOTNC3: The file is not a classic netCDF file, but an HDF file.
@item NC_ENOTNC: The file is not a classic netCDF file.
@item NC_ENOENT: The specified netCDF file does not exist.
@item NC_EACCESS: Permission denied.
@item NC_EBAD_FILE: Invalid file name.
@item NC_EFILE: other unknown I/O error.
@end itemize

@heading Example

Here is an example using ncmpi_inq to find out about a netCDF file
named foo.nc:

@example
#include <pnetcdf.h>
   ...
int err, ncid, ndims, nvars, ngatts, unlimdimid;
   ...
err = @ref{ncmpi_open}(MPI_COMM_WORLD, "foo.nc", NC_NOWRITE, MPI_INFO_NULL,  &ncid);
if (err != NC_NOERR) printf("Error: %s\n",ncmpi_strerror(err));
   ...
err = @ref{ncmpi_inq Family, ncmpi_inq}(ncid, &ndims, &nvars, &ngatts, &unlimdimid);
if (err != NC_NOERR) printf("Error: %s\n",ncmpi_strerror(err));
@end example

@node ncmpi_sync, ncmpi_abort, ncmpi_inq Family, Files
@section Synchronize an Opened NetCDF File to Disk: ncmpi_sync
@findex ncmpi_sync
@cindex ncmpi_sync, example

The function ncmpi_sync offers a way to flush system cache (both on client and
server sides) to the storage devices in file systems.
Use this API to minimize data loss in case of system crash.

Note this API is expensive in term of timing, as it will not return until
the data cached in client- and server-side file systems are safely stored in
the storage devices of the file systems.

This API does not flush the pending nonblocking requests. Flushing pending
nonblocking requests, users should use
@ref{ncmpi_wait/wait_all, ncmpi_wait_all} or
@ref{ncmpi_wait/wait_all, ncmpi_wait}.

@ignore
@itemize
@item
To minimize data loss in case of abnormal termination, or

@item
To make data available to other programs for reading immediately
after it is written. But note that a process that already had the
file open for reading would not see the number of records increase
when the writing process calls ncmpi_sync; to accomplish this, the
reading process must call ncmpi_sync.
@end itemize

This function allows sharing of a netCDF file
among multiple readers and one writer, by having the writer call
ncmpi_sync after writing and the readers call ncmpi_sync before each
read. For a writer, this flushes buffers to disk. For a reader, it
makes sure that the next read will be from disk rather than from
previously cached buffers, so that the reader will see changes made by
the writing process (e.g., the number of records written) without
having to close and reopen the file. If you are only accessing a
small amount of data, it can be expensive in computer resources to
always synchronize to disk after every write, since you are giving up
the benefits of buffering.

Sharing files when the writer enters define mode to change the data
schema requires extra care. In previous releases, after the writer
left define mode, the readers were left looking at an old copy of the
file, since the changes were made to a new copy. The only way
readers could see the changes was by closing and reopening the
file. Now the changes are made in place, but readers have no
knowledge that their internal tables are now inconsistent with the new
file schema. If netCDF datasets are shared across redefinition,
some mechanism external to the PnetCDF library must be provided that
prevents access by readers during redefinition and causes the readers
to call ncmpi_sync before any subsequent access.

When calling ncmpi_sync, the netCDF file must be in data mode. A
netCDF file in define mode is synchronized to disk only when
ncmpi_enddef is called. A process that is reading a netCDF file that
another process is writing may call ncmpi_sync to get updated with the
changes made to the data by the writing process (e.g., the number of
records written), without having to close and reopen the file.

Data is automatically synchronized to disk when a netCDF file is
closed, or whenever you leave define mode.
@end ignore

@heading Operational Mode
This API is a collective subroutine.

This API must be called while the file is in data mode (collective or independent).

@heading Usage
@example
int ncmpi_sync(int ncid);
@end example

@table @code
@item ncid
NetCDF ID, from a previous call to ncmpi_open or ncmpi_create.
@end table

@heading Return Error Codes
ncmpi_sync returns the value NC_NOERR if no errors occurred. Otherwise,
the returned status indicates an error. Possible causes of errors include:
@itemize
@item NC_EBADID: The specified netCDF ID does not refer to an opened netCDF file.
@item NC_EINDEFINE: Operation not allowed in define mode.
@end itemize

@heading Example

Here is an example using ncmpi_sync to synchronize the disk writes of a
netCDF file named foo.nc:

@example
#include <pnetcdf.h>
   ...
int status;
int ncid;
   ...
status = @ref{ncmpi_open}(MPI_COMM_WORLD, "foo.nc", NC_WRITE, MPI_INFO_NULL, &ncid); /* open for writing */
if (status != NC_NOERR) handle_error(status);

   ...           /* write data or change attributes */

status = @ref{ncmpi_redef}(ncid);      /* enter define mode */
if (status != NC_NOERR) handle_error(status);

   ...           /* define or change dimensions, variables, and attributes */

status = @ref{ncmpi_enddef}(ncid);      /* exit define mode */
if (status != NC_NOERR) handle_error(status);

   ...           /* write data or change attributes */

status = @ref{ncmpi_sync}(ncid);      /* synchronize to disk */
if (status != NC_NOERR) handle_error(status);
@end example

@node ncmpi_abort, ncmpi_set_fill, ncmpi_sync, Files
@section Back Out of Recent Definitions: ncmpi_abort
@findex ncmpi_abort
@cindex ncmpi_abort, example
@cindex backing out of definitions
@cindex canceling definitions

You no longer need to call this function, since it is called
automatically by ncmpi_close in case the file is in define mode and
something goes wrong with committing the changes. The function
ncmpi_abort just closes the netCDF file, if not in define mode. If the
file is being created and is still in define mode, the dataset is
deleted. If define mode was entered by a call to ncmpi_redef, the netCDF
file is restored to its state before definition mode was entered
and the file is closed.

@heading Operational Mode
This API is a collective subroutine.

This API can be called in either define or data mode (collective or independent).

@heading Usage
@example
int ncmpi_abort(int ncid);
@end example

@table @code
@item ncid
NetCDF ID, from a previous call to ncmpi_open or ncmpi_create.
@end table

@heading Return Error Codes
ncmpi_abort returns the value NC_NOERR if no errors occurred. Otherwise,
the returned status indicates an error. Possible causes of errors include:
@itemize
@item NC_EBADID: The specified netCDF ID does not refer to an opened netCDF file.
@item NC_EFILE: When called from define mode while creating a netCDF file, deletion of the file failed.
@end itemize

@heading Example

Here is an example using ncmpi_abort to back out of redefinitions of a
file named foo.nc:

@example
#include <pnetcdf.h>
   ...
int ncid, status, latid;
   ...
status = @ref{ncmpi_open}(MPI_COMM_WORLD, "foo.nc", NC_NOWRITE, MPI_INFO_NULL,  &ncid); /* open for read only */
if (status != NC_NOERR) handle_error(status);
   ...
status = @ref{ncmpi_redef}(ncid);                    /* enter define mode */
if (status != NC_NOERR) handle_error(status);
   ...
status = @ref{ncmpi_def_dim}(ncid, "lat", 18L, &latid);
if (status != NC_NOERR) @{
   handle_error(status);
   status = @ref{ncmpi_abort}(ncid);                 /* define failed, abort */
   if (status != NC_NOERR) handle_error(status);
@}
@end example

@node ncmpi_set_fill, ncmpi_set_default_format, ncmpi_abort, Files
@section Set Fill Mode for Writes: ncmpi_set_fill
@findex ncmpi_set_fill
@cindex ncmpi_set_fill, example
@cindex write fill mode, setting

This function is intended for advanced usage, to optimize writes under
some circumstances described below. The function ncmpi_set_fill sets the
fill mode for a netCDF file open for writing and returns the
current fill mode in a return parameter. The fill mode can be
specified as either NC_FILL or NC_NOFILL.
@strong{The default mode of PnetCDF is NC_NOFILL.}
Note that this is opposite to netCDF whose default mode is NC_FILL.
The behavior
corresponding to NC_FILL is that data is pre-filled with fill values,
that is fill values are written when you create non-record variables
at the time ncmpi_enddef is called.
This makes it possible to detect attempts to read data before
it was written. For more information on the use of fill values
see @ref{Fill Values}.
@c For information about how to define your own fill values see @ref{Attribute Conventions,,, PnetCDF, PnetCDF Users' Guide}.

NC_NOFILL can be used to enhance
performance, because it avoids the duplicate writes that occur when
the PnetCDF library writes fill values that are later overwritten with
data.

A value indicating which mode the netCDF file was already in is
returned. You can use this value to temporarily change the fill mode
of an opened netCDF file and then restore it to the previous mode.

When in the default NC_NOFILL mode for an opened netCDF file, you must
be certain to write valid data in all the positions that will later be
read. Note that fill mode is only a transient property of a netCDF
file open for writing: if you close and reopen the dataset, it will
revert to the default behavior. You can also revert to the default
behavior by calling ncmpi_set_fill again to explicitly set the fill mode
to NC_NOFILL.

@strong{ncmpi_set_fill() will change the fill mode for all variables defined
so far at the time this API is called.}
In other words, it overwrites the fill mode for all variables previously
defined.
This will also change the default fill mode for new variables defined
following this call.
To set the fill mode for individual variables, readers are referred to
@ref{ncmpi_def_var_fill}.

@strong{In PnetCDF, this API only affects non-record variables.}
In addition, @strong{it can only be called while in the define mode.}
All non-record variables will be filled with fill values (either default
or user-defined) at the time ncmpi_enddef() is called.

For record variables, users must call @ref{ncmpi_fill_var_rec}() to fill one
record of a variable at a time. If fill mode is desired, users should call
@ref{ncmpi_fill_var_rec}() first followed by the regular put APIs.

If the netCDF file has an unlimited dimension and the last record
was written while in nofill mode, then the file may be shorter than
if nofill mode was not set, but this will be completely transparent if
you access the data only through the PnetCDF or netCDF interfaces.

As stated in netCDF document, the use of this feature may not be available
(or even needed) in
future releases. Programmers are cautioned against heavy reliance upon
this feature.

@heading Operational Mode
This API is a collective subroutine and must be called in define mode, contrary to netCDF
where nc_set_fill() can also be called in data mode. The reason of PnetCDF
enforcing this requirement is because PnetCDF only fills fixed-size
variables at ncmpi_enddef(). Record variables are only filled in
@ref{ncmpi_fill_var_rec}().


@heading Usage
@example
int ncmpi_set_fill(int  ncid,
                   int  fillmode,
                   int *old_modep);
@end example

@table @code
@item ncid
NetCDF ID, from a previous call to ncmpi_open or ncmpi_create.

@item fillmode
Desired fill mode for the file, either NC_NOFILL or NC_FILL.

@item old_modep
Pointer to location for returned current fill mode of the file
before this call, either NC_NOFILL or NC_FILL.
@end table

@heading Return Error Codes
ncmpi_set_fill returns the value NC_NOERR if no errors
occurred. Otherwise, the returned status indicates an error. Possible
causes of errors include:
@itemize
@item NC_EBADID: The specified netCDF ID does not refer to an opened netCDF file.
@item NC_EPERM: The specified netCDF ID refers to a file open for read-only access.
@item NC_ENOTINDEFINE: Operation not allowed in data mode.
@item NC_EINVAL: The fill mode argument is neither NC_NOFILL nor NC_FILL.
@item NC_EMULTIDEFINE_FILL_MODE: values in fill_mode are inconsistent among all processes.
@end itemize

@heading Example

Here is an example using ncmpi_set_fill to set nofill mode for subsequent
writes of a netCDF file named foo.nc:

@example
#include <pnetcdf.h>
   ...
int ncid, status, old_fill_mode;
   ...
status = @ref{ncmpi_create}(MPI_COMM_WORLD, "foo.nc", NC_WRITE, info, &ncid);
if (status != NC_NOERR) handle_error(status);

   ...       /* create dimensions, variables, attributes */
   ...       /* finish definitions of all variables */

status = @ref{ncmpi_set_fill}(ncid, NC_FILL, &old_fill_mode); /* set to fill */
if (status != NC_NOERR) handle_error(status);

status = @ref{ncmpi_enddef}(ncid);
if (status != NC_NOERR) handle_error(status);

   ...           /* write data */
@end example

@heading Full example C program
@itemize
@item
@url{https://github.com/Parallel-NetCDF/PnetCDF/tree/master/examples/C/fill_mode.c, fill_mode.c}
@item
The above programs are available in all PnetCDF releases under directory examples/C.
@end itemize

@node ncmpi_set_default_format, ncmpi_begin_indep_data, ncmpi_set_fill, Files
@section Set/Inquire Default Creation Format: ncmpi_set_default_format and ncmpi_inq_default_format
@findex ncmpi_set_default_format
@findex ncmpi_inq_default_format
@cindex ncmpi_set_default_format, example
@cindex ncmpi_inq_default_format, example
@cindex create flag, setting default
@cindex inquiring default

This function is intended for advanced users. (1.6.1 and later)

Starting from netCDF 3.6, a new file format named 64-bit offset format, or
CDF-2, was introduced to relax the limitations on creating very large
files. The older format is referred as CDF-1 format.

Users are warned that creating files in the 64-bit offset format makes
them unreadable by the netCDF library prior to version 3.6.0. For
reasons of compatibility, users should continue to create files in
CDF-1 format.

In addition to 64-bit offset format, PnetCDF also supports the 64-bit data
format, which allows variables to be defined with more than 4 billion array
elements. This format is named CDF-5. Similarly, the files in 64-bite data
format cannot be read by the netCDF library version 3.6.0 and all prior to
version 3.6.0.

Users who do want to use 64-bit offset or 64-bit data format files can create
them directly from ncmpi_create, using the proper cmode flag.
(@pxref{ncmpi_create}).

The function ncmpi_set_default_format allows the user to change the
format of the netCDF file to be created by future calls to ncmpi_create
without changing the cmode flag.

This allows the user to convert a program to use 64-bit offset or data
formation without changing all calls the ncmpi_create. @xref{Large File
Support,,, netcdf, @value{n-man}}.

Once the default format is set, all future created files will be in
the desired format.

Constants are provided in the pnetcdf.h file to be used with this
function,
NC_FORMAT_CLASSIC (CDF-1 format),
NC_FORMAT_CDF2 (or NC_FORMAT_64BIT), and
NC_FORMAT_CDF5 (or NC_FORMAT_64BIT_DATA).

If a non-NULL pointer is provided, it is assumed to point to an integer,
where the existing default format will be written.

Using ncmpi_create with a cmode including NC_64BIT_OFFSET or NC_64BIT_DATA
overrides the default format, and creates a 64-bit offset (CDF-2) or 64-bit
data (CDF-5) file.

@heading Operational Mode
ncmpi_set_default_format is an independent subroutine, but is expected to
be called by all processes that intend to create a file later.

ncmpi_inq_default_format is an independent subroutine.

@heading Usage
@example
int ncmpi_set_default_format(int  new_format,
                             int *old_formatp);

int ncmpi_inq_default_format(int *formatp);
@end example

@table @code

@item new_format
NC_FORMAT_CLASSIC (the default setting), NC_FORMAT_CDF2 (NC_FORMAT_64BIT),
or NC_FORMAT_CDF5 (NC_FORMAT_64BIT_DATA).

@item old_formatp
Either NULL (in which case it will be ignored), or a pointer to an int
where the existing default format (i.e. before being changed to the
new format) will be written. This allows you to get the existing
default format while setting a new default format.

@item formatp
The current setting for default file format.

@end table

@heading Return Error Codes
ncmpi_set_default_format returns the value NC_NOERR if no errors
occurred. Otherwise, the returned status indicates an error. Possible
causes of errors include:
@itemize
@item NC_EINVAL: For ncmpi_set_default_format(), this indicates an invalid
new default format is used. The only valid formats are
NC_FORMAT_CLASSIC (CDF-1 format), NC_FORMAT_CDF2 (NC_FORMAT_64BIT),
and NC_FORMAT_CDF5 (NC_FORMAT_64BIT_DATA).
Trying to set the default format to something else
will result in an invalid argument error.
For ncmpi_inq_default_format, this error indicates NULL pointer is used.
@item NC_EMULTIDEFINE_OMODE: the values of new_format are inconsistent among processes.
@end itemize

@heading Example

Here is an example using ncmpi_set_default_format to create files
in CDF-1, CDF-2, and CDF-5 formats with the same ncmpi_create call:

@example
#include <pnetcdf.h>
   ...
int i, ncid;
int format[3] = @{NC_FORMAT_CLASSIC, NC_FORMAT_CDF2, NC_FORMAT_CDF5@};
   ...
for (i=0; i<3; i++) @{
    status = @ref{ncmpi_set_default_format}(format[i], NULL);
    if (status != NC_NOERR) handle_error(status);

    status = @ref{ncmpi_create}(MPI_COMM_WORLD, "foo.nc", NC_CLOBBER, MPI_INFO_NULL,  &ncid);
    if (status != NC_NOERR) handle_error(status);
   ...
@}
@end example

@node ncmpi_begin_indep_data, ncmpi_end_indep_data, ncmpi_set_default_format, Files
@section Enter independent data mode: ncmpi_begin_indep_data
@findex ncmpi_begin_indep_data
@cindex ncmpi_begin_indep_data, example

This API leaves the netCDF data set from collective data mode and enters
into independent data mode.

@heading Operational Mode
This API is a collective subroutine.

This API must be called while the file is in collective data mode.
Starting from version 1.2.0, if called in the independent mode, this API takes no effect and returns NC_NOERR immediately.

@heading Usage
@example
int ncmpi_begin_indep_data (int ncid);
@end example

@table @code

@item ncid
NetCDF ID, from a previous call to ncmpi_open or ncmpi_create.

@end table

@heading Return Error Codes
ncmpi_begin_indep_data returns the value NC_NOERR if no errors occurred. Otherwise, the returned status indicates an error. Possible causes of errors include:
@itemize
@item NC_EBADID: The specified netCDF ID does not refer to an opened netCDF file.
@item NC_EINDEFINE: Operation not allowed in define mode.
@end itemize

@heading Example

Here is an example using ncmpi_put_vara_double_all in collective data mode and ncmpi_put_vara_double in independent data mode.

@example
#include <pnetcdf.h>
   ...
int  err;                       /* error status */
int  ncid;                      /* netCDF ID */
int  varid;                     /* variable ID */
MPI_Offset start[3], count[3];
double *buf;                    /* array to hold values */
    ...
err = @ref{ncmpi_create}(MPI_COMM_WORLD, "foo.nc", NC_CLOBBER, MPI_INFO_NULL, &ncid);
if (err != NC_NOERR) handle_error(err);
   ...
err = @ref{ncmpi_enddef}(ncid);
if (err != NC_NOERR) handle_error(err);
   ...
/* collectively write values into netCDF variable */
err = @ref{ncmpi_put_vara_@var{<type>}, ncmpi_put_vara_double_all}(ncid, varid, start, count, buf);
if (err != NC_NOERR) handle_error(err);
   ...
/* entering independent data mode */
err = @ref{ncmpi_begin_indep_data}(ncid);
if (err != NC_NOERR) handle_error(err);
   ...
/* independently write values into netCDF variable */
err = @ref{ncmpi_put_vara_@var{<type>}, ncmpi_put_vara_double}(ncid, varid, start, count, buf);
if (err != NC_NOERR) handle_error(err);
   ...
/* exiting independent data mode */
err = @ref{ncmpi_end_indep_data}(ncid);
if (err != NC_NOERR) handle_error(err);
@end example

@node ncmpi_end_indep_data, ncmpi_inq_put_size, ncmpi_begin_indep_data, Files
@section Exit independent data mode: ncmpi_end_indep_data
@findex ncmpi_end_indep_data
@cindex ncmpi_end_indep_data, example

This API leaves the netCDF data set from independent data mode and enters
into collective data mode.

@heading Operational Mode
This API is a collective subroutine.

This API must be called while the file is in independent data mode.
Starting from version 1.9.0, if called in the collective mode, this API takes
no effect and returns NC_NOERR immediately.

@heading Usage
@example
int ncmpi_end_indep_data (int ncid);
@end example

@table @code

@item ncid
NetCDF ID, from a previous call to ncmpi_open or ncmpi_create.

@end table

@heading Return Error Codes
ncmpi_end_indep_data returns the value NC_NOERR if no errors occurred. Otherwise, the returned status indicates an error. Possible causes of errors include:
@itemize
@item NC_EBADID: The specified netCDF ID does not refer to an opened netCDF file.
@item NC_EINDEFINE: Operation not allowed in define mode.
@item NC_ENOTINDEP: Attempt independent I/O operations in collective data mode.
@end itemize

@heading Example

Here is an example using ncmpi_put_vara_double_all in collective data mode and ncmpi_put_vara_double in independent data mode.

@example
#include <pnetcdf.h>
   ...
int  err;                       /* error status */
int  ncid;                      /* netCDF ID */
int  varid;                     /* variable ID */
MPI_Offset start[3], count[3];
double *buf;                    /* array to hold values */
    ...
err = @ref{ncmpi_create}(MPI_COMM_WORLD, "foo.nc", NC_CLOBBER, MPI_INFO_NULL, &ncid);
if (err != NC_NOERR) handle_error(err);
   ...
err = @ref{ncmpi_enddef}(ncid);
if (err != NC_NOERR) handle_error(err);
   ...
/* collectively write values into netCDF variable */
err = @ref{ncmpi_put_vara_@var{<type>}, ncmpi_put_vara_double_all}(ncid, varid, start, count, buf);
if (err != NC_NOERR) handle_error(err);
   ...
/* entering independent data mode */
err = @ref{ncmpi_begin_indep_data}(ncid);
if (err != NC_NOERR) handle_error(err);
   ...
/* independently write values into netCDF variable */
err = @ref{ncmpi_put_vara_@var{<type>}, ncmpi_put_vara_double}(ncid, varid, start, count, buf);
if (err != NC_NOERR) handle_error(err);
   ...
/* exiting independent data mode */
err = @ref{ncmpi_end_indep_data}(ncid);
if (err != NC_NOERR) handle_error(err);
@end example

@node ncmpi_inq_put_size, ncmpi_inq_get_size, ncmpi_end_indep_data, Files
@section Inquire the amount of data put to file so far: ncmpi_inq_put_size
@findex ncmpi_inq_put_size
@cindex ncmpi_inq_put_size, example

This API reports the amount of data that has actually been written to the file since the file is opened/created. The amount includes the data written/updated to the file header as well as the variables to the file body.

Note in some conditions, metadata (header data) will be cached in the memory and flushed to the file at the file close time. Hence the true write amount after file is closed may be slightly more than the one reported by this API when it is called immediately before file close.

One can use this API to check the amount of data written by a sequence of write
calls. See the example below.

@heading Operational Mode
This API is an independent subroutine and can be called while the file is in either define or data mode.

@heading Usage
@example
int ncmpi_inq_put_size(int         ncid,
                       MPI_Offset *size);
@end example

@table @code
@item ncid
NetCDF ID, from a previous call to ncmpi_open or ncmpi_create.
@item size
The amount of data (in bytes) written to the file by far.
@end table

@heading Return Error Codes
ncmpi_inq_put_size returns the value NC_NOERR if no errors occurred. Otherwise, the returned status indicates an error. Possible causes of errors include:
@itemize
@item NC_EBADID: The specified netCDF ID does not refer to an opened netCDF file.
@item NC_ENOTSUPPORT: Inquiring read and write sizes for NetCDF-4 files is not yet supported.
@end itemize

@heading Example
Here is an example using ncmpi_inq_put_size after a few calls to the put APIs.

@example
#include <pnetcdf.h>
   ...
int i, ncid, err;
MPI_Offset put_size_1, put_size_2;
   ...
err = @ref{ncmpi_create}(MPI_COMM_WORLD, "foo.nc", NC_CLOBBER, MPI_INFO_NULL,  &ncid);
if (err != NC_NOERR) handle_error(err);
   ...
err = @ref{ncmpi_enddef}(ncid);                    /* exit define mode */
if (err != NC_NOERR) handle_error(err);
   ...
err = @ref{ncmpi_put_vara_@var{<type>}, ncmpi_put_vara_int_all}(ncid, varid, ...);
err = @ref{ncmpi_inq_put_size}(ncid, &put_size_1);
/* put_size_1 is the amount of data written by this process so far */

err = @ref{ncmpi_put_vars_@var{<type>}, ncmpi_put_vars_float_all}(ncid, varid, ...);
err = @ref{ncmpi_put_var_@var{<type>}, ncmpi_put_var_short_all}(ncid, varid, ...);
err = @ref{ncmpi_inq_put_size}(ncid, &put_size_2);
/* (put_size_2 - put_size_1) is the sum of write amounts by the two put APIs (float and short) */

@end example

@node ncmpi_inq_get_size, ncmpi_inq_header_size, ncmpi_inq_put_size, Files
@section Inquire the amount of data got from file so far: ncmpi_inq_get_size
@findex ncmpi_inq_get_size
@cindex ncmpi_inq_get_size, example

This API reports the amount of data that has been actually read from the file since the file is opened/created. The amount includes the data read from the file header as well as the variables from the file body.

One can use this API to check the amount of data read by a sequence of read
calls. See the example below.

@heading Operational Mode
This API is an independent subroutine and can be called while the file is in either define or data mode.

@heading Usage
@example
int ncmpi_inq_get_size(int         ncid,
                       MPI_Offset *size);
@end example

@table @code
@item ncid
NetCDF ID, from a previous call to ncmpi_open or ncmpi_create.
@item size
The amount of data (in bytes) read from the file by far.
@end table

@heading Return Error Codes
ncmpi_inq_get_size returns the value NC_NOERR if no errors occurred. Otherwise,
the returned status indicates an error. Possible causes of errors include:
@itemize
@item NC_EBADID: The specified netCDF ID does not refer to an opened netCDF file.
@item NC_ENOTSUPPORT: Inquiring read and write sizes for NetCDF-4 files is not yet supported.
@end itemize

@heading Example
Here is an example using ncmpi_inq_get_size after a few calls to the get APIs.


@example
#include <pnetcdf.h>
   ...
int i, ncid, err;
MPI_Offset get_size_1, get_size_2;
   ...
err = @ref{ncmpi_open}(MPI_COMM_WORLD, "foo.nc", NC_NOWRITE, MPI_INFO_NULL, &ncid);
if (err != NC_NOERR) handle_error(err);
   ...
err = @ref{ncmpi_get_vara_@var{<type>}, ncmpi_get_vara_int_all}(ncid, varid, ...);
err = @ref{ncmpi_inq_get_size}(ncid, &get_size_1);
/* get_size_1 is the amount of data read by this process so far */

err = @ref{ncmpi_get_vars_@var{<type>}, ncmpi_get_vars_float_all}(ncid, varid, ...);
err = @ref{ncmpi_get_var_@var{<type>}, ncmpi_get_var_short_all}(ncid, varid, ...);
err = @ref{ncmpi_inq_get_size}(ncid, &get_size_2);
/* (get_size_2 - get_size_1) is the sum of read amounts by the two get APIs (float and short) */

@end example

@node ncmpi_inq_header_size, ncmpi_inq_header_extent, ncmpi_inq_get_size, Files
@section Inquire the size of the file header: ncmpi_inq_header_size
@findex ncmpi_inq_header_size
@cindex ncmpi_inq_header_size, example

This API reports the current file header size (in bytes) of an opened netCDF file.
Note this is the amount of space used by the metadata.

Note there might be a gap between the end of file header (true space used by the header) and the first variable stored in the file.
The gap allows expansion of the header in case new metadata is added to the header.
For example, a program re-enters the define mode and add more metadata.
If the size of gap is sufficiently large enough, the new metadata can be accommodated in the gap without moving the existing variables stored in the data section.

Check @pxref{ncmpi_inq_header_extent} for obtaining the file header extent, which indicates the maximum size the file header can expand without touching the existing variables.

@heading Operational Mode
This API is an independent subroutine and can be called while the file is in either define or data mode.

@heading Usage
@example
int ncmpi_inq_header_size(int         ncid,
                          MPI_Offset *size);
@end example

@table @code
@item ncid
NetCDF ID, from a previous call to ncmpi_open or ncmpi_create.
@item size
The size of file header (in bytes).
@end table

@heading Return Error Codes
ncmpi_inq_header_size returns the value NC_NOERR if no errors occurred. Otherwise, the returned status indicates an error. Possible causes of errors include:
@itemize
@item NC_EBADID: The specified netCDF ID does not refer to an opened netCDF file.
@item NC_ENOTSUPPORT: Inquiring header size and extent of NetCDF-4 files is not yet supported.
@end itemize

@heading Example
Here is an example using ncmpi_inq_header_size after a call to ncmpi_enddef.

@example
#include <pnetcdf.h>
   ...
int ncid, err;
MPI_Offset header_size;
   ...
err = @ref{ncmpi_create}(MPI_COMM_WORLD, "foo.nc", NC_CLOBBER, MPI_INFO_NULL,  &ncid);
if (err != NC_NOERR) handle_error(err);
   ...
err = @ref{ncmpi_enddef}(ncid);                    /* exit define mode */
if (err != NC_NOERR) handle_error(err);
   ...
err = @ref{ncmpi_inq_header_size}(ncid, &header_size);
@end example

@node ncmpi_inq_header_extent, ncmpi_sync_numrecs, ncmpi_inq_header_size, Files
@section Inquire the file header extent: ncmpi_inq_header_extent
@findex ncmpi_inq_header_extent
@cindex ncmpi_inq_header_extent, example

This API reports the current file header extent of an opened netCDF file.
The amount is the file space allocated for the file header.

Note there might be a gap between the end of file header (true space used by the header) and the first variable stored in the file.
The gap allows expansion of the header in case new metadata is added to the header.
For example, a program re-enters the define mode and add more metadata.
If the size of gap is sufficiently large enough, the new metadata can be accommodated in the gap without moving the existing variables stored in the data section.

The return value also indicates the starting file offset of the first variable (start file offset of the data section).

@heading Operational Mode
This API is an independent subroutine and can be called while the file is in either define or data mode.

@heading Usage
@example
int ncmpi_inq_header_extent(int         ncid,
                            MPI_Offset *extent);
@end example

@table @code
@item ncid
NetCDF ID, from a previous call to ncmpi_open or ncmpi_create.
@item size
The extent of file header (in bytes).
@end table

@heading Return Error Codes
ncmpi_inq_header_extent returns the value NC_NOERR if no errors occurred. Otherwise, the returned status indicates an error. Possible causes of errors include:
@itemize
@item NC_EBADID: The specified netCDF ID does not refer to an opened netCDF file.
@end itemize

@heading Example
Here is an example using ncmpi_inq_header_extent after a call ncmpi_enddef.

@example
#include <pnetcdf.h>
   ...
int ncid, err;
MPI_Offset header_extent;
   ...
err = @ref{ncmpi_create}(MPI_COMM_WORLD, "foo.nc", NC_CLOBBER, MPI_INFO_NULL,  &ncid);
if (err != NC_NOERR) handle_error(err);
   ...
err = @ref{ncmpi_enddef}(ncid);                    /* exit define mode */
if (err != NC_NOERR) handle_error(err);
   ...
err = @ref{ncmpi_inq_header_extent}(ncid, &header_extent);
@end example

@node ncmpi_sync_numrecs, ncmpi_delete, ncmpi_inq_header_extent, Files
@section Synchronize the number of records in memory across all processes: ncmpi_sync_numrecs
@findex ncmpi_sync_numrecs
@cindex ncmpi_sync_numrecs, example

This API synchronizes the number of records among all processes and flush it to the file.

This API is useful when the file is in independent data mode.
In independent mode, some processes' writes may cause the number of records increased but others may not. To ensure all processes have an up-to-date value of number of records, users should call this API to update/synchronize the value among all processes and the file.

This API has no effect while the file is in collective data mode, because
the number of records is always synchronized in collective mode.

@heading Operational Mode
This API is collective and can only be called in data mode (collective or independent).

@heading Usage
@example
int ncmpi_sync_numrecs(int ncid);
@end example

@table @code
@item ncid
NetCDF ID, from a previous call to ncmpi_open or ncmpi_create.
@end table

@heading Return Error Codes
ncmpi_sync_numrecs returns the value NC_NOERR if no errors occurred. Otherwise, the returned status indicates an error. Possible causes of errors include:
@itemize
@item NC_EBADID: The specified netCDF ID does not refer to an opened netCDF file.
@item NC_EINDEFINE: Operation not allowed in define mode.
@item NC_EPERM: The specified netCDF ID refers to a file open for read-only access.
@item NC_EWRITE: Unknown error in writing to file.
@item NC_ENOTSUPPORT: This API for NetCDF-4 files is not yet supported.
@end itemize

@heading Example
Here is an example using ncmpi_sync_numrecs.

@example
#include <pnetcdf.h>
   ...
int ncid, varid, err;
   ...
err = @ref{ncmpi_create}(MPI_COMM_WORLD, "foo.nc", NC_CLOBBER, MPI_INFO_NULL,  &ncid);
if (err != NC_NOERR) handle_error(err);
   ...
err = @ref{ncmpi_enddef}(ncid);                    /* exit define mode */
if (err != NC_NOERR) handle_error(err);
   ...
err = @ref{ncmpi_put_vara_@var{<type>}, ncmpi_put_vara_int_all}(ncid, varid, ...);
err = @ref{ncmpi_put_vars_@var{<type>}, ncmpi_put_vars_float_all}(ncid, varid, ...);
err = @ref{ncmpi_put_var_@var{<type>}, ncmpi_put_var_short_all}(ncid, varid, ...);
   ...
err = @ref{ncmpi_sync_numrecs}(ncid);
if (err != NC_NOERR) handle_error(err);
   ...
@end example

@node ncmpi_delete, ncmpi_inq_file_info, ncmpi_sync_numrecs, Files
@section Delete a file: ncmpi_delete
@findex ncmpi_delete
@cindex ncmpi_delete, example

The function ncmpi_delete deletes a file, without check if it is a NetCDF file.

@heading Operational Mode
This API is an independent subroutine.

@heading Usage
@example
int ncmpi_delete(const char *filename,
                 MPI_Info    info);
@end example

@table @code
@item filename
Name of the file to be deleted.
@item info
MPI info object, containing file hints to be passed to MPI-IO library.
@end table

@heading Return Error Codes
ncmpi_delete returns the value NC_NOERR if no errors occurred. Otherwise, the returned status indicates an error. Possible causes of errors include:
@itemize
@item NC_ENOENT: The specified netCDF file does not exist.
@item NC_EACCESS: Permission denied.
@item NC_EBAD_FILE: Invalid file name (e.g., path name too long).
@item NC_EFILE: other error returned from MPI_File_delete.
@end itemize

@heading Example
Here is an example using ncmpi_delete.

@example
#include <pnetcdf.h>
   ...
int status;
MPI_Info info = MPI_INFO_NULL;
   ...
status = @ref{ncmpi_delete}("foo.nc", info);
if (status != NC_NOERR) handle_error(status);
@end example

@node ncmpi_inq_file_info, ncmpi_get_file_info, ncmpi_delete, Files
@section Obtain the MPI Info object that contains all the I/O hints currently used: ncmpi_inq_file_info
@findex ncmpi_inq_file_info
@cindex ncmpi_inq_file_info, example

The function ncmpi_inq_file_info returns an MPI info object containing all the file hints used by PnetCDF library.

@heading Operational Mode
This API is an independent subroutine and can be called while the file is in either define or data mode (collective or independent).

@heading Usage
@example
int ncmpi_inq_file_info(int       ncid,
                        MPI_Info *info_used);
@end example

@table @code
@item ncid
NetCDF ID, from a previous call to ncmpi_open or ncmpi_create.
@item info_used
MPI info object, containing file hints used by PnetCDF library. Note that the
returned file hints may be different from the ones set by users, as PnetCDF
adjusts the hint values based on some information available from the file
system underneath.
The user is responsible for freeing info_used via calling MPI_Info_free().
@end table

@heading Return Error Codes
ncmpi_inq_file_info returns the value NC_NOERR if no errors occurred. Otherwise,
the returned status indicates an error. Possible causes of errors include:
@itemize
@item NC_EBADID: The specified netCDF ID does not refer to an opened netCDF file.
@item NC_ENOTSUPPORT: Inquiring MPI-IO info object for NetCDF-4 file is not yet supported.
@end itemize

@heading Example
Here is an example using ncmpi_inq_file_info.

@example
#include <pnetcdf.h>
   ...
int ncid, status, i, nkeys;
MPI_Info info_used;
   ...
status = @ref{ncmpi_inq_file_info}(ncid, &info_used);
if (status != NC_NOERR) handle_error(status);

MPI_Info_inq_nkeys(info_used, &nkeys);
printf("MPI File Info: nkeys = %d\n",nkeys);
for (i=0; i<nkeys; i++) @{
    char key[MPI_MAX_INFO_KEY], value[MPI_MAX_INFO_VAL];
    int  valuelen, flag;

    MPI_Info_get_nthkey(info_used, i, key);
    MPI_Info_get_valuelen(info_used, key, &valuelen, &flag);
    MPI_Info_get(info_used, key, valuelen+1, value, &flag);
    printf("MPI File Info: [%2d] key = %25s, value = %s\n",i,key,value);
@}
MPI_Info_free(&info_used);
@end example

@heading Full example C program
@itemize
@item
@url{https://github.com/Parallel-NetCDF/PnetCDF/tree/master/examples/C/collective_write.c, collective_write.c}
@item
@url{https://github.com/Parallel-NetCDF/PnetCDF/tree/master/examples/C/hints.c, hints.c}
@item
@url{https://github.com/Parallel-NetCDF/PnetCDF/tree/master/examples/C/get_info.c, get_info.c}
@item
@url{https://github.com/Parallel-NetCDF/PnetCDF/tree/master/examples/C/nonblocking_write.c, nonblocking_write.c}
@item
The above programs are available in all PnetCDF releases under directory examples/C.
@end itemize

@node ncmpi_get_file_info, ncmpi_inq_files_opened, ncmpi_inq_file_info, Files
@section Obtain the MPI Info object that contains all the I/O hints currently used (deprecated): ncmpi_get_file_info
@findex ncmpi_get_file_info
@cindex ncmpi_get_file_info, example

This function is deprecated in 1.5.0 and later.
It functions as ncmpi_inq_file_info.
Please refer to @ref{ncmpi_inq_file_info}.


@node ncmpi_inq_files_opened, , ncmpi_get_file_info, Files
@section Reports the number of files that are currently opened: ncmpi_inq_files_opened
@findex ncmpi_inq_files_opened

The function ncmpi_inq_files_opened reports the number of files and their IDs that are currently opened.

@heading Operational Mode
This API is an independent subroutine.

@heading Usage
@example
int ncmpi_inq_files_opened(int *num,
                           int *ncids);
@end example

@table @code
@item num
[Output] number of files. This argument cannot be NULL.
@item ncids
[Output] array of netCDF IDs, each corresponding to an opened file. This argument can be NULL.
@end table

@heading Return Error Codes
ncmpi_inq_files_opened returns the value NC_NOERR if no errors occurred. Otherwise,
the returned status indicates an error. Possible causes of errors include:
@itemize
@item NC_EINVAL: Argument num is NULL.
@end itemize

@heading Example
Here is an example using ncmpi_inq_files_opened.

@example
#include <pnetcdf.h>
   ...
int status, num, *ncids;
   ...
/* inquire the number of file opened */
status = @ref{ncmpi_inq_files_opened}(&num, NULL);
if (status != NC_NOERR) handle_error(status);

/* allocate ncids array */
ncids = malloc(num * sizeof(int);

/* inquire the list of ncids */
status = @ref{ncmpi_inq_files_opened}(&num, ncids);
if (status != NC_NOERR) handle_error(status);
@end example

@node Dimensions, Variables, Files, Top
@chapter Dimensions

@menu
* Dimensions Introduction::     Rules for Dimensions
* ncmpi_def_dim::                  Create a Dimension
* ncmpi_inq_dimid::                Get a Dimension ID from Its Name
* ncmpi_inq_dim Family::           Inquire about a Dimension
* ncmpi_rename_dim::               Rename a Dimension
@end menu

@node Dimensions Introduction, ncmpi_def_dim, Dimensions, Dimensions
@section Dimensions Introduction

Dimensions for a netCDF file are defined when it is created, while
the netCDF file is in define mode. Additional dimensions may be
added later by reentering define mode. A netCDF dimension has a name
and a length. At most one dimension in a netCDF file can have the
unlimited length, which means variables using this dimension can grow
along this dimension.

There is a suggested limit (1024) to the number of dimensions that can
be defined in a single netCDF file. The limit is the value of the
predefined macro NC_MAX_DIMS. The purpose of the limit is to make
writing generic applications simpler. They need only provide an array
of NC_MAX_DIMS dimensions to handle any netCDF file. The
implementation of the PnetCDF library does not enforce this advisory
maximum, so it is possible to use more dimensions, if necessary, but
netCDF utilities that assume the advisory maximums may not be able to
handle the resulting netCDF files.

Ordinarily, the name and length of a dimension are fixed when the
dimension is first defined. The name may be changed later, but the
length of a dimension (other than the unlimited dimension) cannot be
changed without copying all the data to a new netCDF file with a
redefined dimension length.

Dimension lengths in the C interface are type MPI_Offset rather than type
size_t as defined in netCDF-3. The original note from netCDF-3 is "Dimension
lengths in the C interface are type size_t rather than type int to make it
possible to access all the data in a netCDF file on a platform that only
supports a 16-bit int data type. If dimension lengths were type int instead, it
would not be possible to access data from variables with a dimension length
greater than a 16-bit int can accommodate."

A netCDF dimension in an opened netCDF file is referred to by a small
integer called a dimension ID. In the C interface, dimension IDs are
0, 1, 2, ..., in the order in which the dimensions were defined.

Operations supported on dimensions are:
@itemize

@item
Create a dimension, given its name and length.

@item
Get a dimension ID from its name.

@item
Get a dimension's name and length from its ID.

@item
Rename a dimension.
@end itemize

@node ncmpi_def_dim, ncmpi_inq_dimid, Dimensions Introduction, Dimensions
@section Create a Dimension: ncmpi_def_dim
@findex ncmpi_def_dim
@cindex ncmpi_def_dim, example

The function ncmpi_def_dim adds a new dimension to an opened netCDF file
in define mode. It returns (as an argument) a dimension ID, given the
netCDF ID, the dimension name, and the dimension length. At most one
unlimited length dimension, called the record dimension, may be
defined for each netCDF file.

@heading Operational Mode
This API is a collective routine.
All processes must participate the call with the same values for arguments
name and len.

This API must be called while the file is in define mode.

@heading Usage
@example
int ncmpi_def_dim (int         ncid,
                   const char *name,
                   MPI_Offset  len,
                   int        *dimidp);
@end example

@table @code
@item ncid
NetCDF ID, from a previous call to ncmpi_open or ncmpi_create.

@item name
Dimension name. Must be a legal netCDF identifier.
@legalidshort

@item len
Length of dimension; that is, number of values for this dimension as
an index to variables that use it. This should be either a positive
integer (of type MPI_Offset) or the predefined constant NC_UNLIMITED.
@itemize
@item
For CDF-1 format, the maximum length of a dimension is (2^31 - 4) = 2147483644.
@item
For CDF-2 format, the maximum length of a dimension is (2^32 - 4) = 4294967292.
@item
For CDF-5 format, the maximum length of a dimension is
(2^63 - 1) = 9223372036854775807 = NC_MAX_INT64 = INT64_MAX.
Note this maximum is different from the NetCDF library's (2^64-4).
@end itemize

@item dimidp
Pointer to location for returned dimension ID.
@end table

@heading Return Error Codes
ncmpi_def_dim returns the value NC_NOERR if no errors
occurred. Otherwise, the returned status indicates an error. Possible
causes of errors include:
@itemize
@item NC_EBADID: The specified netCDF ID does not refer to an opened netCDF file.
@item NC_ENAMEINUSE: The new name is the name of another dimension.
@item NC_EBADDIM: The dimension ID is invalid for the specified netCDF file.
@item NC_ENOTINDEFINE: Operation not allowed in data mode.
@item NC_EDIMSIZE: The specified length is negative or larger than the limits allowable by the file format.
@item NC_EMAXDIMS: The number of dimensions exceeds the limit, NC_MAX_DIMS=1024.
@item NC_EUNLIMIT: The specified length is unlimited, but there is already an unlimited length dimension defined for this netCDF file.
@item NC_EMULTIDEFINE_DIM_NAME: Dimension name is inconsistent among processes.
@item NC_EMULTIDEFINE_DIM_SIZE: Dimension size is inconsistent among processes.
@end itemize

@heading Example

Here is an example using ncmpi_def_dim to create a dimension named lat of
length 18 and a unlimited dimension named rec in a new netCDF file
named foo.nc:

@example
#include <pnetcdf.h>
   ...
int status, ncid, latid, recid;
MPI_Offset len = 18;
   ...
status = @ref{ncmpi_create}(MPI_COMM_WORLD, "foo.nc", NC_NOCLOBBER, MPI_INFO_NULL, &ncid);
if (status != NC_NOERR) handle_error(status);
   ...
status = @ref{ncmpi_def_dim}(ncid, "lat", len, &latid);
if (status != NC_NOERR) handle_error(status);
status = @ref{ncmpi_def_dim}(ncid, "rec", NC_UNLIMITED, &recid);
if (status != NC_NOERR) handle_error(status);
@end example

@node ncmpi_inq_dimid, ncmpi_inq_dim Family, ncmpi_def_dim, Dimensions
@section Get a Dimension ID from Its Name: ncmpi_inq_dimid
@findex ncmpi_inq_dimid
@cindex ncmpi_inq_dimid, example

The function ncmpi_inq_dimid returns (as an argument) the ID of a netCDF
dimension, given the name of the dimension. If ndims is the number of
dimensions defined for a netCDF file, each dimension has an ID
between 0 and ndims-1.

@heading Operational Mode
This API is an independent subroutine and can be called while the file is in either define or data mode (collective or independent).

@heading Usage
@example
int ncmpi_inq_dimid(int         ncid,
                    const char *name,
                    int        *dimidp);
@end example

@table @code

@item ncid
NetCDF ID, an input argument obtained from a previous call to ncmpi_open or ncmpi_create.

@item name
Dimension name, an input argument, a character string beginning with a letter and
followed by any sequence of letters, digits, or underscore ('_')
characters. Case is significant in dimension names.

@item dimidp
Pointer to location for the returned dimension ID (output).

@end table

@heading Return Error Codes
ncmpi_inq_dimid returns the value NC_NOERR if no errors
occurred. Otherwise, the returned status indicates an error. Possible
causes of errors include:
@itemize
@item NC_EBADID: The specified netCDF ID does not refer to an opened netCDF file.
@item NC_EBADDIM: The name that was specified is not the name of a dimension in the netCDF file.
@end itemize

@heading Example

Here is an example using ncmpi_inq_dimid to determine the dimension ID of
a dimension named lat, assumed to have been defined previously in an
existing netCDF file named foo.nc:

@example
#include <pnetcdf.h>
   ...
int status, ncid, latid;
   ...
status = @ref{ncmpi_open}(MPI_COMM_WORLD, "foo.nc", NC_NOWRITE, MPI_INFO_NULL, &ncid);  /* open for reading */
if (status != NC_NOERR) handle_error(status);
   ...
status = @ref{ncmpi_inq_dimid}(ncid, "lat", &latid);
if (status != NC_NOERR) handle_error(status);
@end example

@node ncmpi_inq_dim Family, ncmpi_rename_dim, ncmpi_inq_dimid, Dimensions
@section Inquire about a Dimension: ncmpi_inq_dim Family
@findex ncmpi_inq_dim Family
@cindex ncmpi_inq_dim Family, example

This family of functions returns information about a netCDF
dimension. Information about a dimension includes its name and its
length. The length for the unlimited dimension, if any, is the number
of records written so far.

The functions in this family include ncmpi_inq_dim, ncmpi_inq_dimname, and
ncmpi_inq_dimlen. The function ncmpi_inq_dim returns all the information
about a dimension; the other functions each return just one item of
information.

@heading Operational Mode
These APIs are independent subroutines and can be called while the file is in either define or data mode (collective or independent).

@heading Usage
@example
int ncmpi_inq_dim     (int ncid, int dimid, char* name, MPI_Offset* lengthp);
int ncmpi_inq_dimname (int ncid, int dimid, char *name);
int ncmpi_inq_dimlen  (int ncid, int dimid, MPI_Offset *lengthp);
@end example

@table @code

@item ncid
NetCDF ID, from a previous call to ncmpi_open or ncmpi_create.

@item dimid
Dimension ID, from a previous call to ncmpi_inq_dimid or ncmpi_def_dim.

@item name
Returned dimension name. The caller must allocate space for the
returned name. The maximum possible length, in characters, of a
dimension name is given by the predefined constant NC_MAX_NAME. (This
doesn't include the null terminator, so declare your array to be size
NC_MAX_NAME+1). The returned character array will be null-terminated.

@item lengthp
Pointer to location for returned length of dimension. For the
unlimited dimension, this is the number of records written so far.

@end table

@heading Return Error Codes
APIs in this group return the value NC_NOERR if no errors
occurred. Otherwise, the returned status indicates an error. Possible
causes of errors include:
@itemize
@item NC_EBADID: The specified netCDF ID does not refer to an opened netCDF file.
@item NC_EBADDIM: The dimension ID is invalid for the specified netCDF file.
@end itemize

@heading Example

Here is an example using ncmpi_inq_dim to determine the length of a
dimension named lat, and the name and current maximum length of the
unlimited dimension for an existing netCDF file named foo.nc:

@example
#include <pnetcdf.h>
   ...
int status, ncid, latid, recid;
MPI_Offset latlength, recs;
char recname[NC_MAX_NAME+1];
   ...
status = @ref{ncmpi_open}(MPI_COMM_WORLD, "foo.nc", NC_NOWRITE, MPI_INFO_NULL, &ncid);  /* open for reading */
if (status != NC_NOERR) handle_error(status);
status = @ref{ncmpi_inq Family, ncmpi_inq_unlimdim}(ncid, &recid); /* get ID of unlimited dimension */
if (status != NC_NOERR) handle_error(status);
   ...
status = @ref{ncmpi_inq_dim Family, ncmpi_inq_dimid}(ncid, "lat", &latid);  /* get ID for lat dimension */
if (status != NC_NOERR) handle_error(status);
status = @ref{ncmpi_inq_dim Family, ncmpi_inq_dimlen}(ncid, latid, &latlength); /* get lat length */
if (status != NC_NOERR) handle_error(status);
/* get unlimited dimension name and current length */
status = @ref{ncmpi_inq_dim Family, ncmpi_inq_dim}(ncid, recid, recname, &recs);
if (status != NC_NOERR) handle_error(status);
@end example

@node ncmpi_rename_dim,  , ncmpi_inq_dim Family, Dimensions
@section Rename a Dimension: ncmpi_rename_dim
@findex ncmpi_rename_dim
@cindex ncmpi_rename_dim, example

The function ncmpi_rename_dim renames an existing dimension in a netCDF
file open for writing.
It is illegal to rename a dimension to the same name as another dimension.

@heading Operational Mode
This API is a collective routine.
All processes must participate the call with the same values for arguments
dimid and name.

This API can be called in either define or data mode in the following conditions.
@itemize
@item
If the new name is longer than the old name, then the netCDF file must be in define mode.
@item
If the new name is shorter than the old name, then the netCDF file can be in either define or data mode.
@end itemize

@heading Usage
@example
int ncmpi_rename_dim(int         ncid,
                     int         dimid,
                     const char *name);
@end example

@table @code

@item ncid
NetCDF ID, from a previous call to ncmpi_open or ncmpi_create.

@item dimid
Dimension ID, from a previous call to ncmpi_inq_dimid or ncmpi_def_dim.

@item name
New dimension name.

@end table

@heading Return Error Codes
ncmpi_rename_dim returns the value NC_NOERR if no errors
occurred. Otherwise, the returned status indicates an error. Possible
causes of errors include:
@itemize
@item NC_EBADID: The specified netCDF ID does not refer to an opened netCDF file.
@item NC_EPERM: The specified netCDF ID refers to a file open for read-only access.
@item NC_ENAMEINUSE: The new name is the name of another dimension.
@item NC_EBADDIM: The dimension ID is invalid for the specified netCDF file.
@item NC_ENOTINDEFINE: The new name is longer than the old name and the netCDF file is not in define mode.
@item NC_EMULTIDEFINE_DIM_NAME: The new dimension name is inconsistent among processes.
@end itemize

@heading Example
Here is an example using ncmpi_rename_dim to rename the dimension lat to
latitude in an existing netCDF file named foo.nc:

@example
#include <pnetcdf.h>
   ...
int status, ncid, latid;
   ...
status = @ref{ncmpi_open}(MPI_COMM_WORLD, "foo.nc", NC_WRITE, MPI_INFO_NULL, &ncid);  /* open for writing */
if (status != NC_NOERR) handle_error(status);
   ...
status = @ref{ncmpi_redef}(ncid);  /* put in define mode to rename dimension */
if (status != NC_NOERR) handle_error(status);
status = @ref{ncmpi_inq_dimid}(ncid, "lat", &latid);
if (status != NC_NOERR) handle_error(status);
status = @ref{ncmpi_rename_dim}(ncid, latid, "latitude");
if (status != NC_NOERR) handle_error(status);
status = @ref{ncmpi_enddef}(ncid); /* leave define mode */
if (status != NC_NOERR) handle_error(status);
@end example

@node Variables, Attributes, Dimensions, Top
@chapter Variables

@menu
* Variable Introduction::       What are Variables?
* Variable Types::              Floating point, integer, and all that
* ncmpi_def_var::               Create a Variable
* ncmpi_def_var_fill::          Set fill mode for a Variable (1.6.1 and later)
* ncmpi_inq_var_fill::          Inquire fill mode of a Variable (1.6.1 and later)
* ncmpi_fill_var_rec::          Fill a record of a record variable (1.6.1 and later)
* ncmpi_inq_varid::             Get a Variable ID from Its Name
* ncmpi_inq_var Family::        Get Information about a Variable from Its ID
* ncmpi_put_var1_@var{<type>}::        Write a Single Data Value
* ncmpi_put_var_@var{<type>}::         Write an Entire Variable
* ncmpi_put_vara_@var{<type>}::        Write an Array of Values
* ncmpi_put_vars_@var{<type>}::        Write a Subsampled Array of Values
* ncmpi_put_varm_@var{<type>}::        Write a Mapped Array of Values
* ncmpi_put_varn_@var{<type>}::        Write a List of Subarrays of Values
* ncmpi_put_vard::        Write an Array of Values using filetype
* ncmpi_get_var1_@var{<type>}::        Read a Single Data Value
* ncmpi_get_var_@var{<type>}::         Read an Entire Variable
* ncmpi_get_vara_@var{<type>}::        Read an Array of Values
* ncmpi_get_vars_@var{<type>}::        Read a Subsampled Array of Values
* ncmpi_get_varm_@var{<type>}::        Read a Mapped Array of Values
* ncmpi_get_varn_@var{<type>}::        Read a List of Subarrays of Values
* ncmpi_get_vard::        Read an Array of Values using filetype
* Strings::                     Reading and Writing Character String Values
* Fill Values::                 What's Written Where there's No Data?
* ncmpi_rename_var::            Rename a Variable
* ncmpi_iput_var@var{<kind>}_@var{<type>}:: Non-blocking APIs for Writing a Subarray
* ncmpi_iget_var@var{<kind>}_@var{<type>}:: Non-blocking APIs for Reading a Subarray
* ncmpi_iput_varn_@var{<type>}:: Non-blocking APIs for Writing a List of Subarrays (1.6.0 and later)
* ncmpi_iget_varn_@var{<type>}:: Non-blocking APIs for Reading a List of Subarrays (1.6.0 and later)
* ncmpi_bput_var@var{<kind>}_@var{<type>}:: Non-blocking Buffered-version APIs for Writing a Subarray (1.3.0 and later)
* ncmpi_bput_varn_@var{<type>}:: Non-blocking Buffered-version APIs for Writing a List of subarrays (1.6.0 and later)
* ncmpi_wait/wait_all::         Wait function for Non-blocking APIs
* ncmpi_inq_nreqs::             inquire number of pending nonblocking requests
* ncmpi_inq_buffer Family::     inquire information about the attached buffer used by buffered put APIs
* ncmpi_cancel::                cancel one or more pending nonblocking requests
@end menu

@node Variable Introduction, Variable Types, Variables, Variables
@section Introduction
@cindex appending data to variable
@cindex variables, rules

Variables for a netCDF file are defined when the dataset is
created, while the netCDF file is in define mode. Other variables
may be added later by reentering define mode. A netCDF variable has a
name, a type, and a shape, which are specified when it is defined. A
variable may also have values, which are established later in data
mode.

Ordinarily, the name, type, and shape are fixed when the variable is
first defined. The name may be changed, but the type and shape of a
variable cannot be changed. However, a variable defined in terms of
the unlimited dimension can grow without bound in that dimension.

A netCDF variable in an opened netCDF file is referred to by a small
integer called a variable ID.

Variable IDs reflect the order in which variables were defined within
a netCDF file. Variable IDs are 0, 1, 2,..., in the order in which
the variables were defined. A function is available for getting the
variable ID from the variable name and vice-versa.

Attributes (@pxref{Attributes}) may be associated with a variable to
specify such properties as units.

Operations supported on variables are:
@itemize

@item
Create a variable, given its name, data type, and shape.

@item
Get a variable ID from its name.

@item
Get a variable's name, data type, shape, and number of attributes from
its ID.

@item
Put a data value into a variable, given variable ID, indices, and
value.

@item
Put an array of values into a variable, given variable ID, corner
indices, edge lengths, and a block of values.

@item
Put a subsampled or mapped array-section of values into a variable,
given variable ID, corner indices, edge lengths, stride vector, index
mapping vector, and a block of values.

@item
Get a data value from a variable, given variable ID and indices.

@item
Get an array of values from a variable, given variable ID, corner
indices, and edge lengths.

@item
Get a subsampled or mapped array-section of values from a variable,
given variable ID, corner indices, edge lengths, stride vector, and
index mapping vector.

@item
Rename a variable.
@end itemize

@node Variable Types, ncmpi_def_var, Variable Introduction, Variables
@section Language Types Corresponding to netCDF external data types
@cindex bit lengths of data types

The following table gives the netCDF external data types defined in CDF-1 and CDF-2 and the
corresponding type constants for defining variables in the C
interface:

@multitable @columnfractions .20 .20 .10 .5
@item Type   @tab C #define @tab Bits @tab Intent of use
@item char   @tab NC_CHAR   @tab 8    @tab text data
@item byte   @tab NC_BYTE   @tab 8    @tab 1-byte integer*
@item short  @tab NC_SHORT  @tab 16   @tab 2-byte signed integer
@item int    @tab NC_INT    @tab 32   @tab 4-byte signed integer
@item float  @tab NC_FLOAT  @tab 32   @tab 4-byte floating point number
@item double @tab NC_DOUBLE @tab 64   @tab 8-byte real number in double precision
@end multitable

The first column gives the netCDF external data type, which is the
same as the CDL data type. The next column gives the corresponding C
preprocessor macro for use in PnetCDF functions (the preprocessor
macros are defined in the netCDF C header-file pnetcdf.h). The third
column gives the number of bits used in the external representation of
values of the corresponding type.

* NC_BYTE is considered unsigned when calling from _uchar APIs and the
file is in either CDF-1 or CDF-2 format. In all other cases, NC_BYTE is
considered signed. For more information about this special treatment, see
@url{http://www.unidata.ucar.edu/software/netcdf/docs/data_type.html#type_conversion}

@heading New data types supported in CDF-5 format

@multitable @columnfractions .30 .20 .10 .40
@item Type               @tab C #define @tab Bits @tab Intent of use
@item unsigned byte      @tab NC_UBYTE  @tab 8    @tab unsigned 1-byte integer
@item unsigned short     @tab NC_USHORT @tab 16   @tab unsigned 2-byte integer
@item unsigned int       @tab NC_UINT   @tab 32   @tab unsigned 4-byte integer
@item long long          @tab NC_INT64  @tab 64   @tab   signed 8-byte integer
@item unsigned long long @tab NC_UINT64 @tab 64   @tab unsigned 8-byte integer
@end multitable


@node ncmpi_def_var, ncmpi_def_var_fill, Variable Types, Variables
@section Create a Variable: @code{ncmpi_def_var}
@findex ncmpi_def_var
@cindex ncmpi_def_var, example
@cindex creating variables
@cindex variables, creating

The function ncmpi_def_var adds a new variable to an opened netCDF file
in define mode. It returns (as an argument) a variable ID, given the
netCDF ID, the variable name, the variable type, the number of
dimensions, and a list of the dimension IDs.

@heading Operational Mode
This API is a collective subroutine.

This API must be called while the file is in define mode.

@heading Usage
@example
int ncmpi_def_var(int         ncid,
                  const char *name,
                  nc_type     xtype,
                  int         ndims,
                  const int   dimids[],
                  int        *varidp);
@end example

@table @code
@item ncid
NetCDF ID, from a previous call to ncmpi_open or ncmpi_create.

@item name
Variable name. Must be a legal netCDF identifier.
@legalidshort

@item xtype
One of the predefined netCDF external data types. The type of this parameter,
nc_type, is defined in the PnetCDF header file, pnetcdf.h. The valid netCDF
external data types are NC_BYTE, NC_CHAR, NC_SHORT, NC_INT, NC_FLOAT, and
NC_DOUBLE. For CDF-5 file format, the following additional data types are
supported: NC_UBYTE, NC_USHORT, NC_UINT, NC_INT64, and NC_UINT64.

@item ndims
Number of dimensions for the variable. For example, 2 specifies a
matrix, 1 specifies a vector, and 0 means the variable is a scalar
with no dimensions. Must not be negative or greater than the
predefined constant NC_MAX_VAR_DIMS.

@item dimids
Vector of ndims dimension IDs corresponding to the variable
dimensions. If the ID of the unlimited dimension is included, it must
be first. This argument is ignored if ndims is 0.

@item varidp
Pointer to location for the returned variable ID.
@end table

@heading Return Error Codes
ncmpi_def_var returns the value NC_NOERR if no errors
occurred. Otherwise, the returned status indicates an error. Possible
causes of errors include:
@itemize
@item NC_EBADID: Bad ncid. The specified netCDF ID does not refer to an opened netCDF file.
@item NC_ENOTINDEFINE: Operation not allowed in data mode.
@item NC_EBADNAME: Name contains illegal characters.
@item NC_EMAXNAME: NC_MAX_NAME exceeded.
@item NC_EBADTYPE: Not a valid NC data type used in argument xtype.
@item NC_ESTRICTCDF2: Attempting CDF-5 operation on strict CDF or CDF-2 file (the NC data type specified in xtype is only valid in CDF-5 files).
@item NC_EBADDIM: One or more of the dimension IDs in the list of dimensions is not a valid dimension ID for the netCDF file.
@item NC_EINVAL: Number of dimensions too large, or negative.
@item NC_EMAXVARS: The number of variables would exceed the constant NC_MAX_VARS, the maximum number of variables permitted in a netCDF file.
@item NC_ENAMEINUSE: Name already in use.
@item NC_EUNLIMPOS: only the highest dimension can be unlimited.
@item NC_ENOMEM: run out of memory.
@item NC_EVARSIZE: The size of variable exceeds the size constraints for whichever variant of the file format is in use.
@end itemize

@heading Example

Here is an example using ncmpi_def_var to create a variable named rh of
type double with three dimensions, time, lat, and lon in a new netCDF
file named foo.nc:

@example
#include <pnetcdf.h>
   ...
int  status;                       /* error status */
int  ncid;                         /* netCDF ID */
int  lat_dim, lon_dim, time_dim;   /* dimension IDs */
int  rh_id;                        /* variable ID */
int  rh_dimids[3];                 /* variable shape */
   ...
status = @ref{ncmpi_create}(MPI_COMM_WORLD, "foo.nc", NC_NOCLOBBER, MPI_INFO_NULL, &ncid);
if (status != NC_NOERR) handle_error(status);
   ...
                                   /* define dimensions */
status = @ref{ncmpi_def_dim}(ncid, "lat", 5L, &lat_dim);
if (status != NC_NOERR) handle_error(status);
status = @ref{ncmpi_def_dim}(ncid, "lon", 10L, &lon_dim);
if (status != NC_NOERR) handle_error(status);
status = @ref{ncmpi_def_dim}(ncid, "time", NC_UNLIMITED, &time_dim);
if (status != NC_NOERR) handle_error(status);
   ...
                                   /* define variable */
rh_dimids[0] = time_dim;
rh_dimids[1] = lat_dim;
rh_dimids[2] = lon_dim;
status = @ref{ncmpi_def_var}(ncid, "rh", NC_DOUBLE, 3, rh_dimids, &rh_id);
if (status != NC_NOERR) handle_error(status);
@end example

@node ncmpi_def_var_fill, ncmpi_inq_var_fill, ncmpi_def_var, Variables
@section Set fill mode for a Variable: @code{ncmpi_def_var_fill}
@findex ncmpi_def_var_fill
@cindex ncmpi_def_var_fill, example
@cindex fill
@cindex variables, fill


The API ncmpi_def_var_fill sets the fill mode parameters for a
variable. This API is only available in version 1.6.1 and later.

@comment An alternative way to turn on the fill mode for a variable is through the call to @ref{ncmpi_put_att_@var{<type>}} to set the attribute ``_FillValue''.  Similar, deleting the attribute ``_FillValue'' through a call to @ref{ncmpi_del_att} turns off the fill mode for a variable.  PnetCDF checks this attribute for the fill mode status of a variable.

This API must be called after the variable is defined, but before
ncmpi_enddef is called.

@heading Operational Mode
This API is a collective subroutine.

This API must be called while the file is in define mode.

@heading Usage

@example
int ncmpi_def_var_fill(int         ncid,
                       int         varid,
                       int         no_fill,
                       const void *fill_value);
@end example

@table @code

@item ncid
NetCDF ID, from a previous call to ncmpi_open or ncmpi_create.

@item varid
Variable ID. This value must be consistent across all calling MPI processes.

@item no_fill
Set no_fill mode for a variable.
1 for on (not to fill) and 0 for off (to fill).
When this mode is on, fill values will
not be written for the variable. This is helpful in high performance applications.
The mode may only be changed after the variable is defined, but before it
is committed to disk (i.e. before the first ncmpi_enddef after the ncmpi_def_var.)

@item fill_value
A pointer to a value which will be used as the fill value for the
variable. Must be the same type as the variable. This will be written
to a _FillValue attribute, created for this purpose. If NULL, this
argument will be ignored and the default fill value is used.

@end table

@heading Return Error Codes
ncmpi_def_var_fill returns the value NC_NOERR if no errors
occurred. Otherwise, the returned status indicates an error. Possible
causes of errors include:
@itemize
@item NC_EBADID: Bad ncid. The specified netCDF ID does not refer to an opened netCDF file.
@item NC_EPERM: Attempt write operations in read-only file.
@item NC_ENOTINDEFINE: Operation not allowed in data mode.
@item NC_ENOTVAR: Cannot find this variable.
@item NC_EGLOBAL: NC_GLOBAL is considered invalid variable ID for this API.
@item NC_EMULTIDEFINE_VAR_FILL_MODE: Fill modes are inconsistent among all MPI processes.
@item NC_EMULTIDEFINE_VAR_FILL_VALUE: Fill values are inconsistent among all MPI processes.
@end itemize

@heading Example

Here is an example using ncmpi_def_var to create a variable named rh of
type double with three dimensions and turn on the variable's fill mode using
the PnetCDF default fill value.

@example
#include <pnetcdf.h>

/* create a file */
/* define dimensions */
    ...
status = @ref{ncmpi_def_var}(ncid, "rh", NC_DOUBLE, 3, dimids, &varid);
if (status != NC_NOERR) handle_error(status);

/* set fill mode to yes and use the default fill values */
status = @ref{ncmpi_def_var_fill}(ncid, varid, 0, NULL);
if (status != NC_NOERR) handle_error(status);

status = @ref{ncmpi_enddef}(ncid);
if (status != NC_NOERR) handle_error(status);
@end example

@heading Full example C program
@itemize
@item
@url{https://github.com/Parallel-NetCDF/PnetCDF/tree/master/examples/C/fill_mode.c, fill_mode.c}
@item
The above programs are available in all PnetCDF releases under directory examples/C.
@end itemize


@node ncmpi_inq_var_fill, ncmpi_fill_var_rec, ncmpi_def_var_fill, Variables
@section Inquire Fill Mode Settings of a Variable: @code{ncmpi_inq_var_fill}
@findex ncmpi_inq_var_fill
@cindex ncmpi_inq_var_fill, example
@cindex fill
@cindex variables, fill

The API ncmpi_inq_var_fill returns the fill mode settings for a
variable.  This API is only available in version 1.6.1 and later.

@heading Operational Mode
This API is an independent subroutine.

This API can be called while the file is in either define or data mode.

@heading Usage

@example
int ncmpi_inq_var_fill(int   ncid,
                       int   varid,
                       int  *no_fill,
                       void *fill_value);
@end example

@table @code

@item ncid
NetCDF ID, from a previous call to ncmpi_open or ncmpi_create.

@item varid
Variable ID. Different MPI processes may use different variable IDs.

@item no_fill
Pointer to an integer which will get a 1 if no_fill mode is set for
this variable, 0 if no_fill mode is false.
@xref{ncmpi_def_var_fill} for turning on and off the fill mode for a variable.
This argument will be ignored if it is NULL.

@item fill_value
A pointer which will get the fill value for this variable. This
argument will be ignored if it is NULL.

@end table

@heading Return Error Codes
ncmpi_inq_var_fill returns the value NC_NOERR if no errors
occurred. Otherwise, the returned status indicates an error. Possible
causes of errors include:
@itemize
@item NC_EBADID: Bad ncid. The specified netCDF ID does not refer to an opened netCDF file.
@item NC_ENOTVAR: Cannot find this variable.
@item NC_EGLOBAL: NC_GLOBAL is considered invalid variable ID for this API.
@end itemize

@heading Example

Here is an example using ncmpi_def_var to create a variable named rh of
type double with three dimensions. Calling ncmpi_def_var_fill to turn on the
variable's fill mode with the PnetCDF default fill value. Later in data mode,
it calls ncmpi_inq_var_fill to inquire the fill mode settings of the variable.

@example
#include <pnetcdf.h>

int    no_fill;
double fill_value_in;

    ...  /* create a file */
    ...  /* define dimensions */

status = @ref{ncmpi_def_var}(ncid, "rh", NC_DOUBLE, 3, dimids, &varid);
if (status != NC_NOERR) handle_error(status);

status = @ref{ncmpi_def_var_fill}(ncid, varid, 0, NULL);
if (status != NC_NOERR) handle_error(status);

status = @ref{ncmpi_enddef}(ncid);
if (status != NC_NOERR) handle_error(status);
    ...

/* check fill mode settings for variable "rh" */
status = @ref{ncmpi_inq_var_fill}(ncid, varid, &no_fill, &fill_value_in);
if (status != NC_NOERR) handle_error(status);
@end example

@heading Full example C program
@itemize
@item
@url{https://github.com/Parallel-NetCDF/PnetCDF/tree/master/examples/C/fill_mode.c, fill_mode.c}
@item
The above programs are available in all PnetCDF releases under directory examples/C.
@end itemize



@node ncmpi_fill_var_rec, ncmpi_inq_varid, ncmpi_inq_var_fill, Variables
@section Fill a record of a Variable: @code{ncmpi_fill_var_rec}
@findex ncmpi_fill_var_rec
@cindex ncmpi_fill_var_rec, example
@cindex Filling a record of a Variable
@cindex variables, fill mode


The API ncmpi_fill_var_rec fills a record of a record variable
with predefined or user-defined fill values.
It is available in version 1.6.1 and later.

@heading Operational Mode
This API is collective and can only be called in collective data mode.

@heading Usage

@example
int ncmpi_fill_var_rec(int        ncid,
                       int        varid,
                       MPI_Offset recno);
@end example

@table @code

@item ncid
NetCDF ID, from a previous call to ncmpi_open or ncmpi_create.

@item varid
Variable ID. This value must be consistent across all calling MPI processes.

@item recno
index of the record to be filled

@end table

@heading Return Error Codes
ncmpi_fill_var_rec returns the value NC_NOERR if no errors
occurred. Otherwise, the returned status indicates an error. Possible
causes of errors include:
@itemize
@item NC_EBADID: Bad ncid. The specified netCDF ID does not refer to an opened netCDF file.
@item NC_EPERM: Attempt write operations in read-only file.
@item NC_EINDEP: Attempt collective I/O operations in independent data mode.
@item NC_ENOTVAR: Can't find this variable.
@item NC_EGLOBAL: NC_GLOBAL is considered invalid variable ID for this API.
@item NC_ENOTRECVAR: This variable is not a record.
@item NC_ENOTFILL: This variable's fill mode is off.
@item NC_ENOTSUPPORT: This API for NetCDF-4 files is not yet supported.
@end itemize

@heading Example

@example
#include <pnetcdf.h>

    ...  /* create a file */

/* define dimensions */
status = @ref{ncmpi_def_dim}(ncid, "rec_dim", NC_UNLIMITED, &dimids[0]);
if (status != NC_NOERR) handle_error(status);
status = @ref{ncmpi_def_dim}(ncid, "lon_dim", 1024, &dimids[1]);
if (status != NC_NOERR) handle_error(status);
status = @ref{ncmpi_def_dim}(ncid, "lat_dim", 1024, &dimids[2]);
if (status != NC_NOERR) handle_error(status);
    ...

/* define variables */
status = @ref{ncmpi_def_var}(ncid, "rec_var", NC_DOUBLE, 3, dimids, &varid);
if (status != NC_NOERR) handle_error(status);
    ...

status = @ref{ncmpi_enddef}(ncid);
if (status != NC_NOERR) handle_error(status);

/* fill the first record of variable rec_var */
status = @ref{ncmpi_fill_var_rec}(ncid, varid, 0);
if (status != NC_NOERR) handle_error(status);

/* fill the second record of variable rec_var */
status = @ref{ncmpi_fill_var_rec}(ncid, varid, 1);
if (status != NC_NOERR) handle_error(status);
@end example


@node ncmpi_inq_varid, ncmpi_inq_var Family, ncmpi_fill_var_rec, Variables
@section Get a Variable ID from Its Name: ncmpi_inq_varid
@findex ncmpi_inq_varid
@cindex ncmpi_inq_varid, example
@cindex variables, inquiring about
@cindex inquiring about variables

The function ncmpi_inq_varid returns the ID of a netCDF variable, given
its name.

@heading Operational Mode
This API is an independent subroutine.

This API can be called while the file is in either define or data mode (collective or independent).

@heading Usage
@example
int ncmpi_inq_varid(int         ncid,
                    const char *name,
                    int        *varidp);
@end example

@table @code
@item ncid
NetCDF ID, from a previous call to ncmpi_open or ncmpi_create.

@item name
Variable name for which ID is desired.

@item varidp
Pointer to location for returned variable ID.
@end table

@heading Return Error Codes
ncmpi_inq_varid returns the value NC_NOERR if no errors
occurred. Otherwise, the returned status indicates an error. Possible
causes of errors include:
@itemize
@item NC_EBADID: Bad ncid. The specified netCDF ID does not refer to an opened netCDF file.
@item NC_ENOTVAR: The specified variable name is not a valid name for a variable in the specified netCDF file.
@end itemize

@heading Example

Here is an example using ncmpi_inq_varid to find out the ID of a variable
named rh in an existing netCDF file named foo.nc:

@example
#include <pnetcdf.h>
   ...
int  status, ncid, rh_id;
   ...
status = @ref{ncmpi_open}(MPI_COMM_WORLD, "foo.nc", NC_NOWRITE, MPI_INFO_NULL,  &ncid);
if (status != NC_NOERR) handle_error(status);
   ...
status = @ref{ncmpi_inq_varid}(ncid, "rh", &rh_id);
if (status != NC_NOERR) handle_error(status);
@end example

@heading Full example C program
@itemize
@item
@url{https://github.com/Parallel-NetCDF/PnetCDF/tree/master/examples/C/fill_mode.c, fill_mode.c}
@item
The above programs are available in all PnetCDF releases under directory examples/C.
@end itemize

@node ncmpi_inq_var Family, ncmpi_put_var1_@var{<type>}, ncmpi_inq_varid, Variables
@section Get Information about a Variable from Its ID: ncmpi_inq_var Family
@findex ncmpi_inq_var
@findex ncmpi_inq_varname
@findex ncmpi_inq_vartype
@findex ncmpi_inq_varndims
@findex ncmpi_inq_vardimid
@findex ncmpi_inq_varnatts
@findex ncmpi_inq_varoffset
@cindex ncmpi_inq_var, example
@cindex variables, getting name

A family of functions that returns information about a netCDF
variable, given its ID. Information about a variable includes its
name, type, number of dimensions, a list of dimension IDs describing
the shape of the variable, and the number of variable attributes that
have been assigned to the variable.

The function ncmpi_inq_var returns all the information about a netCDF
variable, given its ID. The other functions each return just one item
of information about a variable.

These other functions include ncmpi_inq_varname, ncmpi_inq_vartype,
ncmpi_inq_varndims, ncmpi_inq_vardimid, and ncmpi_inq_varnatts.

@heading Operational Mode
These APIs are independent subroutines.

These APIs can be called while the file is in either define or data mode (collective or independent).

@heading Usage
@example
int ncmpi_inq_var       (int ncid, int varid, char *name, nc_type *xtypep,
                         int *ndimsp, int dimids[], int *nattsp);
int ncmpi_inq_varname   (int ncid, int varid, char *name);
int ncmpi_inq_vartype   (int ncid, int varid, nc_type *xtypep);
int ncmpi_inq_varndims  (int ncid, int varid, int *ndimsp);
int ncmpi_inq_vardimid  (int ncid, int varid, int dimids[]);
int ncmpi_inq_varnatts  (int ncid, int varid, int *nattsp);
int ncmpi_inq_varoffset (int ncid, int varid, MPI_Offset *offset);
@end example

@table @code

@item ncid
NetCDF ID, from a previous call to ncmpi_open or ncmpi_create.

@item varid
Variable ID. Different MPI processes may use different variable IDs.

@item name
Returned variable name. The caller must allocate space for the
returned name. The maximum possible length, in characters, of a
variable name is given by the predefined constant NC_MAX_NAME. (This
doesn't include the null terminator, so declare your array to be size
NC_MAX_NAME+1). The returned character array will be null-terminated.

@item xtypep
Pointer to location for returned variable type, one of the set of
predefined netCDF external data types. The type of this parameter,
nc_type, is defined in the netCDF header file. The valid netCDF
external data types are NC_BYTE, NC_CHAR, NC_SHORT, NC_INT, NC_FLOAT,
and NC_DOUBLE.
For CDF-5 file format, the following data types are also supported: NC_UBYTE, NC _USHORT, NC_UINT, NC_INT64, and NC_UINT64.

@item ndimsp
Pointer to location for returned number of dimensions the variable
was defined as using. For example, 2 indicates a matrix, 1 indicates a
vector, and 0 means the variable is a scalar with no dimensions.

@item dimids
Returned vector of *ndimsp dimension IDs corresponding to the
variable dimensions. The caller must allocate enough space for a
vector of at least *ndimsp integers to be returned. The maximum
possible number of dimensions for a variable is given by the
predefined constant NC_MAX_VAR_DIMS.

@item nattsp
Pointer to location for returned number of variable attributes
assigned to this variable.

@item offset
Pointer to the location for returned starting file offset of
this variable.
@end table

@heading Return Error Codes
APIs in this group return the value NC_NOERR if no errors
occurred. Otherwise, the returned status indicates an error. Possible
causes of errors include:
@itemize
@item NC_EBADID: Bad ncid.  The specified netCDF ID does not refer to an opened netCDF file.
@item NC_ENOTVAR: The variable ID is invalid for the specified netCDF file.
@item NC_EGLOBAL: NC_GLOBAL is considered invalid for these APIs, except ncmpi_inq_varnatts().
@item NC_ENOTSUPPORT: This API for NetCDF-4 files is not yet supported.
@end itemize

@heading Example

Here is an example using ncmpi_inq_var to find out about a variable named
rh in an existing netCDF file named foo.nc:

@example
#include <pnetcdf.h>
   ...
int  status                        /* error status */
int  ncid;                         /* netCDF ID */
int  rh_id;                        /* variable ID */
nc_type rh_type;                   /* variable type */
int rh_ndims;                      /* number of dims */
int rh_dimids[NC_MAX_VAR_DIMS];    /* dimension ids */
int rh_natts                       /* number of attributes */
   ...
status = @ref{ncmpi_open}(MPI_COMM_WORLD, "foo.nc", NC_NOWRITE, MPI_INFO_NULL,  &ncid);
if (status != NC_NOERR) handle_error(status);
   ...
status = @ref{ncmpi_inq_varid}(ncid, "rh", &rh_id);
if (status != NC_NOERR) handle_error(status);
/* we don't need name, since we already know it */
status = @ref{ncmpi_inq_var Family, ncmpi_inq_var}(ncid, rh_id, 0, &rh_type, &rh_ndims, rh_dimids, &rh_natts);
if (status != NC_NOERR) handle_error(status);
@end example

@node ncmpi_put_var1_@var{<type>}, ncmpi_put_var_@var{<type>}, ncmpi_inq_var Family, Variables
@section Write a Single Data Value: ncmpi_put_var1_@var{<type>}
@findex ncmpi_put_var1_text
@findex ncmpi_put_var1_uchar
@findex ncmpi_put_var1_schar
@findex ncmpi_put_var1_short
@findex ncmpi_put_var1_int
@findex ncmpi_put_var1_float
@findex ncmpi_put_var1_double
@findex ncmpi_put_var1_ushort
@findex ncmpi_put_var1_unit
@findex ncmpi_put_var1_longlong
@findex ncmpi_put_var1_ulonglong
@cindex ncmpi_put_var1_text, example
@cindex ncmpi_put_var1_uchar, example
@cindex ncmpi_put_var1_schar, example
@cindex ncmpi_put_var1_short, example
@cindex ncmpi_put_var1_int, example
@cindex ncmpi_put_var1_float, example
@cindex ncmpi_put_var1_double, example
@cindex ncmpi_put_var1_ushort, example
@cindex ncmpi_put_var1_unit, example
@cindex ncmpi_put_var1_longlong, example
@cindex ncmpi_put_var1_ulonglong, example
@cindex writing single value

The functions ncmpi_put_var1_@var{<type>} put a single data value of the
specified type into a variable of an opened netCDF file that is in
data mode. Inputs are the netCDF ID, the variable ID, an index that
specifies which value to add or alter, and the data value. The value
is converted to the external data type of the variable, if necessary.

@heading Data types
@html
<table cellpadding="4" border="1">
<tr class="spacer" align=center>
    <td> &lt;<b>type  </b>&gt; for API names </td>
    <td> &lt;<b>C type</b>&gt; for API arguments </td>
</tr>
<tr align=center> <td>text     </td> <td>char             </td> </tr>
<tr align=center> <td>schar    </td> <td>signed char      </td> </tr>
<tr align=center> <td>short    </td> <td>short            </td> </tr>
<tr align=center> <td>int      </td> <td>int              </td> </tr>
<tr align=center> <td>float    </td> <td>float            </td> </tr>
<tr align=center> <td>double   </td> <td>double           </td> </tr>
<tr align=center> <td>uchar    </td> <td>unsigned char    </td> </tr>
<tr align=center> <td>ushort   </td> <td>unsigned short   </td> </tr>
<tr align=center> <td>uint     </td> <td>unsigned int     </td> </tr>
<tr align=center> <td>longlong </td> <td>long long        </td> </tr>
<tr align=center> <td>ulonglong</td> <td>unsigned longlong</td> </tr>
</table>
@end html

@heading Operational Mode
These API must be called while the file is in data mode.

@heading Collective I/O
The corresponding collective APIs have the suffix name "_all" and must be called in collective data mode.

@heading Usage
@example
     int ncmpi_put_var1_@strong{<type>}     (int                  ncid,
                                     int                 varid,
                                     const MPI_Offset    index[],
                                     const @strong{<C type>}     *buf);

     int ncmpi_put_var1             (int                 ncid,
                                     int                 varid,
                                     const MPI_Offset    index[],
                                     const void         *buf,
                                     MPI_Offset          bufcount,
                                     MPI_Datatype        buftype);

     int ncmpi_put_var1_@strong{<type>}_all (int                  ncid,
                                     int                 varid,
                                     const MPI_Offset    index[],
                                     const @strong{<C type>}     *buf);

     int ncmpi_put_var1_all         (int                 ncid,
                                     int                 varid,
                                     const MPI_Offset    index[],
                                     const void         *buf,
                                     MPI_Offset          bufcount,
                                     MPI_Datatype        buftype);
@end example

@table @code

@item ncid
NetCDF ID, from a previous call to ncmpi_open or ncmpi_create.

@item varid
Variable ID. Different MPI processes may use different variable IDs.

@item index[]
The index of the data value to be written. The indices are relative
to 0, so for example, the first data value of a two-dimensional
variable would have index (0,0). The elements of index must correspond
to the variable's dimensions. Hence, if the variable uses the
unlimited dimension, the first index would correspond to the unlimited
dimension.

@item buf
Pointer to the data value to be written. If the type of data values
differs from the netCDF variable type, type conversion will
occur.
@c @xref{Type Conversion,,, pnetcdf, The PnetCDF Users Guide}.

@item bufcount
An integer indicates the number of MPI derived data type elements in the buf to be written to the file.

@item buftype
An MPI derived data type that describes the memory layout of buf.
Starting from PnetCDF version 1.6.0, buftype can be MPI_DATATYPE_NULL.
In this case, bufcount is ignored and the buf's data type must match the type
of the variable defined in the file - no data conversion will be done.

@end table

@heading Return Error Codes
ncmpi_put_var1_@var{<type>} returns the value NC_NOERR if no errors
occurred. Otherwise, the returned status indicates an error. Possible
causes of errors include:
@itemize
@item NC_EBADID: Bad ncid.  The specified netCDF ID does not refer to an opened netCDF file.
@item NC_EPERM: Attempt write operations in read-only file.
@item NC_EINDEFINE: Operation not allowed in define mode.
@item NC_ENOTVAR: The variable ID is invalid for the specified netCDF file.
@item NC_EGLOBAL: NC_GLOBAL is considered invalid for these APIs.
@item NC_EINVALCOORDS: The specified indices were out of range for the rank of the specified variable. For example, a negative index or an index that is larger than the corresponding dimension length will cause an error.
@item NC_ERANGE: The specified value is out of the range of values representable by the external data type of the variable.
@item NC_ECHAR: Attempt to convert numerical values to or from text data.
@item NC_EINDEP: Attempt collective I/O operations in independent data mode.
@item NC_ENOTINDEP: Attempt independent I/O operations in collective data mode.
@item NC_EIOMISMATCH: The number of variable elements requested in (bufcount, buftype) is not equal to one. This error may only occur for flexible APIs.
@item NC_ENOTSUPPORT: Flexible APIs for NetCDF-4 files is not yet supported.
@end itemize

@heading Example

Here is an example using ncmpi_put_var1_double_all to set the elements
at starting indices (1+rank*10, 2+rank*10, 3+rank*10) of the variable
named rh in parallel to 0.5+rank in an existing netCDF file named
foo.nc. For simplicity in this example, we assume that we know that rh
is dimensioned with time, lat, and lon. If run sequentially (i.e. one MPI
process), this example is equivalent to to set the values of
rh that corresponds to the second time value, the third lat value, and
the fourth lon value:

@example
#include <pnetcdf.h>
   ...
int  status;                       /* error status */
int  rank;                         /* MPI process rank ID */
int  ncid;                         /* netCDF ID */
int  rh_id;                        /* variable ID */
MPI_Offset rh_index[] = @{1, 2, 3@}; /* where to put value */
double rh_val = 0.5 + rank;        /* value to put */
   ...
/* Open file in write mode */
status = @ref{ncmpi_open}(MPI_COMM_WORLD, "foo.nc", NC_WRITE, MPI_INFO_NULL,  &ncid);
if (status != NC_NOERR) handle_error(status);
   ...
/* Obtain the variabe ID */
status = @ref{ncmpi_inq_varid}(ncid, "rh", &rh_id);
if (status != NC_NOERR) handle_error(status);
   ...
/* Set the starting indices. Indices are different among processes */
MPI_Comm_rank(MPI_COMM_WORLD, &rank);
rh_index[0] += rank*10;
rh_index[1] += rank*10;
rh_index[2] += rank*10;

/* Each MPI process writes a single value to a different location of variable rh */
status = @ref{ncmpi_put_var1_@var{<type>}, ncmpi_put_var1_double_all}(ncid, rh_id, rh_index, &rh_val);
if (status != NC_NOERR) handle_error(status);
@end example

@node ncmpi_put_var_@var{<type>}, ncmpi_put_vara_@var{<type>}, ncmpi_put_var1_@var{<type>}, Variables
@section Write an Entire Variable: ncmpi_put_var_@var{<type>}
@findex ncmpi_put_var_text
@findex ncmpi_put_var_uchar
@findex ncmpi_put_var_schar
@findex ncmpi_put_var_short
@findex ncmpi_put_var_int
@findex ncmpi_put_var_float
@findex ncmpi_put_var_double
@findex ncmpi_put_var_ushort
@findex ncmpi_put_var_unit
@findex ncmpi_put_var_longlong
@findex ncmpi_put_var_ulonglong
@findex ncmpi_put_var_text_all
@findex ncmpi_put_var_uchar_all
@findex ncmpi_put_var_schar_all
@findex ncmpi_put_var_short_all
@findex ncmpi_put_var_int_all
@findex ncmpi_put_var_float_all
@findex ncmpi_put_var_double_all
@findex ncmpi_put_var_ushort_all
@findex ncmpi_put_var_unit_all
@findex ncmpi_put_var_longlong_all
@findex ncmpi_put_var_ulonglong_all
@cindex ncmpi_put_var_text, example
@cindex ncmpi_put_var_uchar, example
@cindex ncmpi_put_var_schar, example
@cindex ncmpi_put_var_short, example
@cindex ncmpi_put_var_int, example
@cindex ncmpi_put_var_float, example
@cindex ncmpi_put_var_double, example
@cindex ncmpi_put_var_ushort, example
@cindex ncmpi_put_var_unit, example
@cindex ncmpi_put_var_longlong, example
@cindex ncmpi_put_var_ulonglong, example
@cindex ncmpi_put_var_text_all, example
@cindex ncmpi_put_var_uchar_all, example
@cindex ncmpi_put_var_schar_all, example
@cindex ncmpi_put_var_short_all, example
@cindex ncmpi_put_var_int_all, example
@cindex ncmpi_put_var_float_all, example
@cindex ncmpi_put_var_double_all, example
@cindex ncmpi_put_var_ushort_all, example
@cindex ncmpi_put_var_unit_all, example
@cindex ncmpi_put_var_longlong_all, example
@cindex ncmpi_put_var_ulonglong_all, example
@cindex writing entire variable
@cindex entire variable, writing
@cindex variable, writing entire

The ncmpi_put_var_@var{<type>} family of functions write all the values of a
variable into a netCDF variable of an opened netCDF file. This is the
simplest interface to use for writing a value in a scalar variable or
whenever all the values of a multidimensional variable can all be
written at once. The values to be written are associated with the
netCDF variable by assuming that the last dimension of the netCDF
variable varies fastest in the C interface. The values are converted
to the external data type of the variable, if necessary.

Take care when using the simplest forms of this interface with record
variables when you don't specify how many records are to be
written. If you try to write all the values of a record variable into
a netCDF file that has no record data yet (hence has 0 records),
nothing will be written. Similarly, if you try to write all of a
record variable but there are more records in the file than you
assume, more data may be written to the file than you supply, which
may result in a segmentation violation.

@heading Note on unexpected data in file when run in parallel:
@strong{
Caution when using the same varid!
Since this API writes the entire variable in the file,
when there are multiple MPI processes making this call, collectively or
independently, they will concurrently write to the same file space.
If the contents of write buffers are different among processes, then
the outcomes in file contents are undefined (data may come from any process).
}

@heading Data types
@html
<table cellpadding="4" border="1">
<tr class="spacer" align=center>
    <td> &lt;<b>type  </b>&gt; for API names </td>
    <td> &lt;<b>C type</b>&gt; for API arguments </td>
</tr>
<tr align=center> <td>text     </td> <td>char             </td> </tr>
<tr align=center> <td>schar    </td> <td>signed char      </td> </tr>
<tr align=center> <td>short    </td> <td>short            </td> </tr>
<tr align=center> <td>int      </td> <td>int              </td> </tr>
<tr align=center> <td>float    </td> <td>float            </td> </tr>
<tr align=center> <td>double   </td> <td>double           </td> </tr>
<tr align=center> <td>uchar    </td> <td>unsigned char    </td> </tr>
<tr align=center> <td>ushort   </td> <td>unsigned short   </td> </tr>
<tr align=center> <td>uint     </td> <td>unsigned int     </td> </tr>
<tr align=center> <td>longlong </td> <td>long long        </td> </tr>
<tr align=center> <td>ulonglong</td> <td>unsigned longlong</td> </tr>
</table>
@end html

@heading Operational Mode
These API must be called while the file is in data mode.

@heading Collective I/O
The corresponding collective APIs have the suffix name "_all" and must be called in collective data mode.
@strong{Users are recommended to avoid calling these collective APIs for the same varid, due to the possible conflicts in file contents. See the above note.}


@heading Usage
@example
int ncmpi_put_var_@strong{<type>}     (int                  ncid,
                               int                 varid,
                               const @strong{<C type>}     *buf);

int ncmpi_put_var             (int                 ncid,
                               int                 varid,
                               const void         *buf,
                               MPI_Offset          bufcount,
                               MPI_Datatype        buftype);

int ncmpi_put_var_@strong{<type>}_all (int                  ncid,
                               int                 varid,
                               const @strong{<C type>}     *buf);

int ncmpi_put_var_all         (int                 ncid,
                               int                 varid,
                               const void         *buf,
                               MPI_Offset          bufcount,
                               MPI_Datatype        buftype);
@end example

@table @code

@item ncid
NetCDF ID, from a previous call to ncmpi_open or ncmpi_create.

@item varid
Variable ID. Different MPI processes may use different variable IDs.

@item buf
Pointer to the data value to be written. If the type of data values
differs from the netCDF variable type, type conversion will
occur.
@c @xref{Type Conversion,,, pnetcdf, The PnetCDF Users Guide}.

@item bufcount
An integer indicates the number of MPI derived data type elements in the buf to be written to the file.

@item buftype
An MPI derived data type that describes the memory layout of buf.
Starting from PnetCDF version 1.6.0, buftype can be MPI_DATATYPE_NULL.
In this case, bufcount is ignored and the buf's data type must match the type
of the variable defined in the file - no data conversion will be done.

@end table

@heading Return Error Codes
ncmpi_put_var_@var{<type>} returns the value NC_NOERR if no
errors occurred. Otherwise, the returned status indicates an
error. Possible causes of errors include:
@itemize
@item NC_EBADID: Bad ncid.  The specified netCDF ID does not refer to an opened netCDF file.
@item NC_EPERM: Attempt write operations in read-only file.
@item NC_EINDEFINE: Operation not allowed in define mode.
@item NC_EGLOBAL: NC_GLOBAL is considered invalid for these APIs.
@item NC_ENOTVAR: Bad variable ID.
@item NC_ECHAR: Attempt to convert numerical values to or from text data.
@item NC_EINDEP: Attempt collective I/O operations in independent data mode.
@item NC_ENOTINDEP: Attempt independent I/O operations in collective data mode.
@item NC_EIOMISMATCH: The number of variable elements requested in (bufcount, buftype) mismatches the variable size. This error may only occur for flexible APIs.
@item NC_ENOTSUPPORT: Flexible APIs for NetCDF-4 files is not yet supported.
@end itemize

@heading Example

Here is an example using ncmpi_put_var_double to change all the
values of the variable named rh to 0.5 in an existing netCDF file
named foo.nc. For simplicity in this example, we assume that we know
that rh is dimensioned with time, lat, and lon, and that there are
three time values, five lat values, and ten lon values.

@example
#include <pnetcdf.h>
   ...
#define TIMES 3
#define LATS  5
#define LONS  10
int  status;                       /* error status */
int  ncid;                         /* netCDF ID */
int  rh_id;                        /* variable ID */
double rh_vals[TIMES*LATS*LONS];   /* array to hold values */
int i;
   ...
/* open the file in writeable mode */
status = @ref{ncmpi_open}(MPI_COMM_WORLD, "foo.nc", NC_WRITE, MPI_INFO_NULL,  &ncid);
if (status != NC_NOERR) handle_error(status);
   ...
/* enter independent data mode */
status = @ref{ncmpi_begin_indep_data}(ncid);
if (status != NC_NOERR) handle_error(status);
   ...
/* obtain variable ID */
status = @ref{ncmpi_inq_varid}(ncid, "rh", &rh_id);
if (status != NC_NOERR) handle_error(status);
   ...
for (i = 0; i < TIMES*LATS*LONS; i++)
    rh_vals[i] = 0.5;

MPI_Comm_rank(MPI_COMM_WORLD, &rank);
if (rank == 0) @{
    /* MPI process rank 0 writes the whole variable */
    status = @ref{ncmpi_put_var_@var{<type>}, ncmpi_put_var_double}(ncid, rh_id, rh_vals);
    if (status != NC_NOERR) handle_error(status);
@}
   ...
/* exit independent data mode */
status = @ref{ncmpi_end_indep_data}(ncid);
if (status != NC_NOERR) handle_error(status);
@end example

@node ncmpi_put_vara_@var{<type>}, ncmpi_put_vars_@var{<type>}, ncmpi_put_var_@var{<type>}, Variables
@section Write an Array of Values: ncmpi_put_vara_@var{<type>}
@findex ncmpi_put_vara_text
@findex ncmpi_put_vara_uchar
@findex ncmpi_put_vara_schar
@findex ncmpi_put_vara_short
@findex ncmpi_put_vara_int
@findex ncmpi_put_vara_float
@findex ncmpi_put_vara_double
@findex ncmpi_put_vara_ushort
@findex ncmpi_put_vara_unit
@findex ncmpi_put_vara_longlong
@findex ncmpi_put_vara_ulonglong
@findex ncmpi_put_vara_text_all
@findex ncmpi_put_vara_uchar_all
@findex ncmpi_put_vara_schar_all
@findex ncmpi_put_vara_short_all
@findex ncmpi_put_vara_int_all
@findex ncmpi_put_vara_float_all
@findex ncmpi_put_vara_double_all
@findex ncmpi_put_vara_ushort_all
@findex ncmpi_put_vara_unit_all
@findex ncmpi_put_vara_longlong_all
@findex ncmpi_put_vara_ulonglong_all
@cindex ncmpi_put_vara_text, example
@cindex ncmpi_put_vara_uchar, example
@cindex ncmpi_put_vara_schar, example
@cindex ncmpi_put_vara_short, example
@cindex ncmpi_put_vara_int, example
@cindex ncmpi_put_vara_float, example
@cindex ncmpi_put_vara_double, example
@cindex ncmpi_put_vara_ushort, example
@cindex ncmpi_put_vara_unit, example
@cindex ncmpi_put_vara_longlong, example
@cindex ncmpi_put_vara_ulonglong, example
@cindex ncmpi_put_vara_text_all, example
@cindex ncmpi_put_vara_uchar_all, example
@cindex ncmpi_put_vara_schar_all, example
@cindex ncmpi_put_vara_short_all, example
@cindex ncmpi_put_vara_int_all, example
@cindex ncmpi_put_vara_float_all, example
@cindex ncmpi_put_vara_double_all, example
@cindex ncmpi_put_vara_ushort_all, example
@cindex ncmpi_put_vara_unit_all, example
@cindex ncmpi_put_vara_longlong_all, example
@cindex ncmpi_put_vara_ulonglong_all, example
@cindex writing array section
@cindex array section, writing

The function ncmpi_put_vara_@var{<type>} writes values into a netCDF variable of
an opened netCDF file. The part of the netCDF variable to write is
specified by giving a corner and a vector of edge lengths that refer
to an array section of the netCDF variable. The values to be written
are associated with the netCDF variable by assuming that the last
dimension of the netCDF variable varies fastest in the C
interface.

@heading Data types
@html
<table cellpadding="4" border="1">
<tr class="spacer" align=center>
    <td> &lt;<b>type  </b>&gt; for API names </td>
    <td> &lt;<b>C type</b>&gt; for API arguments </td>
</tr>
<tr align=center> <td>text     </td> <td>char             </td> </tr>
<tr align=center> <td>schar    </td> <td>signed char      </td> </tr>
<tr align=center> <td>short    </td> <td>short            </td> </tr>
<tr align=center> <td>int      </td> <td>int              </td> </tr>
<tr align=center> <td>float    </td> <td>float            </td> </tr>
<tr align=center> <td>double   </td> <td>double           </td> </tr>
<tr align=center> <td>uchar    </td> <td>unsigned char    </td> </tr>
<tr align=center> <td>ushort   </td> <td>unsigned short   </td> </tr>
<tr align=center> <td>uint     </td> <td>unsigned int     </td> </tr>
<tr align=center> <td>longlong </td> <td>long long        </td> </tr>
<tr align=center> <td>ulonglong</td> <td>unsigned longlong</td> </tr>
</table>
@end html

@heading Operational Mode
These API must be called while the file is in data mode.

@heading Collective I/O
The corresponding collective APIs have the suffix name "_all" and must be called in collective data mode.

@heading Usage
@example
int ncmpi_put_vara_@strong{<type>}     (int                  ncid,
                                int                 varid,
                                const MPI_Offset    start[],
                                const MPI_Offset    count[],
                                const @strong{<C type>}     *buf);

int ncmpi_put_vara             (int                 ncid,
                                int                 varid,
                                const MPI_Offset    start[],
                                const MPI_Offset    count[],
                                const void         *buf,
                                MPI_Offset          bufcount,
                                MPI_Datatype        buftype);

int ncmpi_put_vara_@strong{<type>}_all (int                  ncid,
                                int                 varid,
                                const MPI_Offset    start[],
                                const MPI_Offset    count[],
                                const @strong{<C type>}     *buf);

int ncmpi_put_vara_all         (int                 ncid,
                                int                 varid,
                                const MPI_Offset    start[],
                                const MPI_Offset    count[],
                                const void         *buf,
                                MPI_Offset          bufcount,
                                MPI_Datatype        buftype);
@end example

@table @code

@item ncid
NetCDF ID, from a previous call to ncmpi_open or ncmpi_create.

@item varid
Variable ID. Different MPI processes may use different variable IDs.

@item start
A vector of MPI_Offset integers specifying the index in the variable
where the first of the data values will be written. The indices are
relative to 0, so for example, the first data value of a variable
would have index (0, 0, ... , 0). The size of start must be the same
as the number of dimensions of the specified variable. The elements of
start must correspond to the variable's dimensions in order. Hence, if
the variable is a record variable, the first index would correspond to
the starting record number for writing the data values.

@item count
A vector of MPI_Offset integers specifying the edge lengths along each
dimension of the block of data values to be written. To write a single
value, for example, specify count as (1, 1, ... , 1). The length of
count is the number of dimensions of the specified variable. The
elements of count correspond to the variable's dimensions. Hence, if
the variable is a record variable, the first element of count
corresponds to a count of the number of records to write.

@item buf
Pointer to a block of data values to be written. The order in which the data will be written to the netCDF variable is with the last dimension of the specified variable varying fastest. If the type of data values differs from the netCDF variable type, type conversion will occur.
@c @xref{Type Conversion,,, pnetcdf, The PnetCDF Users Guide}.

@item bufcount
An integer indicates the number of MPI derived data type elements in the buf to be written to the file.

@item buftype
An MPI derived data type that describes the memory layout of buf.
Starting from PnetCDF version 1.6.0, buftype can be MPI_DATATYPE_NULL.
In this case, bufcount is ignored and the buf's data type must match the type
of the variable defined in the file - no data conversion will be done.

@end table

@heading Layout Illustration for Write Buffer in Memory and Data Written in File
@center @image{images/put_vara,,, put_vara mapping, png}

@heading Return Error Codes
ncmpi_put_vara_@var{<type>} returns the value NC_NOERR if no errors
occurred. Otherwise, the returned status indicates an error. Possible
causes of errors include:
@itemize
@item NC_EBADID: Bad ncid.  The specified netCDF ID does not refer to an opened netCDF file.
@item NC_EPERM: Attempt write operations in read-only file.
@item NC_ENOTVAR: The variable ID is invalid for the specified netCDF file.
@item NC_EGLOBAL: NC_GLOBAL is considered invalid for these APIs.
@item NC_EINVALCOORDS: The specified corner indices were out of range for the rank of the specified variable. For example, a negative index, or an index that is larger than the corresponding dimension length will cause an error.
@item NC_EEDGE: The specified edge lengths added to the specified corner would have referenced data out of range for the rank of the specified variable. For example, an edge length that is larger than the corresponding dimension length minus the corner index will cause an error.
@item NC_ERANGE: One or more of the specified values are out of the range of values representable by the external data type of the variable. (Does not apply to the nc_put_vara() function).
@item NC_EINDEFINE: Operation not allowed in define mode.
@item NC_ECHAR: Attempt to convert numerical values to or from text data.
@item NC_ENOMEM: Out of memory.
@item NC_EBADTYPE: Bad type.
@item NC_EINDEP: Attempt collective I/O operations in independent data mode.
@item NC_ENOTINDEP: Attempt independent I/O operations in collective data mode.
@item NC_EIOMISMATCH: The number of variable elements requested in (bufcount, buftype) mismatches the one calculated from count. This error may only occur for flexible APIs.
@item NC_ENOTSUPPORT: Flexible APIs for NetCDF-4 files is not yet supported.
@end itemize

@heading Example

Here is an example using ncmpi_put_vara_double_all to write (or overwrite) the
whole third record of the variable named rh in parallel in an existing netCDF file
named foo.nc. For simplicity in this example, we assume that the number of total
MPI processes running is 4 and we know
that rh is dimensioned with time, lat, and lon, and that there are
three time values, five lat values, and 4*10 lon values.

@example
#include <pnetcdf.h>
   ...
#define TIMES 3
#define LATS  5
#define LONS  10
int  status;                       /* error status */
int  ncid;                         /* netCDF ID */
int  rh_id;                        /* variable ID */
MPI_Offset start[3]                /* start indices of array */
MPI_Offset count[3];               /* write lengths along each dimension */
double rh_vals[TIMES*LATS*LONS];   /* local write buffer */
int i;
   ...
/* open file in writeable mode */
status = @ref{ncmpi_open}(MPI_COMM_WORLD, "foo.nc", NC_WRITE, MPI_INFO_NULL,  &ncid);
if (status != NC_NOERR) handle_error(status);
   ...
/* obtain variable ID */
status = @ref{ncmpi_inq_varid}(ncid, "rh", &rh_id);
if (status != NC_NOERR) handle_error(status);
   ...
/* set the starting indices and write lengths for this process */
MPI_Comm_rank(MPI_COMM_WORLD, &rank);
start[0] = 3;
start[1] = 0;
start[2] = LONS * rank;
count[0] = 1;
count[1] = LATS;
count[2] = LONS;
   ...
/* set the write contents */
for (i=0; i<TIMES*LATS*LONS; i++)
    rh_vals[i] = 0.5 + rank;

/* collectively write a record into variable "rh" */
status = @ref{ncmpi_put_vara_@var{<type>}, ncmpi_put_vara_double_all}(ncid, rh_id, start, count, rh_vals);
if (status != NC_NOERR) handle_error(status);
@end example

@heading Full example C program
@itemize
@item
@url{https://github.com/Parallel-NetCDF/PnetCDF/tree/master/examples/C/put_vara.c, put_vara.c}
@item
@url{https://github.com/Parallel-NetCDF/PnetCDF/tree/master/examples/C/block_cyclic.c, block_cyclic.c}
@item
@url{https://github.com/Parallel-NetCDF/PnetCDF/tree/master/examples/C/collective_write.c, collective_write.c}
@item
@url{https://github.com/Parallel-NetCDF/PnetCDF/tree/master/examples/C/column_wise.c, column_wise.c}
@item
@url{https://github.com/Parallel-NetCDF/PnetCDF/tree/master/examples/C/flexible_api.c, flexible_api.c}
@item
@url{https://github.com/Parallel-NetCDF/PnetCDF/tree/master/examples/C/hints.c, hints.c}
@item
The above programs are available in all PnetCDF releases under directory examples/C.
@end itemize

@node ncmpi_put_vars_@var{<type>}, ncmpi_put_varm_@var{<type>}, ncmpi_put_vara_@var{<type>}, Variables
@section Write a Subsampled Array of Values: ncmpi_put_vars_@var{<type>}
@findex ncmpi_put_vars_text
@findex ncmpi_put_vars_uchar
@findex ncmpi_put_vars_schar
@findex ncmpi_put_vars_short
@findex ncmpi_put_vars_int
@findex ncmpi_put_vars_float
@findex ncmpi_put_vars_double
@findex ncmpi_put_vars_ushort
@findex ncmpi_put_vars_unit
@findex ncmpi_put_vars_longlong
@findex ncmpi_put_vars_ulonglong
@findex ncmpi_put_vars_text_all
@findex ncmpi_put_vars_uchar_all
@findex ncmpi_put_vars_schar_all
@findex ncmpi_put_vars_short_all
@findex ncmpi_put_vars_int_all
@findex ncmpi_put_vars_float_all
@findex ncmpi_put_vars_double_all
@findex ncmpi_put_vars_ushort_all
@findex ncmpi_put_vars_unit_all
@findex ncmpi_put_vars_longlong_all
@findex ncmpi_put_vars_ulonglong_all
@cindex ncmpi_put_vars_text, example
@cindex ncmpi_put_vars_uchar, example
@cindex ncmpi_put_vars_schar, example
@cindex ncmpi_put_vars_short, example
@cindex ncmpi_put_vars_int, example
@cindex ncmpi_put_vars_float, example
@cindex ncmpi_put_vars_double, example
@cindex ncmpi_put_vars_ushort, example
@cindex ncmpi_put_vars_unit, example
@cindex ncmpi_put_vars_longlong, example
@cindex ncmpi_put_vars_ulonglong, example
@cindex ncmpi_put_vars_text_all, example
@cindex ncmpi_put_vars_uchar_all, example
@cindex ncmpi_put_vars_schar_all, example
@cindex ncmpi_put_vars_short_all, example
@cindex ncmpi_put_vars_int_all, example
@cindex ncmpi_put_vars_float_all, example
@cindex ncmpi_put_vars_double_all, example
@cindex ncmpi_put_vars_ushort_all, example
@cindex ncmpi_put_vars_unit_all, example
@cindex ncmpi_put_vars_longlong_all, example
@cindex ncmpi_put_vars_ulonglong_all, example
@cindex writing subsampled array
@cindex subsampled array, writing

Each member of the family of functions ncmpi_put_vars_@var{<type>} writes a
subsampled (strided) array section of values into a netCDF variable of
an opened netCDF file. The subsampled array section is specified by
giving a corner, a vector of counts, and a stride vector.

@heading Data types
@html
<table cellpadding="4" border="1">
<tr class="spacer" align=center>
    <td> &lt;<b>type  </b>&gt; for API names </td>
    <td> &lt;<b>C type</b>&gt; for API arguments </td>
</tr>
<tr align=center> <td>text     </td> <td>char             </td> </tr>
<tr align=center> <td>schar    </td> <td>signed char      </td> </tr>
<tr align=center> <td>short    </td> <td>short            </td> </tr>
<tr align=center> <td>int      </td> <td>int              </td> </tr>
<tr align=center> <td>float    </td> <td>float            </td> </tr>
<tr align=center> <td>double   </td> <td>double           </td> </tr>
<tr align=center> <td>uchar    </td> <td>unsigned char    </td> </tr>
<tr align=center> <td>ushort   </td> <td>unsigned short   </td> </tr>
<tr align=center> <td>uint     </td> <td>unsigned int     </td> </tr>
<tr align=center> <td>longlong </td> <td>long long        </td> </tr>
<tr align=center> <td>ulonglong</td> <td>unsigned longlong</td> </tr>
</table>
@end html

@heading Operational Mode
These API must be called while the file is in data mode.

@heading Collective I/O
The corresponding collective APIs have the suffix name "_all" and must be called in collective data mode.

@heading Usage
@example
int ncmpi_put_vars_@strong{<type>}     (int                  ncid,
                                int                 varid,
                                const MPI_Offset    start[],
                                const MPI_Offset    count[],
                                const MPI_Offset    stride[],
                                const @strong{<C type>}     *buf);

int ncmpi_put_vars             (int                 ncid,
                                int                 varid,
                                const MPI_Offset    start[],
                                const MPI_Offset    count[],
                                const MPI_Offset    stride[],
                                const void         *buf,
                                MPI_Offset          bufcount,
                                MPI_Datatype        buftype);

int ncmpi_put_vars_@strong{<type>}_all (int                  ncid,
                                int                 varid,
                                const MPI_Offset    start[],
                                const MPI_Offset    count[],
                                const MPI_Offset    stride[],
                                const @strong{<C type>}     *buf);

int ncmpi_put_vars_all         (int                 ncid,
                                int                 varid,
                                const MPI_Offset    start[],
                                const MPI_Offset    count[],
                                const MPI_Offset    stride[],
                                const void         *buf,
                                MPI_Offset          bufcount,
                                MPI_Datatype        buftype);
@end example

@table @code

@item ncid
NetCDF ID, from a previous call to ncmpi_open or ncmpi_create.

@item varid
Variable ID. Different MPI processes may use different variable IDs.

@item start
A vector of MPI_Offset integers specifying the index in the variable
where the first of the data values will be written. The indices are
relative to 0, so for example, the first data value of a variable
would have index (0, 0, ... , 0). The elements of start correspond, in
order, to the variable's dimensions. Hence, if the variable is a
record variable, the first index corresponds to the starting record
number for writing the data values.

@item count
A vector of MPI_Offset integers specifying the number of indices selected
along each dimension. To write a single value, for example, specify
count as (1, 1, ... , 1). The elements of count correspond, in order,
to the variable's dimensions. Hence, if the variable is a record
variable, the first element of count corresponds to a count of the
number of records to write.

@item stride
A vector of MPI_Offset integers that specifies the sampling interval
along each dimension of the netCDF variable. The elements of the
stride vector correspond, in order, to the netCDF variable's
dimensions (stride[0] gives the sampling interval along the most
slowly varying dimension of the netCDF variable). Sampling intervals
are specified in type-independent units of elements (a value of 1
selects consecutive elements of the netCDF variable along the
corresponding dimension, a value of 2 selects every other element,
etc.). A NULL stride argument is treated as (1, 1, ... , 1).

@item buf
Pointer to a block of data values to be written. The order in which the data will be written to the netCDF variable is with the last dimension of the specified variable varying fastest. If the type of data values differs from the netCDF variable type, type conversion will occur.
@c @xref{Type Conversion,,, pnetcdf, The PnetCDF Users Guide}.

@item bufcount
An integer indicates the number of MPI derived data type elements in the buf to be written to the file.

@item buftype
An MPI derived data type that describes the memory layout of buf.
Starting from PnetCDF version 1.6.0, buftype can be MPI_DATATYPE_NULL.
In this case, bufcount is ignored and the buf's data type must match the type
of the variable defined in the file - no data conversion will be done.

@end table

@heading Layout Illustration for Write Buffer in Memory and Data Written in File
@center @image{images/put_vars,,, put_vars mapping, png}

@heading Return Error Codes
ncmpi_put_vars_@var{<type>} returns the value NC_NOERR if no errors
occurred. Otherwise, the returned status indicates an error. Possible
causes of errors include:
@itemize
@item NC_EBADID: Bad ncid.  The specified netCDF ID does not refer to an opened netCDF file.
@item NC_EPERM: Attempt write operations in read-only file.
@item NC_ENOTVAR: The variable ID is invalid for the specified netCDF file.
@item NC_EGLOBAL: NC_GLOBAL is considered invalid for these APIs.
@item NC_EINVALCOORDS: The specified corner indices were out of range for the rank of the specified variable. For example, a negative index, or an index that is larger than the corresponding dimension length will cause an error.
@item NC_EEDGE: The specified edge lengths added to the specified corner would have referenced data out of range for the rank of the specified variable. For example, an edge length that is larger than the corresponding dimension length minus the corner index will cause an error.
@item NC_ERANGE: One or more of the specified values are out of the range of values representable by the external data type of the variable. (Does not apply to the ncmpi_put_vars() and ncmpi_put_vars_all()).
@item NC_EINDEFINE: Operation not allowed in define mode.
@item NC_ECHAR: Attempt to convert numerical values to or from text data.
@item NC_ENOMEM: Out of memory.
@item NC_EBADTYPE: Bad type.
@item NC_EINDEP: Attempt collective I/O operations in independent data mode.
@item NC_ENOTINDEP: Attempt independent I/O operations in collective data mode.
@item NC_EIOMISMATCH: The number of variable elements requested in (bufcount, buftype) mismatches the one calculated from count. This error may only occur for flexible APIs.
@item NC_ENOTSUPPORT: Flexible APIs for NetCDF-4 files is not yet supported.
@end itemize

@heading Example

Here is an example of using ncmpi_put_vars_float_all to write
every other point of a netCDF variable named rh in parallel
which is described by the C declaration float rh[4][6] (note the size
of the dimensions). In this example, we assume there are 4 MPI processes
running. The parallel write fills the entire 4x6 array.

@example
#include <pnetcdf.h>
   ...
#define NDIM 2                    /* rank of netCDF variable */
int ncid;                         /* netCDF ID */
int status;                       /* error status */
int rhid;                         /* variable ID */
MPI_Offset start[NDIM];           /* netCDF variable start point: first element */
MPI_Offset count[NDIM] = @{2, 3@};  /* size of internal array: entire (subsampled) netCDF variable */
MPI_Offset stride[NDIM] = @{2, 2@}; /* variable subsampling intervals: access every other netCDF element */
float rh[2][3];                   /* note subsampled sizes for netCDF variable dimensions */
   ...
status = @ref{ncmpi_open}(MPI_COMM_WORLD, "foo.nc", NC_WRITE, MPI_INFO_NULL,  &ncid);
if (status != NC_NOERR) handle_error(status);
   ...
status = @ref{ncmpi_inq_varid}(ncid, "rh", &rhid);
if (status != NC_NOERR) handle_error(status);
   ...
/* set the starting indices and write lengths for this process */
MPI_Comm_rank(MPI_COMM_WORLD, &rank);
if (rank == 0) @{
    start[0] = 0;
    start[1] = 0;                 /* write locations by process rank IDs:
@} else if (rank == 1) @{              0 1 0 1 0 1
    start[0] = 0;                    2 3 2 3 2 3
    start[1] = 1;                    0 1 0 1 0 1
@} else if (rank == 2) @{              2 3 2 3 2 3
    start[0] = 1;                  */
    start[1] = 0;
@} else if (rank == 3) @{
    start[0] = 1;
    start[1] = 1;
@}
   ...
status = @ref{ncmpi_put_vars_@var{<type>}, ncmpi_put_vars_float_all}(ncid, rhid, start, count, stride, rh);
if (status != NC_NOERR) handle_error(status);
@end example

@node ncmpi_put_varm_@var{<type>}, ncmpi_put_varn_@var{<type>}, ncmpi_put_vars_@var{<type>}, Variables
@section Write a Mapped Array of Values: ncmpi_put_varm_@var{<type>}
@findex ncmpi_put_varm_text
@findex ncmpi_put_varm_uchar
@findex ncmpi_put_varm_schar
@findex ncmpi_put_varm_short
@findex ncmpi_put_varm_int
@findex ncmpi_put_varm_float
@findex ncmpi_put_varm_double
@findex ncmpi_put_varm_ushort
@findex ncmpi_put_varm_unit
@findex ncmpi_put_varm_longlong
@findex ncmpi_put_varm_ulonglong
@findex ncmpi_put_varm_text_all
@findex ncmpi_put_varm_uchar_all
@findex ncmpi_put_varm_schar_all
@findex ncmpi_put_varm_short_all
@findex ncmpi_put_varm_int_all
@findex ncmpi_put_varm_float_all
@findex ncmpi_put_varm_double_all
@findex ncmpi_put_varm_ushort_all
@findex ncmpi_put_varm_unit_all
@findex ncmpi_put_varm_longlong_all
@findex ncmpi_put_varm_ulonglong_all
@cindex ncmpi_put_varm_text, example
@cindex ncmpi_put_varm_uchar, example
@cindex ncmpi_put_varm_schar, example
@cindex ncmpi_put_varm_short, example
@cindex ncmpi_put_varm_int, example
@cindex ncmpi_put_varm_float, example
@cindex ncmpi_put_varm_double, example
@cindex ncmpi_put_varm_ushort, example
@cindex ncmpi_put_varm_unit, example
@cindex ncmpi_put_varm_longlong, example
@cindex ncmpi_put_varm_ulonglong, example
@cindex ncmpi_put_varm_text_all, example
@cindex ncmpi_put_varm_uchar_all, example
@cindex ncmpi_put_varm_schar_all, example
@cindex ncmpi_put_varm_short_all, example
@cindex ncmpi_put_varm_int_all, example
@cindex ncmpi_put_varm_float_all, example
@cindex ncmpi_put_varm_double_all, example
@cindex ncmpi_put_varm_ushort_all, example
@cindex ncmpi_put_varm_unit_all, example
@cindex ncmpi_put_varm_longlong_all, example
@cindex ncmpi_put_varm_ulonglong_all, example
@cindex array, writing mapped
@cindex writing mapped array
@cindex mapped array, writing

The ncmpi_put_varm_@var{<type>} family of functions writes a mapped array
section of values into a netCDF variable of an opened netCDF
file. The mapped array section is specified by giving a corner, a
vector of counts, a stride vector, and an index mapping vector. The
index mapping vector is a vector of integers that specifies the
mapping between the dimensions of a netCDF variable and the in-memory
structure of the internal data array. No assumptions are made about
the ordering or length of the dimensions of the data array.

The most common use case for this API is to write a matrix-transposed array.
See an example below.

@heading Data types
@html
<table cellpadding="4" border="1">
<tr class="spacer" align=center>
    <td> &lt;<b>type  </b>&gt; for API names </td>
    <td> &lt;<b>C type</b>&gt; for API arguments </td>
</tr>
<tr align=center> <td>text     </td> <td>char             </td> </tr>
<tr align=center> <td>schar    </td> <td>signed char      </td> </tr>
<tr align=center> <td>short    </td> <td>short            </td> </tr>
<tr align=center> <td>int      </td> <td>int              </td> </tr>
<tr align=center> <td>float    </td> <td>float            </td> </tr>
<tr align=center> <td>double   </td> <td>double           </td> </tr>
<tr align=center> <td>uchar    </td> <td>unsigned char    </td> </tr>
<tr align=center> <td>ushort   </td> <td>unsigned short   </td> </tr>
<tr align=center> <td>uint     </td> <td>unsigned int     </td> </tr>
<tr align=center> <td>longlong </td> <td>long long        </td> </tr>
<tr align=center> <td>ulonglong</td> <td>unsigned longlong</td> </tr>
</table>
@end html

@heading Operational Mode
These API must be called while the file is in data mode.

@heading Collective I/O
The corresponding collective APIs have the suffix name "_all" and must be called in collective data mode.

@heading Usage
@example
int ncmpi_put_varm_@strong{<type>}     (int                  ncid,
                                int                 varid,
                                const MPI_Offset    start[],
                                const MPI_Offset    count[],
                                const MPI_Offset    stride[],
                                const MPI_Offset    imap[],
                                const @strong{<C type>}     *buf);

int ncmpi_put_varm             (int                 ncid,
                                int                 varid,
                                const MPI_Offset    start[],
                                const MPI_Offset    count[],
                                const MPI_Offset    stride[],
                                const MPI_Offset    imap[],
                                const void         *buf,
                                MPI_Offset          bufcount,
                                MPI_Datatype        buftype);

int ncmpi_put_varm_@strong{<type>}_all (int                  ncid,
                                int                 varid,
                                const MPI_Offset    start[],
                                const MPI_Offset    count[],
                                const MPI_Offset    stride[],
                                const MPI_Offset    imap[],
                                const @strong{<C type>}     *buf);

int ncmpi_put_varm_all         (int                 ncid,
                                int                 varid,
                                const MPI_Offset    start[],
                                const MPI_Offset    count[],
                                const MPI_Offset    stride[],
                                const MPI_Offset    imap[],
                                const void         *buf,
                                MPI_Offset          bufcount,
                                MPI_Datatype        buftype);
@end example

@table @code

@item ncid
NetCDF ID, from a previous call to ncmpi_open or ncmpi_create.

@item varid
Variable ID. Different MPI processes may use different variable IDs.

@item start
A vector of MPI_Offset integers specifying the index in the variable
where the first of the data values will be written. The indices are
relative to 0, so for example, the first data value of a variable
would have index (0, 0, ... , 0). The elements of start correspond, in
order, to the variable's dimensions. Hence, if the variable is a
record variable, the first index corresponds to the starting record
number for writing the data values.

@item count
A vector of MPI_Offset integers specifying the number of indices selected
along each dimension. To write a single value, for example, specify
count as (1, 1, ... , 1). The elements of count correspond, in order,
to the variable's dimensions. Hence, if the variable is a record
variable, the first element of count corresponds to a count of the
number of records to write.

@item stride
A vector of MPI_Offset integers that specifies the sampling interval
along each dimension of the netCDF variable. The elements of the
stride vector correspond, in order, to the netCDF variable's
dimensions (stride[0] gives the sampling interval along the most
slowly varying dimension of the netCDF variable). Sampling intervals
are specified in type-independent units of elements (a value of 1
selects consecutive elements of the netCDF variable along the
corresponding dimension, a value of 2 selects every other element,
etc.). A NULL stride argument is treated as (1, 1, ... , 1).

@item imap
A vector of MPI_Offset integers that specifies the mapping between the
dimensions of a netCDF variable and the in-memory structure of the
internal data array. The elements of the index mapping vector
correspond, in order, to the netCDF variable's dimensions (imap[0]
gives the distance between elements of the internal array
corresponding to the most slowly varying dimension of the netCDF
variable). Distances between elements are specified in
type-independent units of elements (the distance between internal
elements that occupy adjacent memory locations is 1 and not the
element's byte-length as in netCDF 2). A NULL argument means the
memory-resident values have the same structure as the associated
netCDF variable.

@item buf
Pointer to the location used for computing where the data values will
be found; the data should be of the type appropriate for the function
called. If the type of data values differs from the netCDF variable
type, type conversion will occur.
@c @xref{Type Conversion,,, pnetcdf, The PnetCDF Users Guide}.

@item bufcount
An integer indicates the number of MPI derived data type elements in the buf to be written to the file.

@item buftype
An MPI derived data type that describes the memory layout of buf.
Starting from PnetCDF version 1.6.0, buftype can be MPI_DATATYPE_NULL.
In this case, bufcount is ignored and the buf's data type must match the type
of the variable defined in the file - no data conversion will be done.

@end table

@heading Layout Illustration for Write Buffer in Memory and Data Written in File
@center @image{images/put_varm,,, put_varm mapping, png}

@heading Return Error Codes
ncmpi_put_varm_@var{<type>} returns the value NC_NOERR if no errors
occurred. Otherwise, the returned status indicates an error. Possible
causes of errors include:
@itemize
@item NC_EBADID: Bad ncid.  The specified netCDF ID does not refer to an opened netCDF file.
@item NC_EPERM: Attempt write operations in read-only file.
@item NC_ENOTVAR: The variable ID is invalid for the specified netCDF file.
@item NC_EGLOBAL: NC_GLOBAL is considered invalid for these APIs.
@item NC_EINVALCOORDS: The specified corner indices were out of range for the rank of the specified variable. For example, a negative index, or an index that is larger than the corresponding dimension length will cause an error.
@item NC_EEDGE: The specified edge lengths added to the specified corner would have referenced data out of range for the rank of the specified variable. For example, an edge length that is larger than the corresponding dimension length minus the corner index will cause an error.
@item NC_ERANGE: One or more of the specified values are out of the range of values representable by the external data type of the variable. (Does not apply to the ncmpi_put_vars() and ncmpi_put_vars_all()).
@item NC_EINDEFINE: Operation not allowed in define mode.
@item NC_ECHAR: Attempt to convert numerical values to or from text data.
@item NC_ENOMEM: Out of memory.
@item NC_EINDEP: Attempt collective I/O operations in independent data mode.
@item NC_ENOTINDEP: Attempt independent I/O operations in collective data mode.
@item NC_EIOMISMATCH: The number of variable elements requested in (bufcount, buftype) mismatches the one calculated from count. This error may only occur for flexible APIs.
@item NC_ENOTSUPPORT: Flexible APIs for NetCDF-4 files is not yet supported.
@end itemize

@heading Example

The following imap vector maps in the trivial way a 4x3x2 netCDF
variable and an internal array of the same shape:

@example
float a[4][3][2];       /* same shape as netCDF variable */
int   imap[3] = @{6, 2, 1@};
                        /* netCDF dimension       inter-element distance */
                        /* ----------------       ---------------------- */
                        /* most rapidly varying       1                  */
                        /* intermediate               2 (=imap[2]*2)     */
                        /* most slowly varying        6 (=imap[1]*3)     */
@end example

Using the imap vector above with ncmpi_put_varm_float_all obtains the same
result as simply using ncmpi_put_var_float.

Here is an example of using ncmpi_put_varm_float_all to write -- from a
transposed, internal array -- a netCDF variable named rh which is
described by the C declaration float rh[6][4] (note the size and order
of the dimensions):

@example
#include <pnetcdf.h>
   ...
#define NDIM 2                    /* rank of netCDF variable */
int ncid;                         /* netCDF ID */
int status;                       /* error status */
int rhid;                         /* variable ID */
MPI_Offset start[NDIM] = @{0, 0@};  /* netCDF variable start point: first element */
MPI_Offset count[NDIM] = @{6, 4@};  /* size of internal array: entire netCDF variable; order corresponds to netCDF variable -- not internal array */
MPI_Offset stride[NDIM] = @{1, 1@}; /* variable subsampling intervals: sample every netCDF element */
MPI_Offset imap[NDIM] = @{1, 6@};   /* internal array inter-element distances; would be @{4, 1@} if not transposing */
float buf[4][6];                  /* note transposition of netCDF variable dimensions */
   ...
status = @ref{ncmpi_open}(MPI_COMM_WORLD, "foo.nc", NC_WRITE, MPI_INFO_NULL,  &ncid);
if (status != NC_NOERR) handle_error(status);
   ...
status = @ref{ncmpi_inq_varid}(ncid, "rh", &rhid);
if (status != NC_NOERR) handle_error(status);
   ...
status = @ref{ncmpi_put_varm_@var{<type>}, ncmpi_put_varm_float_all}(ncid, rhid, start, count, stride, imap, buf);
if (status != NC_NOERR) handle_error(status);

   In memory:                   In file:
     buf is a memory buffer       rh is a netCDF variable

     buf[4][6] = a b c d e f      rh[6][4] =  a g m s
                 g h i j k l                  b h n t
                 m n o p q r                  c i o u
                 s t u v w x                  d j p v
                                              e k q w
                                              f l r x
@end example

Here is another example of using ncmpi_put_varm_float_all to write -- from a
transposed, internal array -- a subsample of the same netCDF variable,
by writing every other point of the netCDF variable:

@example
#include <pnetcdf.h>
   ...
#define NDIM 2                    /* rank of netCDF variable */
int ncid;                         /* netCDF ID */
int status;                       /* error status */
int rhid;                         /* variable ID */
MPI_Offset start[NDIM] = @{0, 0@};  /* netCDF variable start point: first element */
MPI_Offset count[NDIM] = @{3, 2@};  /* size of internal array: entire (subsampled) netCDF variable; order of dimensions corresponds to netCDF variable -- not internal array */
MPI_Offset stride[NDIM] = @{2, 2@}; /* variable subsampling intervals: sample every other netCDF element */
MPI_Offset imap[NDIM] = @{1, 3@};   /* internal array inter-element distances; would be @{2, 1@} if not transposing */
float buf[2][3];                  /* note transposition of (subsampled) netCDF variable dimensions */
   ...
status = @ref{ncmpi_open}(MPI_COMM_WORLD, "foo.nc", NC_WRITE, MPI_INFO_NULL,  &ncid);
if (status != NC_NOERR) handle_error(status);
   ...
status = @ref{ncmpi_inq_varid}(ncid, "rh", &rhid);
if (status != NC_NOERR) handle_error(status);
   ...
status = @ref{ncmpi_put_varm_@var{<type>}, ncmpi_put_varm_float_all}(ncid, rhid, start, count, stride, imap, buf);
if (status != NC_NOERR) handle_error(status);

   In memory:                   In file:
     buf is a memory buffer       rh is a netCDF variable

     buf[2][3] = a b c            rh[6][4] =  a _ d _
                 d e f                        _ _ _ _
                                              b _ e _
                                              _ _ _ _
                                              c _ f _
                                              _ _ _ _
@end example

@heading Full example C program
@itemize
@item
@url{https://github.com/Parallel-NetCDF/PnetCDF/tree/master/examples/C/transpose.c, transpose.c}
@item
@url{https://github.com/Parallel-NetCDF/PnetCDF/tree/master/examples/C/ghost_cell.c, ghost_cell.c}
@item
The above programs are available in all PnetCDF releases under directory examples/C.
@end itemize

@node ncmpi_put_varn_@var{<type>}, ncmpi_put_vard, ncmpi_put_varm_@var{<type>}, Variables
@section Write a List Subarrays to The Same Variable: ncmpi_put_varn_@var{<type>}
@findex ncmpi_put_varn_text
@findex ncmpi_put_varn_uchar
@findex ncmpi_put_varn_schar
@findex ncmpi_put_varn_short
@findex ncmpi_put_varn_int
@findex ncmpi_put_varn_float
@findex ncmpi_put_varn_double
@findex ncmpi_put_varn_ushort
@findex ncmpi_put_varn_unit
@findex ncmpi_put_varn_longlong
@findex ncmpi_put_varn_ulonglong
@findex ncmpi_put_varn_text_all
@findex ncmpi_put_varn_uchar_all
@findex ncmpi_put_varn_schar_all
@findex ncmpi_put_varn_short_all
@findex ncmpi_put_varn_int_all
@findex ncmpi_put_varn_float_all
@findex ncmpi_put_varn_double_all
@findex ncmpi_put_varn_ushort_all
@findex ncmpi_put_varn_unit_all
@findex ncmpi_put_varn_longlong_all
@findex ncmpi_put_varn_ulonglong_all
@cindex ncmpi_put_varn_text, example
@cindex ncmpi_put_varn_uchar, example
@cindex ncmpi_put_varn_schar, example
@cindex ncmpi_put_varn_short, example
@cindex ncmpi_put_varn_int, example
@cindex ncmpi_put_varn_float, example
@cindex ncmpi_put_varn_double, example
@cindex ncmpi_put_varn_ushort, example
@cindex ncmpi_put_varn_unit, example
@cindex ncmpi_put_varn_longlong, example
@cindex ncmpi_put_varn_ulonglong, example
@cindex ncmpi_put_varn_text_all, example
@cindex ncmpi_put_varn_uchar_all, example
@cindex ncmpi_put_varn_schar_all, example
@cindex ncmpi_put_varn_short_all, example
@cindex ncmpi_put_varn_int_all, example
@cindex ncmpi_put_varn_float_all, example
@cindex ncmpi_put_varn_double_all, example
@cindex ncmpi_put_varn_ushort_all, example
@cindex ncmpi_put_varn_unit_all, example
@cindex ncmpi_put_varn_longlong_all, example
@cindex ncmpi_put_varn_ulonglong_all, example
@cindex subarrays, writing list
@cindex writing list subarrays
@cindex list subarrays, writing

The ncmpi_put_varn_@var{<type>} family of functions writes a list of subarrays
into a netCDF variable of an opened netCDF file. The part of the netCDF
variable to write is specified by giving a list of subarrays and each subarray
is specified by a corner and a vector of edge lengths that refer to an array
section of the netCDF variable. For each subarray, the values to be written are
associated with the netCDF variable by assuming that the last dimension of the
netCDF variable varies fastest in the C interface.

This API essentially has the same effect of making multiple calls to ncmpi_put_vara_@var{<type>} with the same variable ID.

@heading Data types
@html
<table cellpadding="4" border="1">
<tr class="spacer" align=center>
    <td> &lt;<b>type  </b>&gt; for API names </td>
    <td> &lt;<b>C type</b>&gt; for API arguments </td>
</tr>
<tr align=center> <td>text     </td> <td>char             </td> </tr>
<tr align=center> <td>schar    </td> <td>signed char      </td> </tr>
<tr align=center> <td>short    </td> <td>short            </td> </tr>
<tr align=center> <td>int      </td> <td>int              </td> </tr>
<tr align=center> <td>float    </td> <td>float            </td> </tr>
<tr align=center> <td>double   </td> <td>double           </td> </tr>
<tr align=center> <td>uchar    </td> <td>unsigned char    </td> </tr>
<tr align=center> <td>ushort   </td> <td>unsigned short   </td> </tr>
<tr align=center> <td>uint     </td> <td>unsigned int     </td> </tr>
<tr align=center> <td>longlong </td> <td>long long        </td> </tr>
<tr align=center> <td>ulonglong</td> <td>unsigned longlong</td> </tr>
</table>
@end html

@heading Operational Mode
These API must be called while the file is in data mode.

@heading Collective I/O
The corresponding collective APIs have the suffix name "_all" and must be called in collective data mode.

@heading Usage
@example
int ncmpi_put_varn_@strong{<type>}     (int                ncid,
                               int                varid,
                               int                num,
                               MPI_Offset* const *starts, /* [num][ndims] */
                               MPI_Offset* const *counts, /* [num][ndims] */
                               const @strong{<C type>}    *buf);

int ncmpi_put_varn            (int                ncid,
                               int                varid,
                               int                num,
                               MPI_Offset* const *starts, /* [num][ndims] */
                               MPI_Offset* const *counts, /* [num][ndims] */
                               const void        *buf,
                               MPI_Offset         bufcount,
                               MPI_Datatype       buftype);

int ncmpi_put_varn_@strong{<type>}_all (int                ncid,
                               int                varid,
                               int                num,
                               MPI_Offset* const *starts, /* [num][ndims] */
                               MPI_Offset* const *counts, /* [num][ndims] */
                               const @strong{<C type>}    *buf);

int ncmpi_put_varn_all        (int                ncid,
                               int                varid,
                               int                num,
                               MPI_Offset* const *starts, /* [num][ndims] */
                               MPI_Offset* const *counts, /* [num][ndims] */
                               const void        *buf,
                               MPI_Offset         bufcount,
                               MPI_Datatype       buftype);
@end example

@table @code

@item ncid
NetCDF ID, from a previous call to ncmpi_open or ncmpi_create.

@item varid
Variable ID. Different MPI processes may use different variable IDs.

@item num
Nnumber of subarray requests.

@item starts
A double pointer that mimics a 2D array of size [num][ndims].
See below for example of how to allocate space and construct such a 2D array.
Each starts[i] is a vector specifying the index in the variable where the first of the data values will be written.
The indices are relative to 0, so for example, the first data value of a variable would have index (0, 0, ... , 0).
The size of starts must be [num][ndims], where ndims is the number of dimensions of the specified variable.
The elements of each starts[i] must correspond to the variable's dimensions in order.
Hence, if the variable is a record variable, the first index of each starts[i] would correspond to the starting record number for writing the data values.

@item counts
A double pointer that mimics a 2D array of size [num][ndims].
See below for example of how to allocate space and construct such a 2D array.
Each counts[i] is a vector specifying the edge lengths along each dimension of the block of data values to be written.
To write a single value, for example, specify count as (1, 1, ... , 1).
The size of counts should be [num][ndims], where ndims is the number of dimensions of the specified variable.
The elements of count correspond to the variable's dimensions.
Hence, if the variable is a record variable, the first element of each counts[i] corresponds to a count of the number of records to write.
This argument can be NULL, in which case it is equivalent to providing counts[*][*]=(1, 1, ... , 1).

@item buf
A pointer to the memory address that contains the data values to be written. If the type of data values differs from the netCDF variable type, type conversion will occur.
@c @xref{Type Conversion,,, pnetcdf, The PnetCDF Users Guide}.

@item bufcount
An integer indicates the number of MPI derived data type elements in the buffer pointed by buf to be written to the file.

@item buftype
An MPI derived data type that describes the memory layout of buf.
Starting from PnetCDF version 1.6.0, buftype can be MPI_DATATYPE_NULL.
In this case, bufcount is ignored and the buf's data type must match the type
of the variable defined in the file - no data conversion will be done.

@end table

@heading Layout Illustration for Write Buffer in Memory and Data Written in File
@center @image{images/put_varn,,, put_varn mapping, png}

@heading Return Error Codes
ncmpi_put_varn_@var{<type>} returns the value NC_NOERR if no errors
occurred. Otherwise, the returned status indicates an error. Possible
causes of errors include:
@itemize
@item NC_EBADID: Bad ncid.  The specified netCDF ID does not refer to an opened netCDF file.
@item NC_EPERM: Attempt write operations in read-only file.
@item NC_ENOTVAR: The variable ID is invalid for the specified netCDF file.
@item NC_EGLOBAL: NC_GLOBAL is considered invalid for these APIs.
@item NC_EINVALCOORDS: The specified corner indices were out of range for the rank of the specified variable. For example, a negative index, or an index that is larger than the corresponding dimension length will cause an error.
@item NC_EEDGE: The specified edge lengths added to the specified corner would have referenced data out of range for the rank of the specified variable. For example, an edge length that is larger than the corresponding dimension length minus the corner index will cause an error.
@item NC_ERANGE: One or more of the specified values are out of the range of values representable by the external data type of the variable. (Does not apply to the ncmpi_put_vars() and ncmpi_put_vars_all()).
@item NC_EINDEFINE: Operation not allowed in define mode.
@item NC_ECHAR: Attempt to convert numerical values to or from text data.
@item NC_ENOMEM: Out of memory.
@item NC_ENULLSTART: It is illegal for argument starts being a NULL.
@item NC_EINDEP: Attempt collective I/O operations in independent data mode.
@item NC_ENOTINDEP: Attempt independent I/O operations in collective data mode.
@item NC_EIOMISMATCH: The number of variable elements requested in (bufcount, buftype) mismatches the one calculated from counts. This error may only occur for flexible APIs.
@item NC_ENOTSUPPORT: This API for NetCDF-4 files is not yet supported.
@end itemize

@heading Example

This example shows how to use a single call of ncmpi_put_varn_float_all()
to write a sequence of requests with arbitrary array indices.

@example
#include <pnetcdf.h>
    ...
#define MAX_NUM_REQS 6
#define NDIMS        2

int  i, j;
int  rank;                         /* MPI process rank ID */
int  err;                          /* error status */
int  ncid;                         /* netCDF ID */
int  varid;                        /* variable ID */
int  num_reqs;                     /* number of subarray requests */
int  dimid[2];                     /* dimension IDs */
int  buf_len;                      /* number of elements in buffer */
float *buffer;                     /* write buffer to hold values */
MPI_Offset **starts, **counts;
    ...
MPI_Comm_rank(MPI_COMM_WORLD, &rank);

err = @ref{ncmpi_create}(MPI_COMM_WORLD, "foo.nc", NC_CLOBBER, MPI_INFO_NULL, &ncid);

if (err != NC_NOERR) handle_error(err);

err = @ref{ncmpi_def_dim}(ncid, "Y", 4,  &dimid[0]);
err = @ref{ncmpi_def_dim}(ncid, "X", 10, &dimid[1]);
err = @ref{ncmpi_def_var}(ncid, "var", NC_FLOAT, NDIMS, dimid, &varid);
err = @ref{ncmpi_enddef}(ncid);

/* allocate starts and counts */
starts    = (MPI_Offset**) malloc(MAX_NUM_REQS*       sizeof(MPI_Offset*));
starts[0] = (MPI_Offset*)  calloc(MAX_NUM_REQS*NDIMS, sizeof(MPI_Offset));
for (i=1; i<MAX_NUM_REQS; i++)
    starts[i] = starts[i-1] + NDIMS;

counts    = (MPI_Offset**) malloc(MAX_NUM_REQS*       sizeof(MPI_Offset*));
counts[0] = (MPI_Offset*)  calloc(MAX_NUM_REQS*NDIMS, sizeof(MPI_Offset));
for (i=1; i<MAX_NUM_REQS; i++)
    counts[i] = counts[i-1] + NDIMS;

if (rank == 0) @{
    num_reqs = 4;
    starts[0][0] = 0; starts[0][1] = 5; counts[0][0] = 1; counts[0][1] = 2;
    starts[1][0] = 1; starts[1][1] = 0; counts[1][0] = 1; counts[1][1] = 1;
    starts[2][0] = 2; starts[2][1] = 6; counts[2][0] = 1; counts[2][1] = 2;
    starts[3][0] = 3; starts[3][1] = 0; counts[3][0] = 1; counts[3][1] = 3;
    /* rank 0 is writing the following locations: ("-" means skip)
              -  -  -  -  -  0  0  -  -  -
              0  -  -  -  -  -  -  -  -  -
              -  -  -  -  -  -  0  0  -  -
              0  0  0  -  -  -  -  -  -  -
     */
@} else if (rank == 1) @{
    num_reqs = 6;
    starts[0][0] = 0; starts[0][1] = 3; counts[0][0] = 1; counts[0][1] = 2;
    starts[1][0] = 0; starts[1][1] = 8; counts[1][0] = 1; counts[1][1] = 2;
    starts[2][0] = 1; starts[2][1] = 5; counts[2][0] = 1; counts[2][1] = 2;
    starts[3][0] = 2; starts[3][1] = 0; counts[3][0] = 1; counts[3][1] = 2;
    starts[4][0] = 2; starts[4][1] = 8; counts[4][0] = 1; counts[4][1] = 2;
    starts[5][0] = 3; starts[5][1] = 4; counts[5][0] = 1; counts[5][1] = 3;
    /* rank 1 is writing the following locations: ("-" means skip)
              -  -  -  1  1  -  -  -  1  1
              -  -  -  -  -  1  1  -  -  -
              1  1  -  -  -  -  -  -  1  1
              -  -  -  -  1  1  1  -  -  -
     */
@} else if (rank == 2) @{
    num_reqs = 5;
    starts[0][0] = 0; starts[0][1] = 7; counts[0][0] = 1; counts[0][1] = 1;
    starts[1][0] = 1; starts[1][1] = 1; counts[1][0] = 1; counts[1][1] = 3;
    starts[2][0] = 1; starts[2][1] = 7; counts[2][0] = 1; counts[2][1] = 3;
    starts[3][0] = 2; starts[3][1] = 2; counts[3][0] = 1; counts[3][1] = 1;
    starts[4][0] = 3; starts[4][1] = 3; counts[4][0] = 1; counts[4][1] = 1;
    /* rank 2 is writing the following locations: ("-" means skip)
              -  -  -  -  -  -  -  2  -  -
              -  2  2  2  -  -  -  2  2  2
              -  -  2  -  -  -  -  -  -  -
              -  -  -  2  -  -  -  -  -  -
     */
@} else if (rank == 3) @{
    num_reqs = 4;
    starts[0][0] = 0; starts[0][1] = 0; counts[0][0] = 1; counts[0][1] = 3;
    starts[1][0] = 1; starts[1][1] = 4; counts[1][0] = 1; counts[1][1] = 1;
    starts[2][0] = 2; starts[2][1] = 3; counts[2][0] = 1; counts[2][1] = 3;
    starts[3][0] = 3; starts[3][1] = 7; counts[3][0] = 1; counts[3][1] = 3;
    /* rank 3 is writing the following locations: ("-" means skip)
              3  3  3  -  -  -  -  -  -  -
              -  -  -  -  3  -  -  -  -  -
              -  -  -  3  3  3  -  -  -  -
              -  -  -  -  -  -  -  3  3  3
     */
@} else @{
    num_reqs = 0;
@}

/* allocate write buffer */
buf_len = 0;
for (i=0; i<num_reqs; i++) @{
    MPI_Offset w_req_len=1;
    for (j=0; j<NDIMS; j++)
        w_req_len *= counts[i][j];
    buf_len += w_req_len;
@}
buffer = (float*) malloc(buf_len * sizeof(float));
for (i=0; i<buf_len; i++) buffer[i] = (float)rank;

/* write values into netCDF variable */
err = @ref{ncmpi_put_varn_@var{<type>}, ncmpi_put_varn_float_all}(ncid, varid, num_reqs, starts, counts, buffer);
if (err != NC_NOERR) handle_error(err);
    ...

err = @ref{ncmpi_close}(ncid);
if (err != NC_NOERR) handle_error(err);

/*    % ncmpidump foo.nc
 *    netcdf foo @{
 *    dimensions:
 *             Y = 4 ;
 *             X = 10 ;
 *    variables:
 *             float var(Y, X) ;
 *    data:
 *
 *     var =
 *       3, 3, 3, 1, 1, 0, 0, 2, 1, 1,
 *       0, 2, 2, 2, 3, 1, 1, 2, 2, 2,
 *       1, 1, 2, 3, 3, 3, 0, 0, 1, 1,
 *       0, 0, 0, 2, 1, 1, 1, 3, 3, 3 ;
 *    @}
 */
@end example

@heading Full example C program
@itemize
@item
@url{https://github.com/Parallel-NetCDF/PnetCDF/tree/master/examples/C/put_varn_int.c, put_varn_int.c}
@item
@url{https://github.com/Parallel-NetCDF/PnetCDF/tree/master/examples/C/put_varn_float.c, put_varn_float.c}
@item
The above programs are available in all PnetCDF releases under directory examples/C.
@end itemize


@node ncmpi_put_vard, ncmpi_get_var1_@var{<type>}, ncmpi_put_varn_@var{<type>}, Variables
@section Write an Array of Values using filetype: ncmpi_put_vard
@findex ncmpi_put_vard
@findex ncmpi_put_vard_all
@cindex ncmpi_put_vard, example
@cindex ncmpi_put_vard_all, example
@cindex writing array section
@cindex array section, writing

The function ncmpi_put_vard writes values into a netCDF variable of
an opened netCDF file. The part of the netCDF variable to write is
specified by an MPI derived data type whose flattened displacements are
relative to the beginning file offset of the variable.

@heading Operational Mode
These API must be called while the file is in data mode.

@heading Collective I/O
The corresponding collective APIs have the suffix name "_all" and must be called in collective data mode.

@heading Usage
@example
int ncmpi_put_vard     (int           ncid,
                        int           varid,
                        MPI_Datatype  filetype,
                        const void   *buf,
                        MPI_Offset    bufcount,
                        MPI_Datatype  buftype);

int ncmpi_put_vard_all (int           ncid,
                        int           varid,
                        MPI_Datatype  filetype,
                        const void   *buf,
                        MPI_Offset    bufcount,
                        MPI_Datatype  buftype);
@end example

@table @code

@item ncid
NetCDF ID, from a previous call to ncmpi_open or ncmpi_create.

@item varid
Variable ID.
Starting from version 1.10.0, filetype argument may cover more than one
variable. In this case, varid is the ID of the first variable.  However,
variables accessed by filetype must be either all fixed-size variables or all
record variables. In addition, the variables accessed by filetype must be of
the same external NC data type. Thie limitation allows the same data type
conversion to perform on the entire write buffer. When calling the collevtive
ncmpi_put_vard_all(), different MPI processes may use different variable IDs,
ncid.

@item filetype
An MPI derived data type that describes the file access layout. The element
datatype that is used to construct filetype must conformed with the external NC
data type of the variable defined in the file, i.e. MPI_FLOAT being used to
construct filetype vs. NC_FLOAT being the NC data type of the variable(s).
Starting from version 1.10.0, filetype may cover more than one variable. In
this case, all variables accessed by the filetype must be of the same NC data
type.
@comment For fixed-size variables, the size of filetype must be smaller or equal to the variable size. PnetCDF checks the lower and upper bounds of filetype and throws error NC_ETYPESIZE if extent of filetype goes beyond of the variable's boundary.
For record variables, accessing more than one record is possible. One might
need the size of record block (i.e. the sum of single records of all record
variables defined in the file) which can be obtained from a call to
@ref{ncmpi_inq Family, ncmpi_inq_recsize}.
@comment Note PnetCDF does not check the access extent for record variables. Users should use a filetype whose extent is within the record boundaries of the variable.
In addition, filetype must meet the following MPI-IO requirement specified in
MPI standard Chapter 13.3.
File displacements of filetype must be non-negative and in a monotonically
nondecreasing order. If the file is opened for writing, filetype is not
permitted to contain overlapping regions.
It is fine for filetype to be MPI_DATATYPE_NULL, which indicates a zero-length
write request.
For independent APIs, a zero-length request is returned immediately.
For collective APIs, the process with a zero-length request will still proceed
to participate the collective MPI operations inside the PnetCDF library.

@item buf
Pointer to the write buffer.

@item bufcount
An integer indicates the number of MPI derived data type elements in the buf to
be written to the file. This argument is ignored if buftype is MPI_DATATYPE_NULL.

@item buftype
An MPI derived data type that describes the memory layout of buf.
There can only be a single element data type contained in buftype.
It is fine for buftype to be MPI_DATATYPE_NULL, which indicates the write
buffer is contiguous and its amount is equal to the size of filetype.
In this case, argument bufcount is ignored and users must ensure the
memory space pointed by argument buf is at least of size of filetype.

@end table

@heading Return Error Codes
ncmpi_put_vard returns the value NC_NOERR if no errors
occurred. Otherwise, the returned status indicates an error. Possible
causes of errors include:
@itemize
@item NC_EBADID: Bad ncid.  The specified netCDF ID does not refer to an opened netCDF file.
@item NC_EPERM: Attempt write operations in read-only file.
@item NC_EINDEP: Attempt collective I/O operations in independent data mode.
@item NC_ENOTINDEP: Attempt independent I/O operations in collective data mode.
@item NC_EINDEFINE: Operation not allowed in define mode.
@item NC_ENOTVAR: Bad varid, variable not found.
@item NC_EGLOBAL: NC_GLOBAL is considered invalid for these APIs.
@comment @item NC_ETYPESIZE: for non-record variables, filetype's extent is beyond the variable's boundaries.
@item NC_EMULTITYPES: Multiple different MPI element datatypes used in filetype or buftype.
@item NC_ETYPE_MISMATCH: filetype's element type mismatches the variable's NC data type.
@item NC_EIOMISMATCH: the number of element data types in filetype mismatches the one in buftype * bufcount.
@item NC_ENOTSUPPORT: This API for NetCDF-4 files is not yet supported.
@end itemize

@heading Example

Here is an example using ncmpi_put_vard.

@example
#include <pnetcdf.h>
   ...
#define NY 2
#define NX 5

MPI_Offset start[2], count[2];
int array_of_sizes[2], array_of_subsizes[2], array_of_starts[2];
int buf[NY][NX];
MPI_Datatype filetype;
    ...

MPI_Comm_size(MPI_COMM_WORLD, &nprocs);
MPI_Comm_rank(MPI_COMM_WORLD, &rank);

/* create an MPI derived data type */
array_of_sizes[0]    = 2;
array_of_sizes[1]    = NX*nprocs;
array_of_subsizes[0] = 2;
array_of_subsizes[1] = NX;
array_of_starts[0]   = 0;
array_of_starts[1]   = NX*rank;
MPI_Type_create_subarray(2, array_of_sizes, array_of_subsizes,
                         array_of_starts, MPI_ORDER_C,
                         MPI_INT, &filetype);
MPI_Type_commit(&filetype);

err = @ref{ncmpi_put_vard, ncmpi_put_vard_all}(ncid, varid, filetype, buf, 2*NX, MPI_INT);

@end example

@heading Full example C program
@itemize
@item
@url{https://github.com/Parallel-NetCDF/PnetCDF/tree/master/examples/C/vard_int.c, vard_int.c}
@item
@url{https://github.com/Parallel-NetCDF/PnetCDF/tree/master/examples/C/vard_mvars.c, vard_mvars.c}
@item
The above programs are available in all PnetCDF releases under directory examples/C.
@end itemize

@node ncmpi_get_var1_@var{<type>}, ncmpi_get_var_@var{<type>}, ncmpi_put_vard, Variables
@section Read a Single Data Value: ncmpi_get_var1_@var{<type>}
@findex ncmpi_get_var1_text
@findex ncmpi_get_var1_uchar
@findex ncmpi_get_var1_schar
@findex ncmpi_get_var1_short
@findex ncmpi_get_var1_int
@findex ncmpi_get_var1_float
@findex ncmpi_get_var1_double
@findex ncmpi_get_var1_ushort
@findex ncmpi_get_var1_unit
@findex ncmpi_get_var1_longlong
@findex ncmpi_get_var1_ulonglong
@cindex ncmpi_get_var1_text, example
@cindex ncmpi_get_var1_uchar, example
@cindex ncmpi_get_var1_schar, example
@cindex ncmpi_get_var1_short, example
@cindex ncmpi_get_var1_int, example
@cindex ncmpi_get_var1_float, example
@cindex ncmpi_get_var1_double, example
@cindex ncmpi_get_var1_ushort, example
@cindex ncmpi_get_var1_unit, example
@cindex ncmpi_get_var1_longlong, example
@cindex ncmpi_get_var1_ulonglong, example
@cindex reading single value
@cindex single value, reading

The functions ncmpi_get_var1_@var{<type>} get a single data value from a
variable of an opened netCDF file that is in data mode. Inputs are
the netCDF ID, the variable ID, a multidimensional index that
specifies which value to get, and the address of a location into which
the data value will be read. The value is converted from the external
data type of the variable, if necessary.

@heading Data types
@html
<table cellpadding="4" border="1">
<tr class="spacer" align=center>
    <td> &lt;<b>type  </b>&gt; for API names </td>
    <td> &lt;<b>C type</b>&gt; for API arguments </td>
</tr>
<tr align=center> <td>text     </td> <td>char             </td> </tr>
<tr align=center> <td>schar    </td> <td>signed char      </td> </tr>
<tr align=center> <td>short    </td> <td>short            </td> </tr>
<tr align=center> <td>int      </td> <td>int              </td> </tr>
<tr align=center> <td>float    </td> <td>float            </td> </tr>
<tr align=center> <td>double   </td> <td>double           </td> </tr>
<tr align=center> <td>uchar    </td> <td>unsigned char    </td> </tr>
<tr align=center> <td>ushort   </td> <td>unsigned short   </td> </tr>
<tr align=center> <td>uint     </td> <td>unsigned int     </td> </tr>
<tr align=center> <td>longlong </td> <td>long long        </td> </tr>
<tr align=center> <td>ulonglong</td> <td>unsigned longlong</td> </tr>
</table>
@end html

@heading Operational Mode
These API must be called while the file is in data mode.

@heading Collective I/O
The corresponding collective APIs have the suffix name "_all" and must be called in collective data mode.

@heading Usage
@example
int ncmpi_get_var1_@strong{<type>}     (int                  ncid,
                                int                 varid,
                                const MPI_Offset    index[],
                                @strong{<C type>}           *buf);

int ncmpi_get_var1             (int                 ncid,
                                int                 varid,
                                const MPI_Offset    index[],
                                void               *buf,
                                MPI_Offset          bufcount,
                                MPI_Datatype        buftype);

int ncmpi_get_var1_@strong{<type>}_all (int                  ncid,
                                int                 varid,
                                const MPI_Offset    index[],
                                @strong{<C type>}           *buf);

int ncmpi_get_var1_all         (int                 ncid,
                                int                 varid,
                                const MPI_Offset    index[],
                                void               *buf,
                                MPI_Offset          bufcount,
                                MPI_Datatype        buftype);
@end example

@table @code

@item ncid
NetCDF ID, from a previous call to ncmpi_open or ncmpi_create.

@item varid
Variable ID. Different MPI processes may use different variable IDs.

@item index[]
The index of the data value to be read. The indices are relative to
0, so for example, the first data value of a two-dimensional variable
would have index (0,0). The elements of index must correspond to the
variable's dimensions. Hence, if the variable is a record variable,
the first index is the record number.

@item buf
Pointer to the location into which the data value is read. If the type of data values
differs from the netCDF variable type, type conversion will
@c occur. @xref{Type Conversion,,, pnetcdf, The PnetCDF Users Guide}.

@item bufcount
An integer indicates the number of MPI derived data type elements in the buf to be read from the file.

@item buftype
An MPI derived data type that describes the memory layout of buf.
Starting from PnetCDF version 1.6.0, buftype can be MPI_DATATYPE_NULL.
In this case, bufcount is ignored and the buf's data type must match the type
of the variable defined in the file - no data conversion will be done.

@end table

@heading Return Error Codes
ncmpi_get_var1_@var{<type>} returns the value NC_NOERR if no errors
occurred. Otherwise, the returned status indicates an error. Possible
causes of errors include:
@itemize
@item NC_EBADID: The specified netCDF ID does not refer to an opened netCDF file.
@item NC_ENOTVAR: The variable ID is invalid for the specified netCDF file.
@item NC_EGLOBAL: NC_GLOBAL is considered invalid for these APIs.
@item NC_EINVALCOORDS: The specified corner indices were out of range for the rank of the specified variable. For example, a negative index, or an index that is larger than the corresponding dimension length will cause an error.
@item NC_EEDGE: The specified edge lengths added to the specified corner would have referenced data out of range for the rank of the specified variable. For example, an edge length that is larger than the corresponding dimension length minus the corner index will cause an error.
@item NC_ERANGE: One or more elements of the external variable are out of the range of values representable by the internal data type of read buffer, buf. (Does not apply to the ncmpi_get_var1() and ncmpi_get_var1_all()).
@item NC_EINDEFINE: Operation not allowed in define mode.
@item NC_ECHAR: Attempt to convert numerical values to or from text data.
@item NC_ENOMEM: Out of memory.
@item NC_EINDEP: Attempt collective I/O operations in independent data mode.
@item NC_ENOTINDEP: Attempt independent I/O operations in collective data mode.
@item NC_EIOMISMATCH: The number of variable elements requested in (bufcount, buftype) is not equal to one. This error may only occur for flexible APIs.
@item NC_ENOTSUPPORT: Flexible APIs for NetCDF-4 files is not yet supported.
@end itemize

@heading Example

Here is an example using ncmpi_get_var1_double_all to get the elements
at starting indices (1+rank*10, 2+rank*10, 3+rank*10) of the variable
named rh in parallel in an existing netCDF file named
foo.nc. For simplicity in this example, we assume that we know that rh
is dimensioned with time, lat, and lon. If run sequentially (i.e. one MPI
process), this example is equivalent to to get the values of
rh that corresponds to the second time value, the third lat value, and
the fourth lon value:

@example
#include <pnetcdf.h>
   ...
int  status;                       /* error status */
int  rank;                         /* MPI process rank ID */
int  ncid;                         /* netCDF ID */
int  rh_id;                        /* variable ID */
MPI_Offset rh_index[] = @{1, 2, 3@}; /* where to get value from */
double rh_val;                     /* where to put it */
   ...
/* Open file in read-only mode */
status = @ref{ncmpi_open}(MPI_COMM_WORLD, "foo.nc", NC_NOWRITE, MPI_INFO_NULL,  &ncid);
if (status != NC_NOERR) handle_error(status);
   ...
/* Obtain the variable ID */
status = @ref{ncmpi_inq_varid}(ncid, "rh", &rh_id);
if (status != NC_NOERR) handle_error(status);
   ...
/* Set the starting indices. Indices are different at each process */
MPI_Comm_rank(MPI_COMM_WORLD, &rank);
rh_index[0] += rank*10;
rh_index[1] += rank*10;
rh_index[2] += rank*10;

/* Each MPI process reads a single value from a different location of variable rh */
status = @ref{ncmpi_get_var1_@var{<type>}, ncmpi_get_var1_double_all}(ncid, rh_id, rh_index, &rh_val);
if (status != NC_NOERR) handle_error(status);
@end example

@node ncmpi_get_var_@var{<type>}, ncmpi_get_vara_@var{<type>}, ncmpi_get_var1_@var{<type>}, Variables
@section Read an Entire Variable ncmpi_get_var_@var{<type>}
@findex ncmpi_get_var_text
@findex ncmpi_get_var_uchar
@findex ncmpi_get_var_schar
@findex ncmpi_get_var_short
@findex ncmpi_get_var_int
@findex ncmpi_get_var_float
@findex ncmpi_get_var_double
@findex ncmpi_get_var_ushort
@findex ncmpi_get_var_unit
@findex ncmpi_get_var_longlong
@findex ncmpi_get_var_ulonglong
@findex ncmpi_get_var_text_all
@findex ncmpi_get_var_uchar_all
@findex ncmpi_get_var_schar_all
@findex ncmpi_get_var_short_all
@findex ncmpi_get_var_int_all
@findex ncmpi_get_var_float_all
@findex ncmpi_get_var_double_all
@findex ncmpi_get_var_ushort_all
@findex ncmpi_get_var_unit_all
@findex ncmpi_get_var_longlong_all
@findex ncmpi_get_var_ulonglong_all
@cindex ncmpi_get_var_text, example
@cindex ncmpi_get_var_uchar, example
@cindex ncmpi_get_var_schar, example
@cindex ncmpi_get_var_short, example
@cindex ncmpi_get_var_int, example
@cindex ncmpi_get_var_float, example
@cindex ncmpi_get_var_double, example
@cindex ncmpi_get_var_ushort, example
@cindex ncmpi_get_var_unit, example
@cindex ncmpi_get_var_longlong, example
@cindex ncmpi_get_var_ulonglong, example
@cindex ncmpi_get_var_text_all, example
@cindex ncmpi_get_var_uchar_all, example
@cindex ncmpi_get_var_schar_all, example
@cindex ncmpi_get_var_short_all, example
@cindex ncmpi_get_var_int_all, example
@cindex ncmpi_get_var_float_all, example
@cindex ncmpi_get_var_double_all, example
@cindex ncmpi_get_var_ushort_all, example
@cindex ncmpi_get_var_unit_all, example
@cindex ncmpi_get_var_longlong_all, example
@cindex ncmpi_get_var_ulonglong_all, example
@cindex reading entire variable
@cindex entire variable, reading

The members of the ncmpi_get_var_@var{<type>} family of functions read all the
values from a netCDF variable of an opened netCDF file. This is the
simplest interface to use for reading the value of a scalar variable
or when all the values of a multidimensional variable can be read at
once. The values are read into consecutive locations with the last
dimension varying fastest.

Take care when using the simplest forms of this interface with record
variables when you don't specify how many records are to be read. If
you try to read all the values of a record variable into an array but
there are more records in the file than you assume, more data will be
read than you expect, which may cause a segmentation violation.

@heading Data types
@html
<table cellpadding="4" border="1">
<tr class="spacer" align=center>
    <td> &lt;<b>type  </b>&gt; for API names </td>
    <td> &lt;<b>C type</b>&gt; for API arguments </td>
</tr>
<tr align=center> <td>text     </td> <td>char             </td> </tr>
<tr align=center> <td>schar    </td> <td>signed char      </td> </tr>
<tr align=center> <td>short    </td> <td>short            </td> </tr>
<tr align=center> <td>int      </td> <td>int              </td> </tr>
<tr align=center> <td>float    </td> <td>float            </td> </tr>
<tr align=center> <td>double   </td> <td>double           </td> </tr>
<tr align=center> <td>uchar    </td> <td>unsigned char    </td> </tr>
<tr align=center> <td>ushort   </td> <td>unsigned short   </td> </tr>
<tr align=center> <td>uint     </td> <td>unsigned int     </td> </tr>
<tr align=center> <td>longlong </td> <td>long long        </td> </tr>
<tr align=center> <td>ulonglong</td> <td>unsigned longlong</td> </tr>
</table>
@end html

@heading Operational Mode
These API must be called while the file is in data mode.

@heading Collective I/O
The corresponding collective APIs have the suffix name "_all" and must be called in collective data mode.

@heading Usage
@example
int ncmpi_get_var_@strong{<type>}     (int                  ncid,
                               int                 varid,
                               @strong{<C type>}           *buf);

int ncmpi_get_var             (int                 ncid,
                               int                 varid,
                               void               *buf,
                               MPI_Offset          bufcount,
                               MPI_Datatype        buftype);

int ncmpi_get_var_@strong{<type>}_all (int                  ncid,
                               int                 varid,
                               @strong{<C type>}           *buf);

int ncmpi_get_var_all         (int                 ncid,
                               int                 varid,
                               void               *buf,
                               MPI_Offset          bufcount,
                               MPI_Datatype        buftype);
@end example

@table @code

@item ncid
NetCDF ID, from a previous call to ncmpi_open or ncmpi_create.

@item varid
Variable ID. Different MPI processes may use different variable IDs.

@item buf
Pointer to a block of contiguous locations in memory into which the data values are read. If the type of data value differs from the netCDF variable type, type conversion will occur.
@c @xref{Type Conversion,,, pnetcdf, The PnetCDF Users Guide}.

@item bufcount
An integer indicates the number of MPI derived data type elements in the buf to be read from the file.

@item buftype
An MPI derived data type that describes the memory layout of buf.
Starting from PnetCDF version 1.6.0, buftype can be MPI_DATATYPE_NULL.
In this case, bufcount is ignored and the buf's data type must match the type
of the variable defined in the file - no data conversion will be done.

@end table

@heading Return Error Codes
ncmpi_get_var_@var{<type>} returns the value NC_NOERR if no errors
occurred. Otherwise, the returned status indicates an error. Possible
causes of errors include:
@itemize
@item NC_EBADID: The specified netCDF ID does not refer to an opened netCDF file.
@item NC_ENOTVAR: The variable ID is invalid for the specified netCDF file.
@item NC_EGLOBAL: NC_GLOBAL is considered invalid for these APIs.
@item NC_ERANGE: One or more elements of the external variable are out of the range of values representable by the internal data type of read buffer, buf. (Does not apply to the ncmpi_get_var() and ncmpi_get_var_all()).
@item NC_EINDEFINE: Operation not allowed in define mode.
@item NC_ECHAR: Attempt to convert numerical values to or from text data.
@item NC_ENOMEM: Out of memory.
@item NC_EINDEP: Attempt collective I/O operations in independent data mode.
@item NC_ENOTINDEP: Attempt independent I/O operations in collective data mode.
@item NC_ENOTSUPPORT: Flexible APIs for NetCDF-4 files is not yet supported.
@end itemize

@heading Example

Here is an example using ncmpi_get_var_double_all to read all the values of
the variable named rh in parallel from an existing netCDF file named
foo.nc. For simplicity in this example, we assume that we know that rh
is dimensioned with time, lat, and lon, and that there are three time
values, five lat values, and ten lon values.

@example
#include <pnetcdf.h>
   ...
#define TIMES 3
#define LATS 5
#define LONS 10
int  status;                       /* error status */
int ncid;                          /* netCDF ID */
int rh_id;                         /* variable ID */
double rh_vals[TIMES*LATS*LONS];   /* array to hold values */
   ...
/* open the file in read-only mode */
status = @ref{ncmpi_open}(MPI_COMM_WORLD, "foo.nc", NC_NOWRITE, MPI_INFO_NULL,  &ncid);
if (status != NC_NOERR) handle_error(status);
   ...
/* obtain variable ID */
status = @ref{ncmpi_inq_varid}(ncid, "rh", &rh_id);
if (status != NC_NOERR) handle_error(status);
   ...
/* all processes read the whole variable in parallel (collectively) */
status = @ref{ncmpi_get_var_@var{<type>}, cmpi_get_var_double_all}(ncid, rh_id, rh_vals);
if (status != NC_NOERR) handle_error(status);
@end example

@node ncmpi_get_vara_@var{<type>}, ncmpi_get_vars_@var{<type>}, ncmpi_get_var_@var{<type>}, Variables
@section Read an Array of Values: ncmpi_get_vara_@var{<type>}
@findex ncmpi_get_vara_text
@findex ncmpi_get_vara_uchar
@findex ncmpi_get_vara_schar
@findex ncmpi_get_vara_short
@findex ncmpi_get_vara_int
@findex ncmpi_get_vara_float
@findex ncmpi_get_vara_double
@findex ncmpi_get_vara_ushort
@findex ncmpi_get_vara_unit
@findex ncmpi_get_vara_longlong
@findex ncmpi_get_vara_ulonglong
@findex ncmpi_get_vara_text_all
@findex ncmpi_get_vara_uchar_all
@findex ncmpi_get_vara_schar_all
@findex ncmpi_get_vara_short_all
@findex ncmpi_get_vara_int_all
@findex ncmpi_get_vara_float_all
@findex ncmpi_get_vara_double_all
@findex ncmpi_get_vara_ushort_all
@findex ncmpi_get_vara_unit_all
@findex ncmpi_get_vara_longlong_all
@findex ncmpi_get_vara_ulonglong_all
@cindex ncmpi_get_vara_text, example
@cindex ncmpi_get_vara_uchar, example
@cindex ncmpi_get_vara_schar, example
@cindex ncmpi_get_vara_short, example
@cindex ncmpi_get_vara_int, example
@cindex ncmpi_get_vara_float, example
@cindex ncmpi_get_vara_double, example
@cindex ncmpi_get_vara_ushort, example
@cindex ncmpi_get_vara_unit, example
@cindex ncmpi_get_vara_longlong, example
@cindex ncmpi_get_vara_ulonglong, example
@cindex ncmpi_get_vara_text_all, example
@cindex ncmpi_get_vara_uchar_all, example
@cindex ncmpi_get_vara_schar_all, example
@cindex ncmpi_get_vara_short_all, example
@cindex ncmpi_get_vara_int_all, example
@cindex ncmpi_get_vara_float_all, example
@cindex ncmpi_get_vara_double_all, example
@cindex ncmpi_get_vara_ushort_all, example
@cindex ncmpi_get_vara_unit_all, example
@cindex ncmpi_get_vara_longlong_all, example
@cindex ncmpi_get_vara_ulonglong_all, example
@cindex array section, reading mapped
@cindex array section, writing mapped

The members of the ncmpi_get_vara_@var{<type>} family of functions read an array
of values from a netCDF variable of an opened netCDF file. The array
is specified by giving a corner and a vector of edge lengths. The
values are read into consecutive locations with the last dimension
varying fastest.

@heading Data types
@html
<table cellpadding="4" border="1">
<tr class="spacer" align=center>
    <td> &lt;<b>type  </b>&gt; for API names </td>
    <td> &lt;<b>C type</b>&gt; for API arguments </td>
</tr>
<tr align=center> <td>text     </td> <td>char             </td> </tr>
<tr align=center> <td>schar    </td> <td>signed char      </td> </tr>
<tr align=center> <td>short    </td> <td>short            </td> </tr>
<tr align=center> <td>int      </td> <td>int              </td> </tr>
<tr align=center> <td>float    </td> <td>float            </td> </tr>
<tr align=center> <td>double   </td> <td>double           </td> </tr>
<tr align=center> <td>uchar    </td> <td>unsigned char    </td> </tr>
<tr align=center> <td>ushort   </td> <td>unsigned short   </td> </tr>
<tr align=center> <td>uint     </td> <td>unsigned int     </td> </tr>
<tr align=center> <td>longlong </td> <td>long long        </td> </tr>
<tr align=center> <td>ulonglong</td> <td>unsigned longlong</td> </tr>
</table>
@end html

@heading Operational Mode
These API must be called while the file is in data mode.

@heading Collective I/O
The corresponding collective APIs have the suffix name "_all" and must be called in collective data mode.

@heading Usage
@example
int ncmpi_get_vara_@strong{<type>}     (int                  ncid,
                                int                 varid,
                                const MPI_Offset    start[],
                                const MPI_Offset    count[],
                                @strong{<C type>}           *buf);

int ncmpi_get_vara             (int                 ncid,
                                int                 varid,
                                const MPI_Offset    start[],
                                const MPI_Offset    count[],
                                void               *buf,
                                MPI_Offset          bufcount,
                                MPI_Datatype        buftype);

int ncmpi_get_vara_@strong{<type>}_all (int                  ncid,
                                int                 varid,
                                const MPI_Offset    start[],
                                const MPI_Offset    count[],
                                @strong{<C type>}           *buf);

int ncmpi_get_vara_all         (int                 ncid,
                                int                 varid,
                                const MPI_Offset    start[],
                                const MPI_Offset    count[],
                                void               *buf,
                                MPI_Offset          bufcount,
                                MPI_Datatype        buftype);
@end example

@table @code

@item ncid
NetCDF ID, from a previous call to ncmpi_open or ncmpi_create.

@item varid
Variable ID. Different MPI processes may use different variable IDs.

@item start
A vector of MPI_Offset integers specifying the index in the variable
where the first of the data values will be read. The indices are
relative to 0, so for example, the first data value of a variable
would have index (0, 0, ... , 0). The length of start must be the same
as the number of dimensions of the specified variable. The elements of
start correspond, in order, to the variable's dimensions. Hence, if
the variable is a record variable, the first index would correspond to
the starting record number for reading the data values.

@item count
A vector of MPI_Offset integers specifying the edge lengths along each
dimension of the block of data values to be read. To read a single
value, for example, specify count as (1, 1, ... , 1). The length of
count is the number of dimensions of the specified variable. The
elements of count correspond, in order, to the variable's
dimensions. Hence, if the variable is a record variable, the first
element of count corresponds to a count of the number of records to
read.

@item buf
Pointer to the location into which the data value is read. If the type
of data value differs from the netCDF variable type, type conversion
will occur.
@c @xref{Type Conversion,,, pnetcdf, The PnetCDF Users Guide}.

@item bufcount
An integer indicates the number of MPI derived data type elements in the buf to be read from the file.

@item buftype
An MPI derived data type that describes the memory layout of buf.
Starting from PnetCDF version 1.6.0, buftype can be MPI_DATATYPE_NULL.
In this case, bufcount is ignored and the buf's data type must match the type
of the variable defined in the file - no data conversion will be done.

@end table

@heading Layout Illustration for Read Buffer in Memory and Data Read from File
@center @image{images/get_vara,,, get_vara mapping, png}

@heading Return Error Codes
ncmpi_get_vara_@var{<type>} returns the value NC_NOERR if no errors
occurred. Otherwise, the returned status indicates an error. Possible
causes of errors include:
@itemize
@item NC_EBADID: The specified netCDF ID does not refer to an opened netCDF file.
@item NC_ENOTVAR: The variable ID is invalid for the specified netCDF file.
@item NC_EGLOBAL: NC_GLOBAL is considered invalid for these APIs.
@item NC_EINVALCOORDS: The specified corner indices were out of range for the rank of the specified variable. For example, a negative index, or an index that is larger than the corresponding dimension length will cause an error.
@item NC_EEDGE: The specified edge lengths added to the specified corner would have referenced data out of range for the rank of the specified variable. For example, an edge length that is larger than the corresponding dimension length minus the corner index will cause an error.
@item NC_ERANGE: One or more elements of the external variable are out of the range of values representable by the internal data type of read buffer, buf. (Does not apply to the ncmpi_get_vara() and ncmpi_get_vara_all()).
@item NC_EINDEFINE: Operation not allowed in define mode.
@item NC_ECHAR: Attempt to convert numerical values to or from text data.
@item NC_ENOMEM: Out of memory.
@item NC_EINDEP: Attempt collective I/O operations in independent data mode.
@item NC_ENOTINDEP: Attempt independent I/O operations in collective data mode.
@item NC_EIOMISMATCH: The number of variable elements requested in (bufcount, buftype) mismatches the one calculated from count. This error may only occur for flexible APIs.
@item NC_ENOTSUPPORT: Flexible APIs for NetCDF-4 files is not yet supported.
@end itemize

@heading Example

Here is an example using ncmpi_get_vara_double_all to read a whole record of
the variable named rh in parallel from an existing netCDF file named
foo.nc. For simplicity in this example, we assume that the number of total
MPI processes running is 4 and we know
that rh is dimensioned with time, lat, and lon, and that there are
three time values, five lat values, and 4*10 lon values.

@example
#include <pnetcdf.h>
   ...
#define TIMES 3
#define LATS  5
#define LONS 10
int  status;                     /* error status */
int ncid;                        /* netCDF ID */
int rh_id;                       /* variable ID */
MPI_Offset start[3];             /* start at first value to be read */
MPI_Offset count[3];             /* read lengths along each dimension */
double rh_vals[TIMES*LATS*LONS]; /* local buffer */
   ...
/* open the file in read-only mode */
status = @ref{ncmpi_open}(MPI_COMM_WORLD, "foo.nc", NC_NOWRITE, MPI_INFO_NULL,  &ncid);
if (status != NC_NOERR) handle_error(status);
   ...
/* inquire the variable ID */
status = @ref{ncmpi_inq_varid}(ncid, "rh", &rh_id);
if (status != NC_NOERR) handle_error(status);
   ...
/* set the starting indices and read lengths for this process */
MPI_Comm_rank(MPI_COMM_WORLD, &rank);
start[0] = 3;
start[1] = 0;
start[2] = LONS * rank;
count[0] = 1;
count[1] = LATS;
count[2] = LONS;
   ...

/* collectively read a record of variable "rh" */
status = @ref{ncmpi_get_vara_@var{<type>}, ncmpi_get_vara_double_all}(ncid, rh_id, start, count, rh_vals);
if (status != NC_NOERR) handle_error(status);
@end example

@heading Full example C program
@itemize
@item
@url{https://github.com/Parallel-NetCDF/PnetCDF/tree/master/examples/C/get_vara.c, get_vara.c}
@item
@url{https://github.com/Parallel-NetCDF/PnetCDF/tree/master/examples/C/flexible_api.c, flexible_api.c}
@item
The above programs are available in all PnetCDF releases under directory examples/C.
@end itemize

@node ncmpi_get_vars_@var{<type>}, ncmpi_get_varm_@var{<type>}, ncmpi_get_vara_@var{<type>}, Variables
@section Read a Subsampled Array of Values: ncmpi_get_vars_@var{<type>}
@findex ncmpi_get_vars_text
@findex ncmpi_get_vars_uchar
@findex ncmpi_get_vars_schar
@findex ncmpi_get_vars_short
@findex ncmpi_get_vars_int
@findex ncmpi_get_vars_float
@findex ncmpi_get_vars_double
@findex ncmpi_get_vars_ushort
@findex ncmpi_get_vars_unit
@findex ncmpi_get_vars_longlong
@findex ncmpi_get_vars_ulonglong
@findex ncmpi_get_vars_text_all
@findex ncmpi_get_vars_uchar_all
@findex ncmpi_get_vars_schar_all
@findex ncmpi_get_vars_short_all
@findex ncmpi_get_vars_int_all
@findex ncmpi_get_vars_float_all
@findex ncmpi_get_vars_double_all
@findex ncmpi_get_vars_ushort_all
@findex ncmpi_get_vars_unit_all
@findex ncmpi_get_vars_longlong_all
@findex ncmpi_get_vars_ulonglong_all
@cindex ncmpi_get_vars_text, example
@cindex ncmpi_get_vars_uchar, example
@cindex ncmpi_get_vars_schar, example
@cindex ncmpi_get_vars_short, example
@cindex ncmpi_get_vars_int, example
@cindex ncmpi_get_vars_float, example
@cindex ncmpi_get_vars_double, example
@cindex ncmpi_get_vars_ushort, example
@cindex ncmpi_get_vars_unit, example
@cindex ncmpi_get_vars_longlong, example
@cindex ncmpi_get_vars_ulonglong, example
@cindex ncmpi_get_vars_text_all, example
@cindex ncmpi_get_vars_uchar_all, example
@cindex ncmpi_get_vars_schar_all, example
@cindex ncmpi_get_vars_short_all, example
@cindex ncmpi_get_vars_int_all, example
@cindex ncmpi_get_vars_float_all, example
@cindex ncmpi_get_vars_double_all, example
@cindex ncmpi_get_vars_ushort_all, example
@cindex ncmpi_get_vars_unit_all, example
@cindex ncmpi_get_vars_longlong_all, example
@cindex ncmpi_get_vars_ulonglong_all, example
@cindex array section, writing subsampled
@cindex array section, reading subsampled

The ncmpi_get_vars_@var{<type>} family of functions read a subsampled (strided)
array section of values from a netCDF variable of an opened netCDF
file. The subsampled array section is specified by giving a corner,
a vector of edge lengths, and a stride vector. The values are read
with the last dimension of the netCDF variable varying fastest.

@heading Data types
@html
<table cellpadding="4" border="1">
<tr class="spacer" align=center>
    <td> &lt;<b>type  </b>&gt; for API names </td>
    <td> &lt;<b>C type</b>&gt; for API arguments </td>
</tr>
<tr align=center> <td>text     </td> <td>char             </td> </tr>
<tr align=center> <td>schar    </td> <td>signed char      </td> </tr>
<tr align=center> <td>short    </td> <td>short            </td> </tr>
<tr align=center> <td>int      </td> <td>int              </td> </tr>
<tr align=center> <td>float    </td> <td>float            </td> </tr>
<tr align=center> <td>double   </td> <td>double           </td> </tr>
<tr align=center> <td>uchar    </td> <td>unsigned char    </td> </tr>
<tr align=center> <td>ushort   </td> <td>unsigned short   </td> </tr>
<tr align=center> <td>uint     </td> <td>unsigned int     </td> </tr>
<tr align=center> <td>longlong </td> <td>long long        </td> </tr>
<tr align=center> <td>ulonglong</td> <td>unsigned longlong</td> </tr>
</table>
@end html

@heading Operational Mode
These API must be called while the file is in data mode.

@heading Collective I/O
The corresponding collective APIs have the suffix name "_all" and must be called in collective data mode.

@heading Usage
@example
int ncmpi_get_vars_@strong{<type>}     (int                  ncid,
                                int                 varid,
                                const MPI_Offset    start[],
                                const MPI_Offset    count[],
                                const MPI_Offset    stride[],
                                @strong{<C type>}           *buf);

int ncmpi_get_vars             (int                 ncid,
                                int                 varid,
                                const MPI_Offset    start[],
                                const MPI_Offset    count[],
                                const MPI_Offset    stride[],
                                void               *buf,
                                MPI_Offset          bufcount,
                                MPI_Datatype        buftype);

int ncmpi_get_vars_@strong{<type>}_all (int                  ncid,
                                int                 varid,
                                const MPI_Offset    start[],
                                const MPI_Offset    count[],
                                const MPI_Offset    stride[],
                                @strong{<C type>}           *buf);

int ncmpi_get_vars_all         (int                 ncid,
                                int                 varid,
                                const MPI_Offset    start[],
                                const MPI_Offset    count[],
                                const MPI_Offset    stride[],
                                void               *buf,
                                MPI_Offset          bufcount,
                                MPI_Datatype        buftype);
@end example

@table @code

@item ncid
NetCDF ID, from a previous call to ncmpi_open or ncmpi_create.

@item varid
Variable ID. Different MPI processes may use different variable IDs.

@item start
A vector of MPI_Offset integers specifying the index in the variable
where the first of the data values will be read. The indices are
relative to 0, so for example, the first data value of a variable
would have index (0, 0, ... , 0). The elements of start correspond, in
order, to the variable's dimensions. Hence, if the variable is a
record variable, the first index corresponds to the starting record
number for reading the data values.

@item count
A vector of MPI_Offset integers specifying the number of indices selected
along each dimension. To read a single value, for example, specify
count as (1, 1, ... , 1). The elements of count correspond, in order,
to the variable's dimensions. Hence, if the variable is a record
variable, the first element of count corresponds to a count of the
number of records to read.

@item stride
A vector of MPI_Offset integers specifying, for each dimension, the
interval between selected indices. The elements of the stride vector
correspond, in order, to the variable's dimensions. A value of 1
accesses adjacent values of the netCDF variable in the corresponding
dimension; a value of 2 accesses every other value of the netCDF
variable in the corresponding dimension; and so on. A NULL stride
argument is treated as (1, 1, ... , 1).

@item buf
Pointer to a block of contiguous locations in memory into which the data values are read. If the type of data value differs from the netCDF variable type, type conversion will occur.
@c @xref{Type Conversion,,, pnetcdf, The PnetCDF Users Guide}.

@item bufcount
An integer indicates the number of MPI derived data type elements in the buf to be read from the file.

@item buftype
An MPI derived data type that describes the memory layout of buf.
Starting from PnetCDF version 1.6.0, buftype can be MPI_DATATYPE_NULL.
In this case, bufcount is ignored and the buf's data type must match the type
of the variable defined in the file - no data conversion will be done.

@end table

@heading Layout Illustration for Read Buffer in Memory and Data Read from File
@center @image{images/get_vars,,, get_vars mapping, png}

@heading Return Error Codes
ncmpi_get_vars_@var{<type>} returns the value NC_NOERR if no errors
occurred. Otherwise, the returned status indicates an error. Possible
causes of errors include:
@itemize
@item NC_EBADID: The specified netCDF ID does not refer to an opened netCDF file.
@item NC_ENOTVAR: The variable ID is invalid for the specified netCDF file.
@item NC_EGLOBAL: NC_GLOBAL is considered invalid for these APIs.
@item NC_EINVALCOORDS: The specified corner indices were out of range for the rank of the specified variable. For example, a negative index, or an index that is larger than the corresponding dimension length will cause an error.
@item NC_EEDGE: The specified edge lengths added to the specified corner would have referenced data out of range for the rank of the specified variable. For example, an edge length that is larger than the corresponding dimension length minus the corner index will cause an error.
@item NC_ERANGE: One or more elements of the external variable are out of the range of values representable by the internal data type of read buffer, buf. (Does not apply to the ncmpi_get_vars() and ncmpi_get_vars_all()).
@item NC_EINDEFINE: Operation not allowed in define mode.
@item NC_ECHAR: Attempt to convert numerical values to or from text data.
@item NC_ENOMEM: Out of memory.
@item NC_EINDEP: Attempt collective I/O operations in independent data mode.
@item NC_ENOTINDEP: Attempt independent I/O operations in collective data mode.
@item NC_EIOMISMATCH: The number of variable elements requested in (bufcount, buftype) mismatches the one calculated from count. This error may only occur for flexible APIs.
@item NC_ENOTSUPPORT: Flexible APIs for NetCDF-4 files is not yet supported.
@end itemize

@heading Example

Here is an example of using ncmpi_get_vars_float_all to read
every other point of a netCDF variable named rh in parallel
which is described by the C declaration float rh[4][6] (note the size
of the dimensions). In this example, we assume there are 4 MPI processes
running. The parallel read reads the entire 4x6 array.

@example
#include <pnetcdf.h>
   ...
#define NDIM 2                    /* rank of netCDF variable */
int ncid;                         /* netCDF ID */
int status;                       /* error status */
int rhid;                         /* variable ID */
MPI_Offset start[NDIM];           /* netCDF variable start point: first element */
MPI_Offset count[NDIM] = @{2, 3@};  /* size of internal array: entire (subsampled) netCDF variable */
MPI_Offset stride[NDIM] = @{2, 2@}; /* variable subsampling intervals: access every other netCDF element */
float rh[2][3];                   /* note subsampled sizes for netCDF variable dimensions */
   ...
/* open the file in read-only mode */
status = @ref{ncmpi_open}(MPI_COMM_WORLD, "foo.nc", NC_NOWRITE, MPI_INFO_NULL, &ncid);
if (status != NC_NOERR) handle_error(status);
   ...
/* inquire variable ID */
status = @ref{ncmpi_inq_varid}(ncid, "rh", &rhid);
if (status != NC_NOERR) handle_error(status);
   ...
/* set the starting indices and read lengths for this process */
MPI_Comm_rank(MPI_COMM_WORLD, &rank);
if (rank == 0) @{
    start[0] = 0;
    start[1] = 0;                 /* read locations by process rank IDs:
@} else if (rank == 1) @{              0 1 0 1 0 1
    start[0] = 0;                    2 3 2 3 2 3
    start[1] = 1;                    0 1 0 1 0 1
@} else if (rank == 2) @{              2 3 2 3 2 3
    start[0] = 1;                  */
    start[1] = 0;
@} else if (rank == 3) @{
    start[0] = 1;
    start[1] = 1;
@}
   ...
/* collectively read the variable */
status = @ref{ncmpi_get_vars_@var{<type>}, ncmpi_get_vars_float_all}(ncid, rhid, start, count, stride, rh);
if (status != NC_NOERR) handle_error(status);
@end example

@node ncmpi_get_varm_@var{<type>}, ncmpi_get_varn_@var{<type>}, ncmpi_get_vars_@var{<type>}, Variables
@section Read a Mapped Array of Values: ncmpi_get_varm_@var{<type>}
@findex ncmpi_get_varm_text
@findex ncmpi_get_varm_uchar
@findex ncmpi_get_varm_schar
@findex ncmpi_get_varm_short
@findex ncmpi_get_varm_int
@findex ncmpi_get_varm_float
@findex ncmpi_get_varm_double
@findex ncmpi_get_varm_ushort
@findex ncmpi_get_varm_unit
@findex ncmpi_get_varm_longlong
@findex ncmpi_get_varm_ulonglong
@findex ncmpi_get_varm_text_all
@findex ncmpi_get_varm_uchar_all
@findex ncmpi_get_varm_schar_all
@findex ncmpi_get_varm_short_all
@findex ncmpi_get_varm_int_all
@findex ncmpi_get_varm_float_all
@findex ncmpi_get_varm_double_all
@findex ncmpi_get_varm_ushort_all
@findex ncmpi_get_varm_unit_all
@findex ncmpi_get_varm_longlong_all
@findex ncmpi_get_varm_ulonglong_all
@cindex ncmpi_get_varm_text, example
@cindex ncmpi_get_varm_uchar, example
@cindex ncmpi_get_varm_schar, example
@cindex ncmpi_get_varm_short, example
@cindex ncmpi_get_varm_int, example
@cindex ncmpi_get_varm_float, example
@cindex ncmpi_get_varm_double, example
@cindex ncmpi_get_varm_ushort, example
@cindex ncmpi_get_varm_unit, example
@cindex ncmpi_get_varm_longlong, example
@cindex ncmpi_get_varm_ulonglong, example
@cindex ncmpi_get_varm_text_all, example
@cindex ncmpi_get_varm_uchar_all, example
@cindex ncmpi_get_varm_schar_all, example
@cindex ncmpi_get_varm_short_all, example
@cindex ncmpi_get_varm_int_all, example
@cindex ncmpi_get_varm_float_all, example
@cindex ncmpi_get_varm_double_all, example
@cindex ncmpi_get_varm_ushort_all, example
@cindex ncmpi_get_varm_unit_all, example
@cindex ncmpi_get_varm_longlong_all, example
@cindex ncmpi_get_varm_ulonglong_all, example
@cindex reading mapped array section
@cindex mapped array section, reading

The ncmpi_get_varm_@var{<type>} family of functions reads a mapped array section
of values from a netCDF variable of an opened netCDF file. The mapped
array section is specified by giving a corner, a vector of edge
lengths, a stride vector, and an index mapping vector. The index
mapping vector is a vector of integers that specifies the mapping
between the dimensions of a netCDF variable and the in-memory
structure of the internal data array. No assumptions are made about
the ordering or length of the dimensions of the data array.

The most common use case for this API is to read a matrix-transposed array.
See an example below.

@heading Data types
@html
<table cellpadding="4" border="1">
<tr class="spacer" align=center>
    <td> &lt;<b>type  </b>&gt; for API names </td>
    <td> &lt;<b>C type</b>&gt; for API arguments </td>
</tr>
<tr align=center> <td>text     </td> <td>char             </td> </tr>
<tr align=center> <td>schar    </td> <td>signed char      </td> </tr>
<tr align=center> <td>short    </td> <td>short            </td> </tr>
<tr align=center> <td>int      </td> <td>int              </td> </tr>
<tr align=center> <td>float    </td> <td>float            </td> </tr>
<tr align=center> <td>double   </td> <td>double           </td> </tr>
<tr align=center> <td>uchar    </td> <td>unsigned char    </td> </tr>
<tr align=center> <td>ushort   </td> <td>unsigned short   </td> </tr>
<tr align=center> <td>uint     </td> <td>unsigned int     </td> </tr>
<tr align=center> <td>longlong </td> <td>long long        </td> </tr>
<tr align=center> <td>ulonglong</td> <td>unsigned longlong</td> </tr>
</table>
@end html

@heading Operational Mode
These API must be called while the file is in data mode.

@heading Collective I/O
The corresponding collective APIs have the suffix name "_all" and must be called in collective data mode.

@heading Usage
@example
int ncmpi_get_varm_@strong{<type>}     (int                  ncid,
                                int                 varid,
                                const MPI_Offset    start[],
                                const MPI_Offset    count[],
                                const MPI_Offset    stride[],
                                const MPI_Offset    imap[],
                                @strong{<C type>}           *buf);

int ncmpi_get_varm             (int                 ncid,
                                int                 varid,
                                const MPI_Offset    start[],
                                const MPI_Offset    count[],
                                const MPI_Offset    stride[],
                                const MPI_Offset    imap[],
                                void               *buf,
                                MPI_Offset          bufcount,
                                MPI_Datatype        buftype);

int ncmpi_get_varm_@strong{<type>}_all (int                  ncid,
                                int                 varid,
                                const MPI_Offset    start[],
                                const MPI_Offset    count[],
                                const MPI_Offset    stride[],
                                const MPI_Offset    imap[],
                                @strong{<C type>}           *buf);

int ncmpi_get_varm_all         (int                 ncid,
                                int                 varid,
                                const MPI_Offset    start[],
                                const MPI_Offset    count[],
                                const MPI_Offset    stride[],
                                const MPI_Offset    imap[],
                                void               *buf,
                                MPI_Offset          bufcount,
                                MPI_Datatype        buftype);
@end example

@table @code

@item ncid
NetCDF ID, from a previous call to ncmpi_open or ncmpi_create.

@item varid
Variable ID. Different MPI processes may use different variable IDs.

@item start
A vector of MPI_Offset integers specifying the index in the variable
where the first of the data values will be read. The indices are
relative to 0, so for example, the first data value of a variable
would have index (0, 0, ... , 0). The elements of start correspond, in
order, to the variable's dimensions. Hence, if the variable is a
record variable, the first index corresponds to the starting record
number for reading the data values.

@item count
A vector of MPI_Offset integers specifying the number of indices selected
along each dimension. To read a single value, for example, specify
count as (1, 1, ... , 1). The elements of count correspond, in order,
to the variable's dimensions. Hence, if the variable is a record
variable, the first element of count corresponds to a count of the
number of records to read.

@item stride
A vector of MPI_Offset integers specifying, for each dimension, the
interval between selected indices. The elements of the stride vector
correspond, in order, to the variable's dimensions. A value of 1
accesses adjacent values of the netCDF variable in the corresponding
dimension; a value of 2 accesses every other value of the netCDF
variable in the corresponding dimension; and so on. A NULL stride
argument is treated as (1, 1, ... , 1).

@item imap
A vector of integers that specifies the mapping between the
dimensions of a netCDF variable and the in-memory structure of the
internal data array. imap[0] gives the distance between elements of
the internal array corresponding to the most slowly varying dimension
of the netCDF variable. imap[n-1] (where n is the rank of the netCDF
variable) gives the distance between elements of the internal array
corresponding to the most rapidly varying dimension of the netCDF
variable. Intervening imap elements correspond to other dimensions of
the netCDF variable in the obvious way. Distances between elements are
specified in type-independent units of elements (the distance between
internal elements that occupy adjacent memory locations is 1 and not
the element's byte-length as in netCDF 2).

@item buf
Pointer to the location used for computing where the data values are
read; the data should be of the type appropriate for the function
called. If the type of data value differs from the netCDF variable
type, type conversion will occur.
@c @xref{Type Conversion,,, pnetcdf, The PnetCDF Users Guide}.

@item bufcount
An integer indicates the number of MPI derived data type elements in the buf to be read from the file.

@item buftype
An MPI derived data type that describes the memory layout of buf.
Starting from PnetCDF version 1.6.0, buftype can be MPI_DATATYPE_NULL.
In this case, bufcount is ignored and the buf's data type must match the type
of the variable defined in the file - no data conversion will be done.

@end table

@heading Layout Illustration for Read Buffer in Memory and Data Read from File
@center @image{images/get_varm,,, get_varm mapping, png}

@heading Return Error Codes
ncmpi_get_varm_@var{<type>} returns the value NC_NOERR if no errors
occurred. Otherwise, the returned status indicates an error. Possible
causes of errors include:
@itemize
@item NC_EBADID: The specified netCDF ID does not refer to an opened netCDF file.
@item NC_ENOTVAR: The variable ID is invalid for the specified netCDF file.
@item NC_EGLOBAL: NC_GLOBAL is considered invalid for these APIs.
@item NC_EINVALCOORDS: The specified corner indices were out of range for the rank of the specified variable. For example, a negative index, or an index that is larger than the corresponding dimension length will cause an error.
@item NC_EEDGE: The specified edge lengths added to the specified corner would have referenced data out of range for the rank of the specified variable. For example, an edge length that is larger than the corresponding dimension length minus the corner index will cause an error.
@item NC_ERANGE: One or more elements of the external variable are out of the range of values representable by the internal data type of read buffer, buf. (Does not apply to the ncmpi_get_varm() and ncmpi_get_varm_all()).
@item NC_EINDEFINE: Operation not allowed in define mode.
@item NC_ECHAR: Attempt to convert numerical values to or from text data.
@item NC_ENOMEM: Out of memory.
@item NC_EINDEP: Attempt collective I/O operations in independent data mode.
@item NC_ENOTINDEP: Attempt independent I/O operations in collective data mode.
@item NC_EIOMISMATCH: The number of variable elements requested in (bufcount, buftype) mismatches the one calculated from count. This error may only occur for flexible APIs.
@item NC_ENOTSUPPORT: Flexible APIs for NetCDF-4 files is not yet supported.
@end itemize


@heading Example

The following imap vector maps in the trivial way a 4x3x2 netCDF
variable and an internal array of the same shape:

@example
float a[4][3][2];       /* same shape as netCDF variable */
MPI_Offset imap[3] = @{6, 2, 1@};
                        /* netCDF dimension       inter-element distance */
                        /* ----------------       ---------------------- */
                        /* most rapidly varying       1                  */
                        /* intermediate               2 (=imap[2]*2)     */
                        /* most slowly varying        6 (=imap[1]*3)     */
@end example

Using the imap vector above with ncmpi_get_varm_float_all obtains the same
result as simply using ncmpi_get_var_float.

Here is an example of using ncmpi_get_varm_float_all to transpose a netCDF
variable named rh which is described by the C declaration float
rh[6][4] (note the size and order of the dimensions):

@example
#include <pnetcdf.h>
   ...
#define NDIM 2               /* rank of netCDF variable */
int ncid;                    /* netCDF ID */
int status;                  /* error status */
int rhid;                    /* variable ID */
MPI_Offset start[NDIM]       /* netCDF variable start point: */
                 = @{0, 0@};   /* first element */
MPI_Offset count[NDIM]       /* size of internal array: entire netCDF */
                 = @{6, 4@};   /* variable; order corresponds to netCDF */
                             /* variable -- not internal array */
MPI_Offset stride[NDIM]      /* variable subsampling intervals: */
                 = @{1, 1@};   /* sample every netCDF element */
MPI_Offset imap[NDIM]        /* internal array inter-element distances; */
                 = @{1, 6@};   /* would be @{4, 1@} if not transposing */
float rh[4][6];              /* note transposition of netCDF variable */
                             /* dimensions */
   ...
status = @ref{ncmpi_open}(MPI_COMM_WORLD, "foo.nc", NC_WRITE, MPI_INFO_NULL,  &ncid);
if (status != NC_NOERR) handle_error(status);
   ...
status = @ref{ncmpi_inq_varid}(ncid, "rh", &rhid);
if (status != NC_NOERR) handle_error(status);
   ...
status = @ref{ncmpi_get_varm_@var{<type>}, ncmpi_get_varm_float_all}(ncid, rhid, start, count, stride, imap, rh);
if (status != NC_NOERR) handle_error(status);
@end example

Here is another example of using ncmpi_get_varm_float_all to simultaneously
transpose and subsample the same netCDF variable, by accessing every
other point of the netCDF variable:

@example
#include <pnetcdf.h>
   ...
#define NDIM 2               /* rank of netCDF variable */
int ncid;                    /* netCDF ID */
int status;                  /* error status */
int rhid;                    /* variable ID */
MPI_Offset start[NDIM]       /* netCDF variable start point: */
                 = @{0, 0@};   /* first element */
MPI_Offset count[NDIM]       /* size of internal array: entire */
                 = @{3, 2@};   /* (subsampled) netCDF variable; order of */
                             /* dimensions corresponds to netCDF */
                             /* variable -- not internal array */
MPI_Offset stride[NDIM]      /* variable subsampling intervals: */
                 = @{2, 2@};   /* sample every other netCDF element */
MPI_Offset imap[NDIM]        /* internal array inter-element distances; */
                 = @{1, 3@};   /* would be @{2, 1@} if not transposing */
float rh[2][3];              /* note transposition of (subsampled) */
                             /* netCDF variable dimensions */
   ...
status = @ref{ncmpi_open}(MPI_COMM_WORLD, "foo.nc", NC_WRITE, MPI_INFO_NULL,  &ncid);
if (status != NC_NOERR) handle_error(status);
   ...
status = @ref{ncmpi_inq_varid}(ncid, "rh", &rhid);
if (status != NC_NOERR) handle_error(status);
   ...
status = @ref{ncmpi_get_varm_@var{<type>}, ncmpi_get_varm_float_all}(ncid, rhid, start, count, stride, imap, rh);
if (status != NC_NOERR) handle_error(status);
@end example

@node ncmpi_get_varn_@var{<type>}, ncmpi_get_vard, ncmpi_get_varm_@var{<type>}, Variables
@section Read a List of Subarrays of Values: ncmpi_get_varn_@var{<type>}
@findex ncmpi_get_varn_text
@findex ncmpi_get_varn_uchar
@findex ncmpi_get_varn_schar
@findex ncmpi_get_varn_short
@findex ncmpi_get_varn_int
@findex ncmpi_get_varn_float
@findex ncmpi_get_varn_double
@findex ncmpi_get_varn_ushort
@findex ncmpi_get_varn_unit
@findex ncmpi_get_varn_longlong
@findex ncmpi_get_varn_ulonglong
@findex ncmpi_get_varn_text_all
@findex ncmpi_get_varn_uchar_all
@findex ncmpi_get_varn_schar_all
@findex ncmpi_get_varn_short_all
@findex ncmpi_get_varn_int_all
@findex ncmpi_get_varn_float_all
@findex ncmpi_get_varn_double_all
@findex ncmpi_get_varn_ushort_all
@findex ncmpi_get_varn_unit_all
@findex ncmpi_get_varn_longlong_all
@findex ncmpi_get_varn_ulonglong_all
@cindex ncmpi_get_varn_text, example
@cindex ncmpi_get_varn_uchar, example
@cindex ncmpi_get_varn_schar, example
@cindex ncmpi_get_varn_short, example
@cindex ncmpi_get_varn_int, example
@cindex ncmpi_get_varn_float, example
@cindex ncmpi_get_varn_double, example
@cindex ncmpi_get_varn_ushort, example
@cindex ncmpi_get_varn_unit, example
@cindex ncmpi_get_varn_longlong, example
@cindex ncmpi_get_varn_ulonglong, example
@cindex ncmpi_get_varn_text_all, example
@cindex ncmpi_get_varn_uchar_all, example
@cindex ncmpi_get_varn_schar_all, example
@cindex ncmpi_get_varn_short_all, example
@cindex ncmpi_get_varn_int_all, example
@cindex ncmpi_get_varn_float_all, example
@cindex ncmpi_get_varn_double_all, example
@cindex ncmpi_get_varn_ushort_all, example
@cindex ncmpi_get_varn_unit_all, example
@cindex ncmpi_get_varn_longlong_all, example
@cindex ncmpi_get_varn_ulonglong_all, example
@cindex reading list subarray section
@cindex list subarray section, writing
@cindex list subarray section, reading

The function ncmpi_get_varn_@var{<type>} reads a list of subarrays of a netCDF variable in an opened netCDF file.
The part of the netCDF variable to read is specified by giving a list of subarrays and each subarray is specified by a corner and a vector of edge lengths that refer to an array section of the netCDF variable.
For each subarray, the values to be read are associated with the netCDF variable by assuming that the last dimension of the netCDF variable varies fastest in the C interface.

This API essentially has the same effect of making multiple calls to ncmpi_get_vara_@var{<type>} with the same variable ID.

@heading Data types
@html
<table cellpadding="4" border="1">
<tr class="spacer" align=center>
    <td> &lt;<b>type  </b>&gt; for API names </td>
    <td> &lt;<b>C type</b>&gt; for API arguments </td>
</tr>
<tr align=center> <td>text     </td> <td>char             </td> </tr>
<tr align=center> <td>schar    </td> <td>signed char      </td> </tr>
<tr align=center> <td>short    </td> <td>short            </td> </tr>
<tr align=center> <td>int      </td> <td>int              </td> </tr>
<tr align=center> <td>float    </td> <td>float            </td> </tr>
<tr align=center> <td>double   </td> <td>double           </td> </tr>
<tr align=center> <td>uchar    </td> <td>unsigned char    </td> </tr>
<tr align=center> <td>ushort   </td> <td>unsigned short   </td> </tr>
<tr align=center> <td>uint     </td> <td>unsigned int     </td> </tr>
<tr align=center> <td>longlong </td> <td>long long        </td> </tr>
<tr align=center> <td>ulonglong</td> <td>unsigned longlong</td> </tr>
</table>
@end html

@heading Operational Mode
These API must be called while the file is in data mode.

@heading Collective I/O
The corresponding collective APIs have the suffix name "_all" and must be called in collective data mode.

@heading Usage
@example
int ncmpi_get_varn_@strong{<type>}     (int                ncid,
                               int                varid,
                               int                num,
                               MPI_Offset* const *starts, /* [num][ndims] */
                               MPI_Offset* const *counts, /* [num][ndims] */
                               @strong{<C type>}          *buf);

int ncmpi_get_varn            (int                ncid,
                               int                varid,
                               int                num,
                               MPI_Offset* const *starts, /* [num][ndims] */
                               MPI_Offset* const *counts, /* [num][ndims] */
                               void              *buf,
                               MPI_Offset         bufcount,
                               MPI_Datatype       buftype);

int ncmpi_get_varn_@strong{<type>}_all (int                ncid,
                               int                varid,
                               int                num,
                               MPI_Offset* const *starts, /* [num][ndims] */
                               MPI_Offset* const *counts, /* [num][ndims] */
                               @strong{<C type>}          *buf);

int ncmpi_get_varn_all        (int                ncid,
                               int                varid,
                               int                num,
                               MPI_Offset* const *starts, /* [num][ndims] */
                               MPI_Offset* const *counts, /* [num][ndims] */
                               void              *buf,
                               MPI_Offset         bufcount,
                               MPI_Datatype       buftype);
@end example

@table @code

@item ncid
NetCDF ID, from a previous call to ncmpi_open or ncmpi_create.

@item varid
Variable ID. Different MPI processes may use different variable IDs.

@item num
Nnumber of subarray requests.

@item starts
A double pointer that mimics a 2D array of size [num][ndims].
See below for example of how to allocate space and construct such a 2D array.
Each starts[i] is a vector specifying the index in the variable where the first of the data values will be read.
The indices are relative to 0, so for example, the first data value of a variable would have index (0, 0, ... , 0).
The size of starts must be [num][ndims], where ndims is the number of dimensions of the specified variable.
The elements of each starts[i] must correspond to the variable's dimensions in order.
Hence, if the variable is a record variable, the first index of each starts[i] would correspond to the starting record number for writing the data values.

@item counts
A double pointer that mimics a 2D array of size [num][ndims].
See below for example of how to allocate space and construct such a 2D array.
Each counts[i] is a vector specifying the edge lengths along each dimension of the block of data values to be read.
To write a single value, for example, specify count as (1, 1, ... , 1).
The size of counts should be [num][ndims], where ndims is the number of dimensions of the specified variable.
The elements of count correspond to the variable's dimensions.
Hence, if the variable is a record variable, the first element of each counts[i] corresponds to a count of the number of records to write.
This argument can be NULL, in which case it is equivalent to providing counts[*][*]=(1, 1, ... , 1).

@item buf
A pointer to the memory address that contains a buffer space to store the data values to be read from the opened file.
If the type of data values differs from the netCDF variable type, type conversion will occur.
@c @xref{Type Conversion,,, pnetcdf, The PnetCDF Users Guide}.

@item bufcount
An integer indicates the number of MPI derived data type elements to be read from the file and stored in the buffer pointed by buf.

@item buftype
An MPI derived data type that describes the memory layout of buf.
Starting from PnetCDF version 1.6.0, buftype can be MPI_DATATYPE_NULL.
In this case, bufcount is ignored and the buf's data type must match the type
of the variable defined in the file - no data conversion will be done.

@end table

@heading Layout Illustration for Read Buffer in Memory and Data in File to be Read
@center @image{images/get_varn,,, get_varn mapping, png}

@heading Return Error Codes
ncmpi_get_varn_@var{<type>} returns the value NC_NOERR if no errors
occurred. Otherwise, the returned status indicates an error. Possible
causes of errors include:
@itemize
@item NC_EBADID: The specified netCDF ID does not refer to an opened netCDF file.
@item NC_ENOTVAR: The variable ID is invalid for the specified netCDF file.
@item NC_EGLOBAL: NC_GLOBAL is considered invalid for these APIs.
@item NC_EINVALCOORDS: The specified corner indices were out of range for the rank of the specified variable. For example, a negative index, or an index that is larger than the corresponding dimension length will cause an error.
@item NC_EEDGE: The specified edge lengths added to the specified corner would have referenced data out of range for the rank of the specified variable. For example, an edge length that is larger than the corresponding dimension length minus the corner index will cause an error.
@item NC_ERANGE: One or more elements of the external variable are out of the range of values representable by the internal data type of read buffer, buf. (Does not apply to the ncmpi_get_varn() and ncmpi_get_varn_all()).
@item NC_EINDEFINE: Operation not allowed in define mode.
@item NC_ECHAR: Attempt to convert numerical values to or from text data.
@item NC_ENOMEM: Out of memory.
@item NC_ENULLSTART: It is illegal for argument starts being a NULL.
@item NC_EINDEP: Attempt collective I/O operations in independent data mode.
@item NC_ENOTINDEP: Attempt independent I/O operations in collective data mode.
@item NC_EIOMISMATCH: The number of variable elements requested in (bufcount, buftype) mismatches the one calculated from counts. This error may only occur for flexible APIs.
@item NC_ENOTSUPPORT: This API for NetCDF-4 files is not yet supported.
@end itemize


@heading Example

This example shows how to use a single call of ncmpi_get_varn_float_all()
to read a sequence of requests with arbitrary array indices.

@example
#include <pnetcdf.h>
    ...
#define MAX_NUM_REQS 6
#define NDIMS        2

int  i, j;
int  rank;                         /* MPI process rank ID */
int  err;                          /* error status */
int  ncid;                         /* netCDF ID */
int  varid;                        /* variable ID */
int  num_reqs;                     /* number of subarray requests */
int  dimid[2];                     /* dimension IDs */
int  buf_len;                      /* number of elements in buffer */
float *buffer;                     /* read buffer to hold values */
MPI_Offset **starts, **counts;
    ...
MPI_Comm_rank(MPI_COMM_WORLD, &rank);

err = @ref{ncmpi_open}(MPI_COMM_WORLD, "foo.nc", NC_NOWRITE, MPI_INFO_NULL, &ncid);
if (err != NC_NOERR) handle_error(err);

/* allocate starts and counts */
starts    = (MPI_Offset**) malloc(MAX_NUM_REQS*       sizeof(MPI_Offset*));
starts[0] = (MPI_Offset*)  calloc(MAX_NUM_REQS*NDIMS, sizeof(MPI_Offset));
for (i=1; i<MAX_NUM_REQS; i++)
    starts[i] = starts[i-1] + NDIMS;

counts    = (MPI_Offset**) malloc(MAX_NUM_REQS*       sizeof(MPI_Offset*));
counts[0] = (MPI_Offset*)  calloc(MAX_NUM_REQS*NDIMS, sizeof(MPI_Offset));
for (i=1; i<MAX_NUM_REQS; i++)
    counts[i] = counts[i-1] + NDIMS;

if (rank == 0) @{
    num_reqs = 4;
    starts[0][0] = 0; starts[0][1] = 5; counts[0][0] = 1; counts[0][1] = 2;
    starts[1][0] = 1; starts[1][1] = 0; counts[1][0] = 1; counts[1][1] = 1;
    starts[2][0] = 2; starts[2][1] = 6; counts[2][0] = 1; counts[2][1] = 2;
    starts[3][0] = 3; starts[3][1] = 0; counts[3][0] = 1; counts[3][1] = 3;
    /* rank 0 is reading the following locations: ("-" means skip)
              -  -  -  -  -  0  0  -  -  -
              0  -  -  -  -  -  -  -  -  -
              -  -  -  -  -  -  0  0  -  -
              0  0  0  -  -  -  -  -  -  -
     */
@} else if (rank == 1) @{
    num_reqs = 6;
    starts[0][0] = 0; starts[0][1] = 3; counts[0][0] = 1; counts[0][1] = 2;
    starts[1][0] = 0; starts[1][1] = 8; counts[1][0] = 1; counts[1][1] = 2;
    starts[2][0] = 1; starts[2][1] = 5; counts[2][0] = 1; counts[2][1] = 2;
    starts[3][0] = 2; starts[3][1] = 0; counts[3][0] = 1; counts[3][1] = 2;
    starts[4][0] = 2; starts[4][1] = 8; counts[4][0] = 1; counts[4][1] = 2;
    starts[5][0] = 3; starts[5][1] = 4; counts[5][0] = 1; counts[5][1] = 3;
    /* rank 1 is reading the following locations: ("-" means skip)
              -  -  -  1  1  -  -  -  1  1
              -  -  -  -  -  1  1  -  -  -
              1  1  -  -  -  -  -  -  1  1
              -  -  -  -  1  1  1  -  -  -
    */
@} else if (rank == 2) @{
    num_reqs = 5;
    starts[0][0] = 0; starts[0][1] = 7; counts[0][0] = 1; counts[0][1] = 1;
    starts[1][0] = 1; starts[1][1] = 1; counts[1][0] = 1; counts[1][1] = 3;
    starts[2][0] = 1; starts[2][1] = 7; counts[2][0] = 1; counts[2][1] = 3;
    starts[3][0] = 2; starts[3][1] = 2; counts[3][0] = 1; counts[3][1] = 1;
    starts[4][0] = 3; starts[4][1] = 3; counts[4][0] = 1; counts[4][1] = 1;
    /* rank 2 is reading the following locations: ("-" means skip)
              -  -  -  -  -  -  -  2  -  -
              -  2  2  2  -  -  -  2  2  2
              -  -  2  -  -  -  -  -  -  -
              -  -  -  2  -  -  -  -  -  -
     */
@} else if (rank == 3) @{
    num_reqs = 4;
    starts[0][0] = 0; starts[0][1] = 0; counts[0][0] = 1; counts[0][1] = 3;
    starts[1][0] = 1; starts[1][1] = 4; counts[1][0] = 1; counts[1][1] = 1;
    starts[2][0] = 2; starts[2][1] = 3; counts[2][0] = 1; counts[2][1] = 3;
    starts[3][0] = 3; starts[3][1] = 7; counts[3][0] = 1; counts[3][1] = 3;
    /* rank 3 is reading the following locations: ("-" means skip)
              3  3  3  -  -  -  -  -  -  -
              -  -  -  -  3  -  -  -  -  -
              -  -  -  3  3  3  -  -  -  -
              -  -  -  -  -  -  -  3  3  3
     */
@} else @{
    num_reqs = 0;
@}

/* allocate read buffer */
buf_len = 0;
for (i=0; i<num_reqs; i++) @{
    MPI_Offset r_req_len=1;
    for (j=0; j<NDIMS; j++)
        r_req_len *= counts[i][j];
    buf_len += r_req_len;
@}
buffer = (float*) malloc(buf_len * sizeof(float));

/* reads values into netCDF variable */
err = @ref{ncmpi_get_varn_@var{<type>}, ncmpi_get_varn_float_all}(ncid, varid, num_reqs, starts, counts, buffer);
if (err != NC_NOERR) handle_error(err);
    ...

err = @ref{ncmpi_close}(ncid);
if (err != NC_NOERR) handle_error(err);

/*    % ncmpidump foo.nc
 *    netcdf foo @{
 *    dimensions:
 *             Y = 4 ;
 *             X = 10 ;
 *    variables:
 *             float var(Y, X) ;
 *    data:
 *
 *     var =
 *       3, 3, 3, 1, 1, 0, 0, 2, 1, 1,
 *       0, 2, 2, 2, 3, 1, 1, 2, 2, 2,
 *       1, 1, 2, 3, 3, 3, 0, 0, 1, 1,
 *       0, 0, 0, 2, 1, 1, 1, 3, 3, 3 ;
 *    @}
 */
@end example

@node ncmpi_get_vard, Strings, ncmpi_get_varn_@var{<type>}, Variables
@section Read an Array of Values using filetype: ncmpi_get_vard
@findex ncmpi_get_vard
@findex ncmpi_get_vard_all
@cindex ncmpi_get_vard, example
@cindex ncmpi_get_vard_all, example
@cindex reading array section
@cindex array section, reading

The function ncmpi_get_vard reads values from a netCDF variable of
an opened netCDF file. The part of the netCDF variable to read is
specified by an MPI derived data type whose flattened displacements are
relative to the beginning file offset of the variable.

@heading Operational Mode
These API must be called while the file is in data mode.

@heading Collective I/O
The corresponding collective APIs have the suffix name "_all" and must be called in collective data mode.

@heading Usage
@example
int ncmpi_get_vard     (int           ncid,
                        int           varid,
                        MPI_Datatype  filetype,
                        void         *buf,
                        MPI_Offset    bufcount,
                        MPI_Datatype  buftype);

int ncmpi_get_vard_all (int           ncid,
                        int           varid,
                        MPI_Datatype  filetype,
                        void         *buf,
                        MPI_Offset    bufcount,
                        MPI_Datatype  buftype);
@end example

@table @code

@item ncid
NetCDF ID, from a previous call to ncmpi_open or ncmpi_create.

@item varid
Variable ID.
Starting from version 1.10.0, filetype argument may cover more than one
variable. In this case, varid is the ID of the first variable.  However,
variables accessed by filetype must be either all fixed-size variables or all
record variables. In addition, the variables accessed by filetype must be of
the same external NC data type. Thie limitation allows the same data type
conversion to perform on the entire read buffer. When calling the collective
ncmpi_get_vard_all(), different MPI processes may use different variable IDs,
ncid.

@item filetype
An MPI derived data type that describes the file access layout. The element
datatype that is used to construct filetype must conformed with the external NC
data type of the variable defined in the file, i.e. MPI_FLOAT being used to
construct filetype vs. NC_FLOAT being the NC data type of the variable(s).
Starting from version 1.10.0, filetype may cover more than one variable. In
this case, all variables accessed by the filetype must be of the same NC data
type.
@comment For fixed-size variables, the size of filetype must be smaller or equal to the variable size. PnetCDF checks the lower and upper bounds of filetype and throws error NC_ETYPESIZE if extent of filetype goes beyond of the variable's boundary.
For record variables, accessing more than one record is possible. One might
need the size of record block (i.e. the sum of single records of all record
variables defined in the file) which can be obtained from a call to
@ref{ncmpi_inq Family, ncmpi_inq_recsize}.
@comment Note PnetCDF does not check the access extent for record variables. Users should use a filetype whose extent is within the record boundaries of the variable.
In addition, filetype must meet the following MPI-IO requirement specified in
MPI standard Chapter 13.3.
File displacements of filetype must be non-negative and in a monotonically
nondecreasing order.
@comment If the file is opened for writing, filetype is not permitted to contain overlapping regions.
It is fine for filetype to be MPI_DATATYPE_NULL, which indicates a zero-length
read request.
For independent APIs, a zero-length request is returned immediately.
For collective APIs, the process with a zero-length request will still proceed
to participate the collective MPI operations inside the PnetCDF library.

@item buf
Pointer to the read buffer.

@item bufcount
An integer indicates the number of MPI derived data type elements in the buf to
be read from the file. This argument is ignored if buftype is MPI_DATATYPE_NULL.

@item buftype
An MPI derived data type that describes the memory layout of buf.
There can only be a single element data type contained in buftype.
It is fine for buftype to be MPI_DATATYPE_NULL, which indicates the read
buffer is contiguous and its amount is equal to the size of filetype.
In this case, argument bufcount is ignored and users must ensure the
memory space pointed by argument buf is at least of size of filetype.

@end table

@heading Return Error Codes
ncmpi_get_vard returns the value NC_NOERR if no errors
occurred. Otherwise, the returned status indicates an error. Possible
causes of errors include:
@itemize
@item NC_EBADID: The specified netCDF ID does not refer to an opened netCDF file.
@item NC_EINDEP: Attempt collective I/O operations in independent data mode.
@item NC_ENOTINDEP: Attempt independent I/O operations in collective data mode.
@item NC_EINDEFINE: Operation not allowed in define mode.
@item NC_ENOTVAR: Bad varid, variable not found.
@item NC_EGLOBAL: NC_GLOBAL is considered invalid for these APIs.
@comment @item NC_ETYPESIZE: for non-record variables, filetype's extent is beyond the variable's boundaries.
@item NC_EMULTITYPES: Multiple different MPI element datatypes used in filetype or buftype.
@item NC_ETYPE_MISMATCH: filetype's element type mismatches the variable's NC data type.
@item NC_EIOMISMATCH: the number of element data types in filetype is not equal to (buftype * bufcount).
@item NC_ENOTSUPPORT: This API for NetCDF-4 files is not yet supported.
@end itemize

@heading Example

Here is an example using ncmpi_get_vard.

@example
#include <pnetcdf.h>
   ...
#define NY 2
#define NX 5

MPI_Offset start[2], count[2];
int array_of_sizes[2], array_of_subsizes[2], array_of_starts[2];
int buf[NY][NX];
MPI_Datatype filetype;
    ...

MPI_Comm_size(MPI_COMM_WORLD, &nprocs);
MPI_Comm_rank(MPI_COMM_WORLD, &rank);

/* create an MPI derived data type */
array_of_sizes[0]    = 2;
array_of_sizes[1]    = NX*nprocs;
array_of_subsizes[0] = 2;
array_of_subsizes[1] = NX;
array_of_starts[0]   = 0;
array_of_starts[1]   = NX*rank;
MPI_Type_create_subarray(2, array_of_sizes, array_of_subsizes,
                         array_of_starts, MPI_ORDER_C,
                         MPI_INT, &filetype);
MPI_Type_commit(&filetype);

err = @ref{ncmpi_get_vard, ncmpi_get_vard_all}(ncid, varid, filetype, buf, 2*NX, MPI_INT);
if (err != NC_NOERR) handle_error(err);
@end example

@heading Full example C program
@itemize
@item
@url{https://github.com/Parallel-NetCDF/PnetCDF/tree/master/examples/C/vard_int.c, vard_int.c}
@item
@url{https://github.com/Parallel-NetCDF/PnetCDF/tree/master/examples/C/vard_mvars.c, vard_mvars.c}
@item
The above programs are available in all PnetCDF releases under directory examples/C.
@end itemize

@node Strings, Fill Values, ncmpi_get_vard, Variables
@section Reading and Writing Character String Values
@cindex attributes, character string
@cindex byte, zero
@cindex zero byte
@cindex writing character-string data
@cindex character-string data, writing

Character strings are not a primitive netCDF external data type, in
part because FORTRAN does not support the abstraction of
variable-length character strings (the FORTRAN LEN function returns
the static length of a character string, not its dynamic length). As a
result, a character string cannot be written or read as a single
object in the PnetCDF interface. Instead, a character string must be
treated as an array of characters, and array access must be used to
read and write character strings as variable data in netCDF
files. Furthermore, variable-length strings are not supported by
the PnetCDF interface except by convention; for example, you may treat
a zero byte as terminating a character string, but you must explicitly
specify the length of strings to be read from and written to netCDF
variables.

Character strings as attribute values are easier to use, since the
strings are treated as a single unit for access. However, the value of
a character-string attribute is still an array of characters with an
explicit length that must be specified when the attribute is defined.

When you define a variable that will have character-string values, use
a character-position dimension as the most quickly varying dimension
for the variable (the last dimension for the variable in C). The
length of the character-position dimension will be the maximum string
length of any value to be stored in the character-string
variable. Space for maximum-length strings will be allocated in the
disk representation of character-string variables whether you use the
space or not. If two or more variables have the same maximum length,
the same character-position dimension may be used in defining the
variable shapes.

To write a character-string value into a character-string variable,
use either entire variable access or array access. The latter requires
that you specify both a corner and a vector of edge lengths. The
character-position dimension at the corner should be zero for C. If
the length of the string to be written is n, then the vector of edge
lengths will specify n in the character-position dimension, and one
for all the other dimensions:(1, 1, ... , 1, n).

In C, fixed-length strings may be written to a netCDF file without
the terminating zero byte, to save space. Variable-length strings
should be written with a terminating zero byte so that the intended
length of the string can be determined when it is later read.

Here is an example that defines a record variable, tx, for character
strings and stores a character-string value into the third record
using ncmpi_put_vara_text. In this example, we assume the string variable
and data are to be added to an existing netCDF file named foo.nc
that already has an unlimited record dimension time.

@example
#include <pnetcdf.h>
   ...
int  ncid;            /* netCDF ID */
int  chid;            /* dimension ID for char positions */
int  timeid;          /* dimension ID for record dimension */
int  tx_id;           /* variable ID */
#define TDIMS 2       /* rank of tx variable */
int tx_dims[TDIMS];   /* variable shape */
MPI_Offset tx_start[TDIMS];
MPI_Offset tx_count[TDIMS];
char tx_val[] = "example string"; /* string to be put */
   ...
status = @ref{ncmpi_open}(MPI_COMM_WORLD, "foo.nc", NC_WRITE, MPI_INFO_NULL,  &ncid);
if (status != NC_NOERR) handle_error(status);
status = @ref{ncmpi_redef}(ncid);       /* enter define mode */
if (status != NC_NOERR) handle_error(status);
   ...
/* define character-position dimension for strings of max length 40 */
status = @ref{ncmpi_def_dim}(ncid, "chid", 40L, &chid);
if (status != NC_NOERR) handle_error(status);
   ...
/* define a character-string variable */
tx_dims[0] = timeid;
tx_dims[1] = chid;    /* character-position dimension last */
status = @ref{ncmpi_def_var}(ncid, "tx", NC_CHAR, TDIMS, tx_dims, &tx_id);
if (status != NC_NOERR) handle_error(status);
   ...
status = @ref{ncmpi_enddef}(ncid);       /* leave define mode */
if (status != NC_NOERR) handle_error(status);
   ...
/* write tx_val into tx netCDF variable in record 3 */
tx_start[0] = 3;      /* record number to write */
tx_start[1] = 0;      /* start at beginning of variable */
tx_count[0] = 1;      /* only write one record */
tx_count[1] = strlen(tx_val) + 1;  /* number of chars to write */
status = @ref{ncmpi_put_vara_@var{<type>}, ncmpi_put_vara_text}(ncid, tx_id, tx_start, tx_count, tx_val);
if (status != NC_NOERR) handle_error(status);
@end example

@node Fill Values, ncmpi_rename_var, Strings, Variables
@section Fill Values
@cindex fill values
@cindex byte vs. char fill values

Prior to version 1.6.1, PnetCDF supports only NC_NOFILL mode.
Starting from 1.6.1, PnetCDF supports fill mode in a slightly different
way from netCDF.

What happens when you try to read a value that was never written in an
opened netCDF file? You might expect that this should always be an
error, and that you should get an error message or an error status
returned. You do get an error if you try to read data from a netCDF
file that is not open for reading, if the variable ID is invalid
for the specified netCDF file, or if the specified indices are not
properly within the range defined by the dimension lengths of the
specified variable. Otherwise, reading a value that was not written
returns a special fill value used to fill in any undefined values when
a netCDF variable is first written.

You may ignore fill values and use the entire range of a netCDF
external data type, but in this case you should make sure you write
all data values before reading them. If you know you will be writing
all the data before reading it, you can specify that no pre-filling of
variables with fill values will occur by calling ncmpi_def_var_fill
after defining a non-record variable.

@heading Differences from NetCDF
@itemize

@item @strong{Default fill mode} --
PnetCDF's default mode is NC_NOFILL, while netCDF's is NC_FILL.

@item @strong{Filling a record variable} --
In PnetCDF, filling a record variable must be requested by calling
@ref{ncmpi_fill_var_rec} explicitly in the data mode, prior to write a
new record. This API will fill only one record of a record variable.
It will overwrite the contents of the record if the contents
are previously written.
@end itemize

The variable attribute _FillValue may be used to specify the fill
value for a variable. Their are default fill values for each type,
defined in the include file pnetcdf.h: NC_FILL_CHAR, NC_FILL_BYTE,
NC_FILL_SHORT, NC_FILL_INT, NC_FILL_FLOAT, and NC_FILL_DOUBLE.
For CDF-5 file format, more default fill values are available
for additional data types: NC_FILL_UBYTE, NC_FILL_USHORT,
NC_FILL_UINT, NC_FILL_INT64, and NC_FILL_UINT64.

The netCDF byte and character types have different default fill
values. The default fill value for characters is the zero byte, a
useful value for detecting the end of variable-length C character
strings. If you need a fill value for a byte variable, it is
recommended that you explicitly define an appropriate _FillValue
attribute, as generic utilities such as ncmpidump/ncdump will not assume a
default fill value for byte variables.

Type conversion for fill values is identical to type conversion for
other values: attempting to convert a value from one type to another
type that can't represent the value results in a range error. Such
errors may occur on writing or reading values from a larger type (such
as double) to a smaller type (such as float), if the fill value for
the larger type cannot be represented in the smaller type.

@node ncmpi_rename_var, ncmpi_iput_var@var{<kind>}_@var{<type>} , Fill Values, Variables
@section Rename a Variable: ncmpi_rename_var
@findex ncmpi_rename_var
@cindex ncmpi_rename_var, example
@cindex renaming variable
@cindex variable, renaming

The function ncmpi_rename_var changes the name of a netCDF variable in an
opened netCDF file.
It is illegal to rename a variable to the name of any existing variable.

@heading Operational Mode
This API is a collective subroutine, argument newname must be consistent among all calling processes.

If the new name is longer than the old name, the netCDF file must be in define mode. Otherwise, it can be called in either define or data mode.

@heading Usage
@example
int ncmpi_rename_var(int         ncid,
                     int         varid,
                     const char *newname);
@end example

@table @code
@item ncid
 NetCDF ID, from a previous call to ncmpi_open or ncmpi_create.

@item varid
 Variable ID. This value must be consistent across all calling MPI processes.

@item newname
 New name for the specified variable.

@end table

@heading Return Error Codes
ncmpi_rename_var returns the value NC_NOERR if no errors
occurred. Otherwise, the returned status indicates an error. Possible
causes of errors include:
@itemize
@item NC_EBADID: The specified netCDF ID does not refer to an opened netCDF file.
@item NC_EPERM: Attempt write operations in read-only file.
@item NC_ENOTVAR: The variable ID is invalid for the specified netCDF file.
@item NC_EGLOBAL: NC_GLOBAL is considered invalid for this API.
@item NC_EBADNAME: Name contains illegal characters.
@item NC_ENAMEINUSE: The new name is in use as the name of another variable.
@item NC_ENOTINDEFINE: Must in define mode when newname is longer.
@item NC_EMAXNAME: NC_MAX_NAME exceeded.
@item NC_EMULTIDEFINE_VAR_NAME: Variable name is inconsistent among processes.
@item NC_EMULTIDEFINE_FNC_ARGS: Inconsistent function arguments used in collective API.
@end itemize

@heading Example

Here is an example using ncmpi_rename_var to rename the variable rh to
rel_hum in an existing netCDF file named foo.nc:

@example
#include <pnetcdf.h>
   ...
int  status;              /* error status */
int  ncid;                /* netCDF ID */
int  rh_id;               /* variable ID */
   ...
status = @ref{ncmpi_open}(MPI_COMM_WORLD, "foo.nc", NC_WRITE, MPI_INFO_NULL,  &ncid);
if (status != NC_NOERR) handle_error(status);
   ...
status = @ref{ncmpi_redef}(ncid);  /* put in define mode to rename variable */
if (status != NC_NOERR) handle_error(status);
status = @ref{ncmpi_inq_varid}(ncid, "rh", &rh_id);
if (status != NC_NOERR) handle_error(status);
status = @ref{ncmpi_rename_var}(ncid, rh_id, "rel_hum");
if (status != NC_NOERR) handle_error(status);
status = @ref{ncmpi_enddef}(ncid); /* leave define mode */
if (status != NC_NOERR) handle_error(status);
@end example

@node ncmpi_iput_var@var{<kind>}_@var{<type>}, ncmpi_iget_var@var{<kind>}_@var{<type>}, ncmpi_rename_var, Variables
@section Nonblocking Write a Subarray: ncmpi_iput_@var{<kind>}_@var{<type>}
@findex ncmpi_iput_var1_text
@findex ncmpi_iput_var1_uchar
@findex ncmpi_iput_var1_schar
@findex ncmpi_iput_var1_short
@findex ncmpi_iput_var1_int
@findex ncmpi_iput_var1_float
@findex ncmpi_iput_var1_double
@findex ncmpi_iput_var1_ushort
@findex ncmpi_iput_var1_unit
@findex ncmpi_iput_var1_longlong
@findex ncmpi_iput_var1_ulonglong
@findex ncmpi_iput_var_text
@findex ncmpi_iput_var_uchar
@findex ncmpi_iput_var_schar
@findex ncmpi_iput_var_short
@findex ncmpi_iput_var_int
@findex ncmpi_iput_var_float
@findex ncmpi_iput_var_double
@findex ncmpi_iput_var_ushort
@findex ncmpi_iput_var_unit
@findex ncmpi_iput_var_longlong
@findex ncmpi_iput_var_ulonglong
@findex ncmpi_iput_vara_text
@findex ncmpi_iput_vara_uchar
@findex ncmpi_iput_vara_schar
@findex ncmpi_iput_vara_short
@findex ncmpi_iput_vara_int
@findex ncmpi_iput_vara_float
@findex ncmpi_iput_vara_double
@findex ncmpi_iput_vara_ushort
@findex ncmpi_iput_vara_unit
@findex ncmpi_iput_vara_longlong
@findex ncmpi_iput_vara_ulonglong
@findex ncmpi_iput_vars_text
@findex ncmpi_iput_vars_uchar
@findex ncmpi_iput_vars_schar
@findex ncmpi_iput_vars_short
@findex ncmpi_iput_vars_int
@findex ncmpi_iput_vars_float
@findex ncmpi_iput_vars_double
@findex ncmpi_iput_vars_ushort
@findex ncmpi_iput_vars_unit
@findex ncmpi_iput_vars_longlong
@findex ncmpi_iput_vars_ulonglong
@findex ncmpi_iput_varm_text
@findex ncmpi_iput_varm_uchar
@findex ncmpi_iput_varm_schar
@findex ncmpi_iput_varm_short
@findex ncmpi_iput_varm_int
@findex ncmpi_iput_varm_float
@findex ncmpi_iput_varm_double
@findex ncmpi_iput_varm_ushort
@findex ncmpi_iput_varm_unit
@findex ncmpi_iput_varm_longlong
@findex ncmpi_iput_varm_ulonglong
@cindex ncmpi_iput_var1_text, example
@cindex ncmpi_iput_var1_uchar, example
@cindex ncmpi_iput_var1_schar, example
@cindex ncmpi_iput_var1_short, example
@cindex ncmpi_iput_var1_int, example
@cindex ncmpi_iput_var1_float, example
@cindex ncmpi_iput_var1_double, example
@cindex ncmpi_iput_var1_ushort, example
@cindex ncmpi_iput_var1_unit, example
@cindex ncmpi_iput_var1_longlong, example
@cindex ncmpi_iput_var1_ulonglong, example
@cindex ncmpi_iput_var_text, example
@cindex ncmpi_iput_var_uchar, example
@cindex ncmpi_iput_var_schar, example
@cindex ncmpi_iput_var_short, example
@cindex ncmpi_iput_var_int, example
@cindex ncmpi_iput_var_float, example
@cindex ncmpi_iput_var_double, example
@cindex ncmpi_iput_var_ushort, example
@cindex ncmpi_iput_var_unit, example
@cindex ncmpi_iput_var_longlong, example
@cindex ncmpi_iput_var_ulonglong, example
@cindex ncmpi_iput_vara_text, example
@cindex ncmpi_iput_vara_uchar, example
@cindex ncmpi_iput_vara_schar, example
@cindex ncmpi_iput_vara_short, example
@cindex ncmpi_iput_vara_int, example
@cindex ncmpi_iput_vara_float, example
@cindex ncmpi_iput_vara_double, example
@cindex ncmpi_iput_vara_ushort, example
@cindex ncmpi_iput_vara_unit, example
@cindex ncmpi_iput_vara_longlong, example
@cindex ncmpi_iput_vara_ulonglong, example
@cindex ncmpi_iput_vars_text, example
@cindex ncmpi_iput_vars_uchar, example
@cindex ncmpi_iput_vars_schar, example
@cindex ncmpi_iput_vars_short, example
@cindex ncmpi_iput_vars_int, example
@cindex ncmpi_iput_vars_float, example
@cindex ncmpi_iput_vars_double, example
@cindex ncmpi_iput_vars_ushort, example
@cindex ncmpi_iput_vars_unit, example
@cindex ncmpi_iput_vars_longlong, example
@cindex ncmpi_iput_vars_ulonglong, example
@cindex ncmpi_iput_varm_text, example
@cindex ncmpi_iput_varm_uchar, example
@cindex ncmpi_iput_varm_schar, example
@cindex ncmpi_iput_varm_short, example
@cindex ncmpi_iput_varm_int, example
@cindex ncmpi_iput_varm_float, example
@cindex ncmpi_iput_varm_double, example
@cindex ncmpi_iput_varm_ushort, example
@cindex ncmpi_iput_varm_unit, example
@cindex ncmpi_iput_varm_longlong, example
@cindex ncmpi_iput_varm_ulonglong, example
@cindex nonblocking write a subarray
@cindex nonblocking, write a subarray

The ncmpi_iput_var@var{<kind>}_@var{<type>} family of functions is the
nonblocking version of the write functions. The nonblocking APIs have an
additional argument, @var{request}. It can be used later to query the status of
the put operation or wait for the write to complete.

A nonblocking put call indicates that the PnetCDF may start using (possible
altering the contents of) the put buffer. The caller should not access any part
of the put buffer after a nonblocking put is called, until the put completes.

@var{<kind>}: <none>, '1', 'a', 's', or 'm'.

@heading Data types
@html
<table cellpadding="4" border="1">
<tr class="spacer" align=center>
    <td> &lt;<b>type  </b>&gt; for API names </td>
    <td> &lt;<b>C type</b>&gt; for API arguments </td>
</tr>
<tr align=center> <td>text     </td> <td>char             </td> </tr>
<tr align=center> <td>schar    </td> <td>signed char      </td> </tr>
<tr align=center> <td>short    </td> <td>short            </td> </tr>
<tr align=center> <td>int      </td> <td>int              </td> </tr>
<tr align=center> <td>float    </td> <td>float            </td> </tr>
<tr align=center> <td>double   </td> <td>double           </td> </tr>
<tr align=center> <td>uchar    </td> <td>unsigned char    </td> </tr>
<tr align=center> <td>ushort   </td> <td>unsigned short   </td> </tr>
<tr align=center> <td>uint     </td> <td>unsigned int     </td> </tr>
<tr align=center> <td>longlong </td> <td>long long        </td> </tr>
<tr align=center> <td>ulonglong</td> <td>unsigned longlong</td> </tr>
</table>
@end html

@heading Operational Mode
Prior to version 1.7.0, nonblocking APIs must be called while the netCDF file is in data mode.
Starting from 1.7.0, nonblocking APIs can be called in either define or data mode.
This API family can be called in either collective or independent data mode.

@heading Usage
@example
int ncmpi_iput_var_@strong{<type>}  (int               ncid,
                            int                varid,
                            const @strong{<C type>}   *buf,
                            int               *request);

int ncmpi_iput_var1_@strong{<type>} (int               ncid,
                            int                varid,
                            const MPI_Offset   start[],
                            const @strong{<C type>}   *buf,
                            int               *request);

int ncmpi_iput_vara_@strong{<type>} (int               ncid,
                            int                varid,
                            const MPI_Offset   start[],
                            const MPI_Offset   count[],
                            const @strong{<C type>}   *buf,
                            int               *request);

int ncmpi_iput_vars_@strong{<type>} (int               ncid,
                            int                varid,
                            const MPI_Offset   start[],
                            const MPI_Offset   count[],
                            const MPI_Offset   stride[],
                            const @strong{<C type>}   *buf,
                            int               *request);

int ncmpi_iput_varm_@strong{<type>} (int               ncid,
                            int                varid,
                            const MPI_Offset   start[],
                            const MPI_Offset   count[],
                            const MPI_Offset   stride[],
                            const MPI_Offset   imap[],
                            const @strong{<C type>}   *buf,
                            int               *request);
@end example
Flexible APIs:
@example
int ncmpi_iput_var  (int                ncid,
                     int                varid,
                     const void         *buf,
                     MPI_Offset         bufcount,
                     MPI_Datatype       buftype,
                     int               *request);

int ncmpi_iput_var1 (int                ncid,
                     int                varid,
                     const MPI_Offset   start[],
                     const void        *buf,
                     MPI_Offset         bufcount,
                     MPI_Datatype       buftype,
                     int               *request);

int ncmpi_iput_vara (int                ncid,
                     int                varid,
                     const MPI_Offset   start[],
                     const MPI_Offset   count[],
                     const void        *buf,
                     MPI_Offset         bufcount,
                     MPI_Datatype       buftype,
                     int               *request);

int ncmpi_iput_vars (int                ncid,
                     int                varid,
                     const MPI_Offset   start[],
                     const MPI_Offset   count[],
                     const MPI_Offset   stride[],
                     const void        *buf,
                     MPI_Offset         bufcount,
                     MPI_Datatype       buftype,
                     int               *request);

int ncmpi_iput_varm (int                ncid,
                     int                varid,
                     const MPI_Offset   start[],
                     const MPI_Offset   count[],
                     const MPI_Offset   stride[],
                     const MPI_Offset   imap[],
                     const void        *buf,
                     MPI_Offset         bufcount,
                     MPI_Datatype       buftype,
                     int               *request);
@end example

@table @code

@item ncid
NetCDF ID, from a previous call to ncmpi_open or ncmpi_create.

@item varid
Variable ID. Different MPI processes may use different variable IDs.

@item start
A vector of MPI_Offset integers specifying the index in the variable
where the first of the data values will be written. The indices are
relative to 0, so for example, the first data value of a variable
would have index (0, 0, ... , 0). The elements of start correspond, in
order, to the variable's dimensions. Hence, if the variable is a
record variable, the first index corresponds to the starting record
number for writing the data values.

@item count
A vector of MPI_Offset integers specifying the number of indices selected
along each dimension. To write a single value, for example, specify
count as (1, 1, ... , 1). The elements of count correspond, in order,
to the variable's dimensions. Hence, if the variable is a record
variable, the first element of count corresponds to a count of the
number of records to write.

@item stride
A vector of MPI_Offset integers that specifies the sampling interval
along each dimension of the netCDF variable. The elements of the
stride vector correspond, in order, to the netCDF variable's
dimensions (stride[0] gives the sampling interval along the most
slowly varying dimension of the netCDF variable). Sampling intervals
are specified in type-independent units of elements (a value of 1
selects consecutive elements of the netCDF variable along the
corresponding dimension, a value of 2 selects every other element,
etc.). A NULL stride argument is treated as (1, 1, ... , 1).

@item imap
A vector of MPI_Offset integers that specifies the mapping between the
dimensions of a netCDF variable and the in-memory structure of the
internal data array. The elements of the index mapping vector
correspond, in order, to the netCDF variable's dimensions (imap[0]
gives the distance between elements of the internal array
corresponding to the most slowly varying dimension of the netCDF
variable). Distances between elements are specified in
type-independent units of elements (the distance between internal
elements that occupy adjacent memory locations is 1 and not the
element's byte-length as in netCDF 2). A NULL argument means the
memory-resident values have the same structure as the associated
netCDF variable.

@item buf
Pointer to the location used for computing where the data values will
be found; the data should be of the type appropriate for the function
called. If the type of data values differs from the netCDF variable
type, type conversion will occur.
@c @xref{Type Conversion,,, pnetcdf, The PnetCDF Users Guide}.

@item bufcount
An integer indicates the number of MPI derived data type elements in the buf to be written to the file.

@item buftype
An MPI derived data type that describes the memory layout of buf.
Starting from PnetCDF version 1.6.0, buftype can be MPI_DATATYPE_NULL.
In this case, bufcount is ignored and the buf's data type must match the type
of the variable defined in the file - no data conversion will be done.

@item request
The nonblocking request ID returned by PnetCDF. It is to be used in a successive call to ncmpi_wait_all() or ncmpi_wait() for the completion of the nonblocking operation.

Starting from 1.7.0, the request argument can be NULL, meaning the caller does not
intend to track the requests IDs. In this case, a call to
ncmpi_wait_all/ncmpi_wait must use NC_REQ_ALL in its second argument "num" to
flush all pending nonblocking requests.

@end table

@heading Return Error Codes
ncmpi_iput_var@var{<kind>}_@var{<type>} returns the value NC_NOERR if no errors
occurred. Otherwise, the returned status indicates an error. Possible
causes of errors include:
@itemize
@item NC_EBADID: The specified netCDF ID does not refer to an opened netCDF file.
@item NC_EPERM: Attempt write operations in read-only file.
@item NC_ENOTVAR: The variable ID is invalid for the specified netCDF file.
@item NC_EGLOBAL: NC_GLOBAL is considered invalid for these APIs.
@item NC_EINVALCOORDS: The specified corner indices were out of range for the rank of the specified variable. For example, a negative index, or an index that is larger than the corresponding dimension length will cause an error.
@item NC_EEDGE: The specified edge lengths added to the specified corner would have referenced data out of range for the rank of the specified variable. For example, an edge length that is larger than the corresponding dimension length minus the corner index will cause an error.
@item NC_ERANGE: One or more of the specified values are out of the range of values representable by the external data type of the variable. Note NC_ERANGE is not a fatal error. The nonblocking request will be still added to the queue when NC_ERANGE is returned. Users are responsible to ensure no pending request exists when closing the file.
@item NC_EINDEFINE: Operation not allowed in define mode.
@item NC_ECHAR: Attempt to convert numerical values to or from text data.
@item NC_ENOMEM: Out of memory.
@item NC_EIOMISMATCH: The number of variable elements requested in (bufcount, buftype) mismatches the one calculated from count. This error may only occur for flexible APIs.
@item NC_ENOTSUPPORT: This API for NetCDF-4 files is not yet supported.
@end itemize



@heading Example
Below is an example using ncmpi_iput_vara_double to write 10 variables.
For simplicity in this example, we assume that the 10 variables have been
defined.

@example
#include <pnetcdf.h>
   ...
int         i;
int         ncid;           /* netCDF ID */
int         varid;          /* variable ID */
int         status;         /* error status */
int         request[10];    /* nonblocking request ID */
int         statuses[10];   /* status for individual requests */
MPI_Offset  start[10][2];   /* 10 sets of start indices */
MPI_Offset  count[10][2];   /* 10 sets of count lengths */
double     *buffers[10];    /* 10 write buffers */
   ...
status = @ref{ncmpi_create}(MPI_COMM_WORLD, "foo.nc", NC_WRITE, MPI_INFO_NULL, &ncid);
if (status != NC_NOERR) handle_error(status);
   ...
/* define dimensions */
/* define variables */
/* set values for start and count */
/* allocate write buffers and assign their values */
   ...
for (i=0; i<10; i++) @{
    /* post a nonblocking write request */
    status = @ref{ncmpi_iput_var@var{<kind>}_@var{<type>}, ncmpi_iput_vara_double}(ncid, varid, start[i], count[i], buffers[i], &request[i]);
    if (status != NC_NOERR) handle_error(status);
@}

/* write all 10 requests to the file at once */
status = @ref{ncmpi_wait/wait_all, ncmpi_wait_all}(ncid, 10, request, statuses);
if (status != NC_NOERR) handle_error(status);

for (i=0; i<10; i++) /* check status for each request */
    if (statuses[i] != NC_NOERR)
        handle_error(statuses[i]);
@end example

@heading Full example C program
@itemize
@item
@url{https://github.com/Parallel-NetCDF/PnetCDF/tree/master/examples/C/block_cyclic.c, block_cyclic.c}
@item
@url{https://github.com/Parallel-NetCDF/PnetCDF/tree/master/examples/C/column_wise.c, column_wise.c}
@item
@url{https://github.com/Parallel-NetCDF/PnetCDF/tree/master/examples/C/flexible_api.c, flexible_api.c}
@item
@url{https://github.com/Parallel-NetCDF/PnetCDF/tree/master/examples/C/nonblocking_write.c, nonblocking_write.c}
@item
The above programs are available in all PnetCDF releases under directory examples/C.
@end itemize

@node ncmpi_iget_var@var{<kind>}_@var{<type>}, ncmpi_iput_varn_@var{<type>}, ncmpi_iget_var@var{<kind>}_@var{<type>}, Variables
@section Nonblocking Read a Subarray: ncmpi_iget_@var{<kind>}_@var{<type>}
@findex ncmpi_iget_var1_text
@findex ncmpi_iget_var1_uchar
@findex ncmpi_iget_var1_schar
@findex ncmpi_iget_var1_short
@findex ncmpi_iget_var1_int
@findex ncmpi_iget_var1_float
@findex ncmpi_iget_var1_double
@findex ncmpi_iget_var1_ushort
@findex ncmpi_iget_var1_unit
@findex ncmpi_iget_var1_longlong
@findex ncmpi_iget_var1_ulonglong
@findex ncmpi_iget_var_text
@findex ncmpi_iget_var_uchar
@findex ncmpi_iget_var_schar
@findex ncmpi_iget_var_short
@findex ncmpi_iget_var_int
@findex ncmpi_iget_var_float
@findex ncmpi_iget_var_double
@findex ncmpi_iget_var_ushort
@findex ncmpi_iget_var_unit
@findex ncmpi_iget_var_longlong
@findex ncmpi_iget_var_ulonglong
@findex ncmpi_iget_vara_text
@findex ncmpi_iget_vara_uchar
@findex ncmpi_iget_vara_schar
@findex ncmpi_iget_vara_short
@findex ncmpi_iget_vara_int
@findex ncmpi_iget_vara_float
@findex ncmpi_iget_vara_double
@findex ncmpi_iget_vara_ushort
@findex ncmpi_iget_vara_unit
@findex ncmpi_iget_vara_longlong
@findex ncmpi_iget_vara_ulonglong
@findex ncmpi_iget_vars_text
@findex ncmpi_iget_vars_uchar
@findex ncmpi_iget_vars_schar
@findex ncmpi_iget_vars_short
@findex ncmpi_iget_vars_int
@findex ncmpi_iget_vars_float
@findex ncmpi_iget_vars_double
@findex ncmpi_iget_vars_ushort
@findex ncmpi_iget_vars_unit
@findex ncmpi_iget_vars_longlong
@findex ncmpi_iget_vars_ulonglong
@findex ncmpi_iget_varm_text
@findex ncmpi_iget_varm_uchar
@findex ncmpi_iget_varm_schar
@findex ncmpi_iget_varm_short
@findex ncmpi_iget_varm_int
@findex ncmpi_iget_varm_float
@findex ncmpi_iget_varm_double
@findex ncmpi_iget_varm_ushort
@findex ncmpi_iget_varm_unit
@findex ncmpi_iget_varm_longlong
@findex ncmpi_iget_varm_ulonglong
@cindex ncmpi_iget_var1_text, example
@cindex ncmpi_iget_var1_uchar, example
@cindex ncmpi_iget_var1_schar, example
@cindex ncmpi_iget_var1_short, example
@cindex ncmpi_iget_var1_int, example
@cindex ncmpi_iget_var1_float, example
@cindex ncmpi_iget_var1_double, example
@cindex ncmpi_iget_var1_ushort, example
@cindex ncmpi_iget_var1_unit, example
@cindex ncmpi_iget_var1_longlong, example
@cindex ncmpi_iget_var1_ulonglong, example
@cindex ncmpi_iget_var_text, example
@cindex ncmpi_iget_var_uchar, example
@cindex ncmpi_iget_var_schar, example
@cindex ncmpi_iget_var_short, example
@cindex ncmpi_iget_var_int, example
@cindex ncmpi_iget_var_float, example
@cindex ncmpi_iget_var_double, example
@cindex ncmpi_iget_var_ushort, example
@cindex ncmpi_iget_var_unit, example
@cindex ncmpi_iget_var_longlong, example
@cindex ncmpi_iget_var_ulonglong, example
@cindex ncmpi_iget_vara_text, example
@cindex ncmpi_iget_vara_uchar, example
@cindex ncmpi_iget_vara_schar, example
@cindex ncmpi_iget_vara_short, example
@cindex ncmpi_iget_vara_int, example
@cindex ncmpi_iget_vara_float, example
@cindex ncmpi_iget_vara_double, example
@cindex ncmpi_iget_vara_ushort, example
@cindex ncmpi_iget_vara_unit, example
@cindex ncmpi_iget_vara_longlong, example
@cindex ncmpi_iget_vara_ulonglong, example
@cindex ncmpi_iget_vars_text, example
@cindex ncmpi_iget_vars_uchar, example
@cindex ncmpi_iget_vars_schar, example
@cindex ncmpi_iget_vars_short, example
@cindex ncmpi_iget_vars_int, example
@cindex ncmpi_iget_vars_float, example
@cindex ncmpi_iget_vars_double, example
@cindex ncmpi_iget_vars_ushort, example
@cindex ncmpi_iget_vars_unit, example
@cindex ncmpi_iget_vars_longlong, example
@cindex ncmpi_iget_vars_ulonglong, example
@cindex ncmpi_iget_varm_text, example
@cindex ncmpi_iget_varm_uchar, example
@cindex ncmpi_iget_varm_schar, example
@cindex ncmpi_iget_varm_short, example
@cindex ncmpi_iget_varm_int, example
@cindex ncmpi_iget_varm_float, example
@cindex ncmpi_iget_varm_double, example
@cindex ncmpi_iget_varm_ushort, example
@cindex ncmpi_iget_varm_unit, example
@cindex ncmpi_iget_varm_longlong, example
@cindex ncmpi_iget_varm_ulonglong, example
@cindex nonblocking read a subarray
@cindex nonblocking, read a subarray

The ncmpi_iget_var@var{<kind>}_@var{<type>} family of functions is the
nonblocking version of the read functions. The nonblocking APIs have an
additional argument, @var{request}. It can be used later to query the status of
the put operation or wait for the write to complete.

A nonblocking get call indicates that the PnetCDF may start using (possible
altering the contents of) the get buffer. The caller should not access any part
of the get buffer after a nonblocking get is called, until the get completes.

@var{<kind>}: <none>, '1', 'a', 's', or 'm'.

@heading Data types
@html
<table cellpadding="4" border="1">
<tr class="spacer" align=center>
    <td> &lt;<b>type  </b>&gt; for API names </td>
    <td> &lt;<b>C type</b>&gt; for API arguments </td>
</tr>
<tr align=center> <td>text     </td> <td>char             </td> </tr>
<tr align=center> <td>schar    </td> <td>signed char      </td> </tr>
<tr align=center> <td>short    </td> <td>short            </td> </tr>
<tr align=center> <td>int      </td> <td>int              </td> </tr>
<tr align=center> <td>float    </td> <td>float            </td> </tr>
<tr align=center> <td>double   </td> <td>double           </td> </tr>
<tr align=center> <td>uchar    </td> <td>unsigned char    </td> </tr>
<tr align=center> <td>ushort   </td> <td>unsigned short   </td> </tr>
<tr align=center> <td>uint     </td> <td>unsigned int     </td> </tr>
<tr align=center> <td>longlong </td> <td>long long        </td> </tr>
<tr align=center> <td>ulonglong</td> <td>unsigned longlong</td> </tr>
</table>
@end html

@heading Operational Mode
Prior to version 1.7.0, nonblocking APIs must be called while the netCDF file is in data mode.
Starting from 1.7.0, nonblocking APIs can be called in either define or data mode.
This API family can be called in either collective or independent data mode.

@heading Usage
@example
int ncmpi_iget_var_@strong{<type>}  (int                ncid,
                            int                 varid,
                            @strong{<C type>}          *buf,
                            int                *request);

int ncmpi_iget_var1_@strong{<type>} (int                ncid,
                            int                 varid,
                            const MPI_Offset    start[],
                            @strong{<C type>}          *buf,
                            int                *request);

int ncmpi_iget_vara_<@strong{<type>}(int                ncid,
                            int                 varid,
                            const MPI_Offset    start[],
                            const MPI_Offset    count[],
                            @strong{<C type>}          *buf,
                            int                *request);

int ncmpi_iget_vars_@strong{<type>} (int                ncid,
                            int                 varid,
                            const MPI_Offset    start[],
                            const MPI_Offset    count[],
                            const MPI_Offset    stride[],
                            @strong{<C type>}          *buf,
                            int                *request);

int ncmpi_iget_varm_@strong{<type>} (int                ncid,
                            int                 varid,
                            const MPI_Offset    start[],
                            const MPI_Offset    count[],
                            const MPI_Offset    stride[],
                            const MPI_Offset    imap[],
                            @strong{<C type>}          *buf,
                            int                *request);
@end example
Flexible APIs:
@example
int ncmpi_iget_var  (int                ncid,
                     int                varid,
                     void              *buf,
                     MPI_Offset         bufcount,
                     MPI_Datatype       buftype,
                     int               *request);

int ncmpi_iget_var1 (int                ncid,
                     int                varid,
                     const MPI_Offset   start[],
                     void              *buf,
                     MPI_Offset         bufcount,
                     MPI_Datatype       buftype,
                     int               *request);

int ncmpi_iget_vara (int                ncid,
                     int                varid,
                     const MPI_Offset   start[],
                     const MPI_Offset   count[],
                     void              *buf,
                     MPI_Offset         bufcount,
                     MPI_Datatype       buftype,
                     int               *request);

int ncmpi_iget_vars (int                ncid,
                     int                varid,
                     const MPI_Offset   start[],
                     const MPI_Offset   count[],
                     const MPI_Offset   stride[],
                     void              *buf,
                     MPI_Offset         bufcount,
                     MPI_Datatype       buftype,
                     int               *request);

int ncmpi_iget_varm (int                ncid,
                     int                varid,
                     const MPI_Offset   start[],
                     const MPI_Offset   count[],
                     const MPI_Offset   stride[],
                     const MPI_Offset   imap[],
                     void              *buf,
                     MPI_Offset         bufcount,
                     MPI_Datatype       buftype,
                     int               *request);
@end example

@table @code

@item ncid
NetCDF ID, from a previous call to ncmpi_open or ncmpi_create.

@item varid
Variable ID. Different MPI processes may use different variable IDs.

@item start
A vector of MPI_Offset integers specifying the index in the variable
where the first of the data values will be read. The indices are
relative to 0, so for example, the first data value of a variable
would have index (0, 0, ... , 0). The elements of start correspond, in
order, to the variable's dimensions. Hence, if the variable is a
record variable, the first index corresponds to the starting record
number for reading the data values.

@item count
A vector of MPI_Offset integers specifying the number of indices selected
along each dimension. To read a single value, for example, specify
count as (1, 1, ... , 1). The elements of count correspond, in order,
to the variable's dimensions. Hence, if the variable is a record
variable, the first element of count corresponds to a count of the
number of records to read.

@item stride
A vector of MPI_Offset integers specifying, for each dimension, the
interval between selected indices. The elements of the stride vector
correspond, in order, to the variable's dimensions. A value of 1
accesses adjacent values of the netCDF variable in the corresponding
dimension; a value of 2 accesses every other value of the netCDF
variable in the corresponding dimension; and so on. A NULL stride
argument is treated as (1, 1, ... , 1).

@item imap
A vector of integers that specifies the mapping between the
dimensions of a netCDF variable and the in-memory structure of the
internal data array. imap[0] gives the distance between elements of
the internal array corresponding to the most slowly varying dimension
of the netCDF variable. imap[n-1] (where n is the rank of the netCDF
variable) gives the distance between elements of the internal array
corresponding to the most rapidly varying dimension of the netCDF
variable. Intervening imap elements correspond to other dimensions of
the netCDF variable in the obvious way. Distances between elements are
specified in type-independent units of elements (the distance between
internal elements that occupy adjacent memory locations is 1 and not
the element's byte-length as in netCDF 2).

@item buf
Pointer to the location used for computing where the data values are
read; the data should be of the type appropriate for the function
called. If the type of data value differs from the netCDF variable
type, type conversion will occur.
@c @xref{Type Conversion,,, pnetcdf, The PnetCDF Users Guide}.

@item bufcount
An integer indicates the number of MPI derived data type elements in the buf to be read from the file.

@item buftype
An MPI derived data type that describes the memory layout of buf.
Starting from PnetCDF version 1.6.0, buftype can be MPI_DATATYPE_NULL.
In this case, bufcount is ignored and the buf's data type must match the type
of the variable defined in the file - no data conversion will be done.

@item request
The nonblocking request ID returned by PnetCDF. It is to be used in a successive call to ncmpi_wait_all() or ncmpi_wait() for the completion of the nonblocking operation.

Starting from 1.7.0, the request argument can be NULL, meaning the caller does not
intend to track the requests IDs. In this case, a call to
ncmpi_wait_all/ncmpi_wait must use NC_REQ_ALL in its second argument "num" to
flush all pending nonblocking requests.

@end table

@heading Return Error Codes
ncmpi_iget_var@var{<kind>}_@var{<type>} returns the value NC_NOERR if no errors
occurred. Otherwise, the returned status indicates an error. Possible
causes of errors include:
@itemize
@item NC_EBADID: The specified netCDF ID does not refer to an opened netCDF file.
@item NC_ENOTVAR: The variable ID is invalid for the specified netCDF file.
@item NC_EGLOBAL: NC_GLOBAL is considered invalid for these APIs.
@item NC_EINVALCOORDS: The specified corner indices were out of range for the rank of the specified variable. For example, a negative index, or an index that is larger than the corresponding dimension length will cause an error.
@item NC_EEDGE: The specified edge lengths added to the specified corner would have referenced data out of range for the rank of the specified variable. For example, an edge length that is larger than the corresponding dimension length minus the corner index will cause an error.
@item NC_ERANGE: One or more elements of the external variable are out of the range of values representable by the internal data type of read buffer, buf.
@item NC_ECHAR: Attempt to convert numerical values to or from text data.
@item NC_ENOMEM: Out of memory.
@item NC_EIOMISMATCH: The number of variable elements requested in (bufcount, buftype) mismatches the one calculated from count. This error may only occur for flexible APIs.
@item NC_ENOTSUPPORT: This API for NetCDF-4 files is not yet supported.
@end itemize

@heading Example
Below is an example using ncmpi_iget_vara_double to read 10 variables.
For simplicity in this example, we assume that the 10 variables have been
defined in the file.

@example
#include <pnetcdf.h>
   ...
int         i;
int         ncid;           /* netCDF ID */
int         varid;          /* variable ID */
int         status;         /* error status */
int         request[10];    /* nonblocking request ID */
int         statuses[10];   /* status for individual requests */
MPI_Offset  start[10][2];   /* 10 sets of start indices */
MPI_Offset  count[10][2];   /* 10 sets of count lengths */
double     *buffers[10];    /* 10 read buffers */
   ...
status = @ref{ncmpi_open}(MPI_COMM_WORLD, "foo.nc", NC_NOWRITE, MPI_INFO_NULL, &ncid);
if (status != NC_NOERR) handle_error(status);
   ...
/* define dimensions */
/* define variables */
/* set values for start and count */
/* allocate read buffers */
   ...
for (i=0; i<10; i++) @{
    /* post a nonblocking read request */
    status = @ref{ncmpi_iget_var@var{<kind>}_@var{<type>}, ncmpi_iget_vara_double}(ncid, varid, start[i], count[i], buffers[i], &request[i]);
    if (status != NC_NOERR) handle_error(status);
@}

/* read all 10 requests from the file at once */
status = @ref{ncmpi_wait/wait_all, ncmpi_wait_all}(ncid, 10, request, statuses);
if (status != NC_NOERR) handle_error(status);

for (i=0; i<10; i++) /* check status for each request */
    if (statuses[i] != NC_NOERR)
        handle_error(statuses[i]);
@end example

@node ncmpi_iput_varn_@var{<type>}, ncmpi_iget_varn_@var{<type>}, ncmpi_iget_var@var{<kind>}_@var{<type>}, Variables
@section Nonblockingly Write a List of Subarrays: ncmpi_iput_varn_@var{<type>}
@findex ncmpi_iput_varn_text
@findex ncmpi_iput_varn_uchar
@findex ncmpi_iput_varn_schar
@findex ncmpi_iput_varn_short
@findex ncmpi_iput_varn_int
@findex ncmpi_iput_varn_float
@findex ncmpi_iput_varn_double
@findex ncmpi_iput_varn_ushort
@findex ncmpi_iput_varn_unit
@findex ncmpi_iput_varn_longlong
@findex ncmpi_iput_varn_ulonglong
@cindex ncmpi_iput_varn_text, example
@cindex ncmpi_iput_varn_uchar, example
@cindex ncmpi_iput_varn_schar, example
@cindex ncmpi_iput_varn_short, example
@cindex ncmpi_iput_varn_int, example
@cindex ncmpi_iput_varn_float, example
@cindex ncmpi_iput_varn_double, example
@cindex ncmpi_iput_varn_ushort, example
@cindex ncmpi_iput_varn_unit, example
@cindex ncmpi_iput_varn_longlong, example
@cindex ncmpi_iput_varn_ulonglong, example
@cindex nonblocking write a list of subarrays
@vindex NC_REQ_ALL

The ncmpi_iput_varn_@var{<type>} family of functions is the nonblocking version
of ncmpi_put_varn_@var{<type>} family.  The functions write, in a nonblocking
fashion, a list of subarrays into a netCDF variable of an opened netCDF
file.

A nonblocking put call indicates that the PnetCDF may start using (possible
altering the contents of) the put buffer. The caller should not access any part
of the put buffer after a nonblocking put is called, until the put completes.

The part of the netCDF variable to write is specified by giving a list of
subarrays and each subarray is specified by a corner and a vector of edge
lengths that refer to an array section of the netCDF variable. For each
subarray, the values to be written are associated with the netCDF variable by
assuming that the last dimension of the netCDF variable varies fastest in the C
interface.

This API essentially has the same effect of making multiple calls to ncmpi_iput_vara_@var{<type>} with the same variable ID.

@heading Data types
@html
<table cellpadding="4" border="1">
<tr class="spacer" align=center>
    <td> &lt;<b>type  </b>&gt; for API names </td>
    <td> &lt;<b>C type</b>&gt; for API arguments </td>
</tr>
<tr align=center> <td>text     </td> <td>char             </td> </tr>
<tr align=center> <td>schar    </td> <td>signed char      </td> </tr>
<tr align=center> <td>short    </td> <td>short            </td> </tr>
<tr align=center> <td>int      </td> <td>int              </td> </tr>
<tr align=center> <td>float    </td> <td>float            </td> </tr>
<tr align=center> <td>double   </td> <td>double           </td> </tr>
<tr align=center> <td>uchar    </td> <td>unsigned char    </td> </tr>
<tr align=center> <td>ushort   </td> <td>unsigned short   </td> </tr>
<tr align=center> <td>uint     </td> <td>unsigned int     </td> </tr>
<tr align=center> <td>longlong </td> <td>long long        </td> </tr>
<tr align=center> <td>ulonglong</td> <td>unsigned longlong</td> </tr>
</table>
@end html

@heading Operational Mode
Prior to version 1.7.0, nonblocking APIs must be called while the netCDF file is in data mode.
Starting from 1.7.0, nonblocking APIs can be called in either define or data mode.
This API family can be called in either collective or independent data mode.

@heading Usage
@example
int ncmpi_iput_varn_@strong{<type>}     (int               ncid,
                                int               varid,
                                int               num,
                                const MPI_Offset  starts[num][],
                                const MPI_Offset  counts[num][],
                                const @strong{<C type>}   *buf,
                                int              *request);

int ncmpi_iput_varn            (int               ncid,
                                int               varid,
                                int               num,
                                const MPI_Offset  starts[num][],
                                const MPI_Offset  counts[num][],
                                const void       *buf,
                                MPI_Offset        bufcount,
                                MPI_Datatype      buftype,
                                int              *request);
@end example

@table @code

@item ncid
NetCDF ID, from a previous call to ncmpi_open or ncmpi_create.

@item varid
Variable ID. Different MPI processes may use different variable IDs.

@item num
Number of subarray requests.

@item starts
A double pointer that mimics a 2D array of size [num][ndims].
See below for example of how to allocate space and construct such a 2D array.
Each starts[i] is a vector specifying the index in the variable where the first of the data values will be written.
The indices are relative to 0, so for example, the first data value of a variable would have index (0, 0, ... , 0).
The size of starts must be [num][ndims], where ndims is the number of dimensions of the specified variable.
The elements of each starts[i] must correspond to the variable's dimensions in order.
Hence, if the variable is a record variable, the first index of each starts[i] would correspond to the starting record number for writing the data values.

@item counts
A double pointer that mimics a 2D array of size [num][ndims].
See below for example of how to allocate space and construct such a 2D array.
Each counts[i] is a vector specifying the edge lengths along each dimension of the block of data values to be written.
To write a single value, for example, specify count as (1, 1, ... , 1).
The size of counts should be [num][ndims], where ndims is the number of dimensions of the specified variable.
The elements of count correspond to the variable's dimensions.
Hence, if the variable is a record variable, the first element of each counts[i] corresponds to a count of the number of records to write.
This argument can be NULL, in which case it is equivalent to providing counts[*][*]=(1, 1, ... , 1).

@item buf
A pointer to the memory address that contains the data values to be written. If the type of data values differs from the netCDF variable type, type conversion will occur.
@c @xref{Type Conversion,,, pnetcdf, The PnetCDF Users Guide}.

@item bufcount
An integer indicates the number of MPI derived data type elements in the buffer pointed by buf to be written to the file.

@item buftype
An MPI derived data type that describes the memory layout of buf.
Starting from PnetCDF version 1.6.0, buftype can be MPI_DATATYPE_NULL.
In this case, bufcount is ignored and the buf's data type must match the type
of the variable defined in the file - no data conversion will be done.

@item request
The nonblocking request ID returned by PnetCDF. It is to be used in a successive call to ncmpi_wait_all() or ncmpi_wait() for the completion of the nonblocking operation.

Starting from 1.7.0, the request argument can be NULL, meaning the caller does not
intend to track the requests IDs. In this case, a call to
ncmpi_wait_all/ncmpi_wait must use NC_REQ_ALL in its second argument "num" to
flush all pending nonblocking requests.

@end table

@heading Return Error Codes
ncmpi_iput_varn_@var{<type>} returns the value NC_NOERR if no errors
occurred. Otherwise, the returned status indicates an error. Possible
causes of errors include:
@itemize
@item NC_EBADID: The specified netCDF ID does not refer to an opened netCDF file.
@item NC_EPERM: Attempt write operations in read-only file.
@item NC_ENOTVAR: The variable ID is invalid for the specified netCDF file.
@item NC_EGLOBAL: NC_GLOBAL is considered invalid for these APIs.
@item NC_EINVALCOORDS: The specified corner indices were out of range for the rank of the specified variable. For example, a negative index, or an index that is larger than the corresponding dimension length will cause an error.
@item NC_EEDGE: The specified edge lengths added to the specified corner would have referenced data out of range for the rank of the specified variable. For example, an edge length that is larger than the corresponding dimension length minus the corner index will cause an error.
@item NC_ERANGE: One or more of the specified values are out of the range of values representable by the external data type of the variable. (Does not apply to the ncmpi_get_var() and ncmpi_get_var_all()). Note NC_ERANGE is not a fatal error. The nonblocking request will be still added to the queue when NC_ERANGE is returned. Users are responsible to ensure no pending request exists when closing the file.
@item NC_ECHAR: Attempt to convert numerical values to or from text data.
@item NC_ENOMEM: Out of memory.
@item NC_ENULLSTART: It is illegal for argument starts being a NULL.
@item NC_EIOMISMATCH: The number of variable elements requested in (bufcount, buftype) mismatches the one calculated from counts. This error may only occur for flexible APIs.
@item NC_ENOTSUPPORT: This API for NetCDF-4 files is not yet supported.
@end itemize


@heading Example

This example shows how to use a single call of ncmpi_put_varn_float_all()
to write a sequence of requests with arbitrary array indices.

@example
#include <pnetcdf.h>
    ...
#define MAX_NUM_REQS 6
#define NDIMS        2

int  i, j;
int  rank;                         /* MPI process rank ID */
int  err;                          /* error status */
int  ncid;                         /* netCDF ID */
int  varid;                        /* variable ID */
int  num_reqs;                     /* number of subarray requests */
int  dimid[2];                     /* dimension IDs */
int  request[1];                   /* nonblocking request ID */
int  st[1];                        /* nonblocking request status */
int  buf_len;                      /* number of elements in buffer */
float *buffer;                     /* write buffer to hold values */
MPI_Offset **starts, **counts;
    ...
MPI_Comm_rank(MPI_COMM_WORLD, &rank);

err = @ref{ncmpi_create}(MPI_COMM_WORLD, "foo.nc", NC_CLOBBER, MPI_INFO_NULL, &ncid);

if (err != NC_NOERR) handle_error(err);

err = @ref{ncmpi_def_dim}(ncid, "Y", 4,  &dimid[0]);
err = @ref{ncmpi_def_dim}(ncid, "X", 10, &dimid[1]);
err = @ref{ncmpi_def_var}(ncid, "var", NC_FLOAT, 2, dimid, &varid);
err = @ref{ncmpi_enddef}(ncid);

/* allocate starts and counts */
starts    = (MPI_Offset**) malloc(MAX_NUM_REQS*       sizeof(MPI_Offset*));
starts[0] = (MPI_Offset*)  calloc(MAX_NUM_REQS*NDIMS, sizeof(MPI_Offset));
for (i=1; i<MAX_NUM_REQS; i++)
    starts[i] = starts[i-1] + NDIMS;

counts    = (MPI_Offset**) malloc(MAX_NUM_REQS*       sizeof(MPI_Offset*));
counts[0] = (MPI_Offset*)  calloc(MAX_NUM_REQS*NDIMS, sizeof(MPI_Offset));
for (i=1; i<MAX_NUM_REQS; i++)
    counts[i] = counts[i-1] + NDIMS;

if (rank == 0) @{
    num_reqs = 4;
    starts[0][0] = 0; starts[0][1] = 5; counts[0][0] = 1; counts[0][1] = 2;
    starts[1][0] = 1; starts[1][1] = 0; counts[1][0] = 1; counts[1][1] = 1;
    starts[2][0] = 2; starts[2][1] = 6; counts[2][0] = 1; counts[2][1] = 2;
    starts[3][0] = 3; starts[3][1] = 0; counts[3][0] = 1; counts[3][1] = 3;
    /* rank 0 is writing the following locations: ("-" means skip)
              -  -  -  -  -  0  0  -  -  -
              0  -  -  -  -  -  -  -  -  -
              -  -  -  -  -  -  0  0  -  -
              0  0  0  -  -  -  -  -  -  -
     */
@} else if (rank == 1) @{
    num_reqs = 6;
    starts[0][0] = 0; starts[0][1] = 3; counts[0][0] = 1; counts[0][1] = 2;
    starts[1][0] = 0; starts[1][1] = 8; counts[1][0] = 1; counts[1][1] = 2;
    starts[2][0] = 1; starts[2][1] = 5; counts[2][0] = 1; counts[2][1] = 2;
    starts[3][0] = 2; starts[3][1] = 0; counts[3][0] = 1; counts[3][1] = 2;
    starts[4][0] = 2; starts[4][1] = 8; counts[4][0] = 1; counts[4][1] = 2;
    starts[5][0] = 3; starts[5][1] = 4; counts[5][0] = 1; counts[5][1] = 3;
    /* rank 1 is writing the following locations: ("-" means skip)
              -  -  -  1  1  -  -  -  1  1
              -  -  -  -  -  1  1  -  -  -
              1  1  -  -  -  -  -  -  1  1
              -  -  -  -  1  1  1  -  -  -
     */
@} else if (rank == 2) @{
    num_reqs = 5;
    starts[0][0] = 0; starts[0][1] = 7; counts[0][0] = 1; counts[0][1] = 1;
    starts[1][0] = 1; starts[1][1] = 1; counts[1][0] = 1; counts[1][1] = 3;
    starts[2][0] = 1; starts[2][1] = 7; counts[2][0] = 1; counts[2][1] = 3;
    starts[3][0] = 2; starts[3][1] = 2; counts[3][0] = 1; counts[3][1] = 1;
    starts[4][0] = 3; starts[4][1] = 3; counts[4][0] = 1; counts[4][1] = 1;
    /* rank 2 is writing the following locations: ("-" means skip)
              -  -  -  -  -  -  -  2  -  -
              -  2  2  2  -  -  -  2  2  2
              -  -  2  -  -  -  -  -  -  -
              -  -  -  2  -  -  -  -  -  -
     */
@} else if (rank == 3) @{
    num_reqs = 4;
    starts[0][0] = 0; starts[0][1] = 0; counts[0][0] = 1; counts[0][1] = 3;
    starts[1][0] = 1; starts[1][1] = 4; counts[1][0] = 1; counts[1][1] = 1;
    starts[2][0] = 2; starts[2][1] = 3; counts[2][0] = 1; counts[2][1] = 3;
    starts[3][0] = 3; starts[3][1] = 7; counts[3][0] = 1; counts[3][1] = 3;
    /* rank 3 is writing the following locations: ("-" means skip)
              3  3  3  -  -  -  -  -  -  -
              -  -  -  -  3  -  -  -  -  -
              -  -  -  3  3  3  -  -  -  -
              -  -  -  -  -  -  -  3  3  3
     */
@} else @{
    num_reqs = 0;
@}

/* allocate write buffer */
buf_len = 0;
for (i=0; i<num_reqs; i++) @{
    MPI_Offset w_req_len=1;
    for (j=0; j<NDIMS; j++)
        w_req_len *= counts[i][j];
    buf_len += w_req_len;
@}
buffer = (float*) malloc(buf_len * sizeof(float));
for (i=0; i<buf_len; i++) buffer[i] = (float)rank;

 /* write values into netCDF variable */
 err = @ref{ncmpi_iput_varn_@var{<type>}, ncmpi_iput_varn_float}(ncid, varid, num_reqs, starts, counts, buffer, &request[0]);
 if (err != NC_NOERR) handle_error(err);
    ...
 /* wait for the nonblocking operation to complete */
 status = @ref{ncmpi_wait/wait_all, ncmpi_wait_all}(ncid, 1, request, st);
 if (status != NC_NOERR) handle_error(status);

 err = @ref{ncmpi_close}(ncid);
 if (err != NC_NOERR) handle_error(err);

/*    % ncmpidump foo.nc
 *    netcdf foo @{
 *    dimensions:
 *             Y = 4 ;
 *             X = 10 ;
 *    variables:
 *             float var(Y, X) ;
 *    data:
 *
 *     var =
 *       3, 3, 3, 1, 1, 0, 0, 2, 1, 1,
 *       0, 2, 2, 2, 3, 1, 1, 2, 2, 2,
 *       1, 1, 2, 3, 3, 3, 0, 0, 1, 1,
 *       0, 0, 0, 2, 1, 1, 1, 3, 3, 3 ;
 *    @}
 */
@end example

@heading Full example C program
@itemize
@item
@url{https://github.com/Parallel-NetCDF/PnetCDF/tree/master/examples/C/i_varn_int64.c, i_varn_int64.c}
@item
The above programs are available in all PnetCDF releases under directory examples/C.
@end itemize

@node ncmpi_iget_varn_@var{<type>}, ncmpi_bput_var@var{<kind>}_@var{<type>}, ncmpi_iput_varn_@var{<type>}, Variables
@section Nonblockingly Read a List of Subarrays: ncmpi_iget_varn_@var{<type>}
@findex ncmpi_iget_varn_text
@findex ncmpi_iget_varn_uchar
@findex ncmpi_iget_varn_schar
@findex ncmpi_iget_varn_short
@findex ncmpi_iget_varn_int
@findex ncmpi_iget_varn_float
@findex ncmpi_iget_varn_double
@findex ncmpi_iget_varn_ushort
@findex ncmpi_iget_varn_unit
@findex ncmpi_iget_varn_longlong
@findex ncmpi_iget_varn_ulonglong
@cindex ncmpi_iget_varn_text, example
@cindex ncmpi_iget_varn_uchar, example
@cindex ncmpi_iget_varn_schar, example
@cindex ncmpi_iget_varn_short, example
@cindex ncmpi_iget_varn_int, example
@cindex ncmpi_iget_varn_float, example
@cindex ncmpi_iget_varn_double, example
@cindex ncmpi_iget_varn_ushort, example
@cindex ncmpi_iget_varn_unit, example
@cindex ncmpi_iget_varn_longlong, example
@cindex ncmpi_iget_varn_ulonglong, example
@cindex nonblocking read a list of subarrays
@vindex NC_REQ_ALL

The ncmpi_iget_varn_@var{<type>} family of functions is the nonblocking version
of ncmpi_get_varn_@var{<type>} family.  The functions read, in a nonblocking
fashion, a list of subarrays of a netCDF variable in an opened netCDF file.

A nonblocking get call indicates that the PnetCDF may start using (possible
altering the contents of) the get buffer. The caller should not access any part
of the get buffer after a nonblocking get is called, until the get completes.

The part of the netCDF variable to read is specified by giving a list of
subarrays and each subarray is specified by a corner and a vector of edge
lengths that refer to an array section of the netCDF variable.  For each
subarray, the values to be read are associated with the netCDF variable by
assuming that the last dimension of the netCDF variable varies fastest in the C
interface.

This API essentially has the same effect of making multiple calls to ncmpi_get_vara_@var{<type>} with the same variable ID.

@heading Data types
@html
<table cellpadding="4" border="1">
<tr class="spacer" align=center>
    <td> &lt;<b>type  </b>&gt; for API names </td>
    <td> &lt;<b>C type</b>&gt; for API arguments </td>
</tr>
<tr align=center> <td>text     </td> <td>char             </td> </tr>
<tr align=center> <td>schar    </td> <td>signed char      </td> </tr>
<tr align=center> <td>short    </td> <td>short            </td> </tr>
<tr align=center> <td>int      </td> <td>int              </td> </tr>
<tr align=center> <td>float    </td> <td>float            </td> </tr>
<tr align=center> <td>double   </td> <td>double           </td> </tr>
<tr align=center> <td>uchar    </td> <td>unsigned char    </td> </tr>
<tr align=center> <td>ushort   </td> <td>unsigned short   </td> </tr>
<tr align=center> <td>uint     </td> <td>unsigned int     </td> </tr>
<tr align=center> <td>longlong </td> <td>long long        </td> </tr>
<tr align=center> <td>ulonglong</td> <td>unsigned longlong</td> </tr>
</table>
@end html

@heading Operational Mode
Prior to version 1.7.0, nonblocking APIs must be called while the netCDF file is in data mode.
Starting from 1.7.0, nonblocking APIs can be called in either define or data mode.
This API family can be called in either collective or independent data mode.

@heading Usage
@example
int ncmpi_iget_varn_@strong{<type>}     (int               ncid,
                               int               varid,
                               int               num,
                               const MPI_Offset  starts[num][],
                               const MPI_Offset  counts[num][],
                               @strong{<C type>}         *buf,
                               int              *request);

int ncmpi_iget_varn            (int               ncid,
                               int               varid,
                               int               num,
                               const MPI_Offset  starts[num][],
                               const MPI_Offset  counts[num][],
                               void             *buf,
                               MPI_Offset        bufcount,
                               MPI_Datatype      buftype,
                               int              *request);
@end example

@table @code

@item ncid
NetCDF ID, from a previous call to ncmpi_open or ncmpi_create.

@item varid
Variable ID. Different MPI processes may use different variable IDs.

@item num
Nnumber of subarray requests.

@item starts
A double pointer that mimics a 2D array of size [num][ndims].
See below for example of how to allocate space and construct such a 2D array.
Each starts[i] is a vector specifying the index in the variable where the first of the data values will be read.
The indices are relative to 0, so for example, the first data value of a variable would have index (0, 0, ... , 0).
The size of starts must be [num][ndims], where ndims is the number of dimensions of the specified variable.
The elements of each starts[i] must correspond to the variable's dimensions in order.
Hence, if the variable is a record variable, the first index of each starts[i] would correspond to the starting record number for writing the data values.

@item counts
A double pointer that mimics a 2D array of size [num][ndims].
See below for example of how to allocate space and construct such a 2D array.
Each counts[i] is a vector specifying the edge lengths along each dimension of the block of data values to be read.
To write a single value, for example, specify count as (1, 1, ... , 1).
The size of counts should be [num][ndims], where ndims is the number of dimensions of the specified variable.
The elements of count correspond to the variable's dimensions.
Hence, if the variable is a record variable, the first element of each counts[i] corresponds to a count of the number of records to write.
This argument can be NULL, in which case it is equivalent to providing counts[*][*]=(1, 1, ... , 1).

@item buf
A pointer to the memory address that contains a buffer space to store the data values to be read from the opened file.
If the type of data values differs from the netCDF variable type, type conversion will occur.
@c @xref{Type Conversion,,, pnetcdf, The PnetCDF Users Guide}.

@item bufcount
An integer indicates the number of MPI derived data type elements to be read from the file and stored in the buffer pointed by buf.

@item buftype
An MPI derived data type that describes the memory layout of buf.
Starting from PnetCDF version 1.6.0, buftype can be MPI_DATATYPE_NULL.
In this case, bufcount is ignored and the buf's data type must match the type
of the variable defined in the file - no data conversion will be done.

@end table

@heading Return Error Codes
ncmpi_iget_varn_@var{<type>} returns the value NC_NOERR if no errors
occurred. Otherwise, the returned status indicates an error. Possible
causes of errors include:
@itemize
@item NC_EBADID: The specified netCDF ID does not refer to an opened netCDF file.
@item NC_ENOTVAR: The variable ID is invalid for the specified netCDF file.
@item NC_EGLOBAL: NC_GLOBAL is considered invalid for these APIs.
@item NC_EINVALCOORDS: The specified corner indices were out of range for the rank of the specified variable. For example, a negative index, or an index that is larger than the corresponding dimension length will cause an error.
@item NC_EEDGE: The specified edge lengths added to the specified corner would have referenced data out of range for the rank of the specified variable. For example, an edge length that is larger than the corresponding dimension length minus the corner index will cause an error.
@item NC_ERANGE: One or more elements of the external variable are out of the range of values representable by the internal data type of read buffer, buf.  (Does not apply to the ncmpi_iget_varn() and ncmpi_iget_varn_all()).
@item NC_ECHAR: Attempt to convert numerical values to or from text data.
@item NC_ENOMEM: Out of memory.
@item NC_ENULLSTART: It is illegal for argument starts being a NULL.
@item NC_EIOMISMATCH: The number of variable elements requested in (bufcount, buftype) mismatches the one calculated from counts. This error may only occur for flexible APIs.
@item NC_ENOTSUPPORT: This API for NetCDF-4 files is not yet supported.
@end itemize

@heading Example

This example shows how to use a single call of ncmpi_iget_varn_float_all()
to read a sequence of requests with arbitrary array indices.

@example
#include <pnetcdf.h>
    ...
#define MAX_NUM_REQS 6
#define NDIMS        2

int  i, j;
int  rank;                         /* MPI process rank ID */
int  err;                          /* error status */
int  ncid;                         /* netCDF ID */
int  varid;                        /* variable ID */
int  num_reqs;                     /* number of subarray requests */
int  dimid[2];                     /* dimension IDs */
int  request[1];                   /* nonblocking request ID */
int  st[1];                        /* nonblocking request status */
int  buf_len;                      /* number of elements in buffer */
float *buffer;                     /* read buffer to hold values */
MPI_Offset **starts, **counts;
    ...
MPI_Comm_rank(MPI_COMM_WORLD, &rank);

err = @ref{ncmpi_open}(MPI_COMM_WORLD, "foo.nc", NC_NOWRITE, MPI_INFO_NULL, &ncid);
if (err != NC_NOERR) handle_error(err);

/* allocate starts and counts */
starts    = (MPI_Offset**) malloc(MAX_NUM_REQS*       sizeof(MPI_Offset*));
starts[0] = (MPI_Offset*)  calloc(MAX_NUM_REQS*NDIMS, sizeof(MPI_Offset));
for (i=1; i<MAX_NUM_REQS; i++)
    starts[i] = starts[i-1] + NDIMS;

counts    = (MPI_Offset**) malloc(MAX_NUM_REQS*       sizeof(MPI_Offset*));
counts[0] = (MPI_Offset*)  calloc(MAX_NUM_REQS*NDIMS, sizeof(MPI_Offset));
for (i=1; i<MAX_NUM_REQS; i++)
    counts[i] = counts[i-1] + NDIMS;

if (rank == 0) @{
    num_reqs = 4;
    starts[0][0] = 0; starts[0][1] = 5; counts[0][0] = 1; counts[0][1] = 2;
    starts[1][0] = 1; starts[1][1] = 0; counts[1][0] = 1; counts[1][1] = 1;
    starts[2][0] = 2; starts[2][1] = 6; counts[2][0] = 1; counts[2][1] = 2;
    starts[3][0] = 3; starts[3][1] = 0; counts[3][0] = 1; counts[3][1] = 3;
    /* rank 0 is reading the following locations: ("-" means skip)
              -  -  -  -  -  0  0  -  -  -
              0  -  -  -  -  -  -  -  -  -
              -  -  -  -  -  -  0  0  -  -
              0  0  0  -  -  -  -  -  -  -
     */
@} else if (rank == 1) @{
    num_reqs = 6;
    starts[0][0] = 0; starts[0][1] = 3; counts[0][0] = 1; counts[0][1] = 2;
    starts[1][0] = 0; starts[1][1] = 8; counts[1][0] = 1; counts[1][1] = 2;
    starts[2][0] = 1; starts[2][1] = 5; counts[2][0] = 1; counts[2][1] = 2;
    starts[3][0] = 2; starts[3][1] = 0; counts[3][0] = 1; counts[3][1] = 2;
    starts[4][0] = 2; starts[4][1] = 8; counts[4][0] = 1; counts[4][1] = 2;
    starts[5][0] = 3; starts[5][1] = 4; counts[5][0] = 1; counts[5][1] = 3;
    /* rank 1 is reading the following locations: ("-" means skip)
              -  -  -  1  1  -  -  -  1  1
              -  -  -  -  -  1  1  -  -  -
              1  1  -  -  -  -  -  -  1  1
              -  -  -  -  1  1  1  -  -  -
    */
@} else if (rank == 2) @{
    num_reqs = 5;
    starts[0][0] = 0; starts[0][1] = 7; counts[0][0] = 1; counts[0][1] = 1;
    starts[1][0] = 1; starts[1][1] = 1; counts[1][0] = 1; counts[1][1] = 3;
    starts[2][0] = 1; starts[2][1] = 7; counts[2][0] = 1; counts[2][1] = 3;
    starts[3][0] = 2; starts[3][1] = 2; counts[3][0] = 1; counts[3][1] = 1;
    starts[4][0] = 3; starts[4][1] = 3; counts[4][0] = 1; counts[4][1] = 1;
    /* rank 2 is reading the following locations: ("-" means skip)
              -  -  -  -  -  -  -  2  -  -
              -  2  2  2  -  -  -  2  2  2
              -  -  2  -  -  -  -  -  -  -
              -  -  -  2  -  -  -  -  -  -
     */
@} else if (rank == 3) @{
    num_reqs = 4;
    starts[0][0] = 0; starts[0][1] = 0; counts[0][0] = 1; counts[0][1] = 3;
    starts[1][0] = 1; starts[1][1] = 4; counts[1][0] = 1; counts[1][1] = 1;
    starts[2][0] = 2; starts[2][1] = 3; counts[2][0] = 1; counts[2][1] = 3;
    starts[3][0] = 3; starts[3][1] = 7; counts[3][0] = 1; counts[3][1] = 3;
    /* rank 3 is reading the following locations: ("-" means skip)
              3  3  3  -  -  -  -  -  -  -
              -  -  -  -  3  -  -  -  -  -
              -  -  -  3  3  3  -  -  -  -
              -  -  -  -  -  -  -  3  3  3
     */
@} else @{
    num_reqs = 0;
@}

/* allocate read buffer */
buf_len = 0;
for (i=0; i<num_reqs; i++) @{
    MPI_Offset r_req_len=1;
    for (j=0; j<NDIMS; j++)
        r_req_len *= counts[i][j];
    buf_len += r_req_len;
@}
buffer = (float*) malloc(buf_len * sizeof(float));

/* reads values into netCDF variable */
err = @ref{ncmpi_iget_varn_@var{<type>}, ncmpi_iget_varn_float}(ncid, varid, num_reqs, starts, counts, buffer, &request[0]);
if (err != NC_NOERR) handle_error(err);
    ...
 /* wait for the nonblocking operation to complete */
 status = @ref{ncmpi_wait/wait_all, ncmpi_wait_all}(ncid, 1, request, st);
 if (status != NC_NOERR) handle_error(status);

err = @ref{ncmpi_close}(ncid);
if (err != NC_NOERR) handle_error(err);

/*    % ncmpidump foo.nc
 *    netcdf foo @{
 *    dimensions:
 *             Y = 4 ;
 *             X = 10 ;
 *    variables:
 *             float var(Y, X) ;
 *    data:
 *
 *     var =
 *       3, 3, 3, 1, 1, 0, 0, 2, 1, 1,
 *       0, 2, 2, 2, 3, 1, 1, 2, 2, 2,
 *       1, 1, 2, 3, 3, 3, 0, 0, 1, 1,
 *       0, 0, 0, 2, 1, 1, 1, 3, 3, 3 ;
 *    @}
 */
@end example

@node ncmpi_bput_var@var{<kind>}_@var{<type>}, ncmpi_bput_varn_@var{<type>}, ncmpi_iput_varn_@var{<type>}, Variables
@section Nonblocking Buffered Write a Subarray: ncmpi_bput_@var{<kind>}_@var{<type>}
@findex ncmpi_bput_var1_text
@findex ncmpi_bput_var1_uchar
@findex ncmpi_bput_var1_schar
@findex ncmpi_bput_var1_short
@findex ncmpi_bput_var1_int
@findex ncmpi_bput_var1_float
@findex ncmpi_bput_var1_double
@findex ncmpi_bput_var1_ushort
@findex ncmpi_bput_var1_unit
@findex ncmpi_bput_var1_longlong
@findex ncmpi_bput_var1_ulonglong
@findex ncmpi_bput_var_text
@findex ncmpi_bput_var_uchar
@findex ncmpi_bput_var_schar
@findex ncmpi_bput_var_short
@findex ncmpi_bput_var_int
@findex ncmpi_bput_var_float
@findex ncmpi_bput_var_double
@findex ncmpi_bput_var_ushort
@findex ncmpi_bput_var_unit
@findex ncmpi_bput_var_longlong
@findex ncmpi_bput_var_ulonglong
@findex ncmpi_bput_vara_text
@findex ncmpi_bput_vara_uchar
@findex ncmpi_bput_vara_schar
@findex ncmpi_bput_vara_short
@findex ncmpi_bput_vara_int
@findex ncmpi_bput_vara_float
@findex ncmpi_bput_vara_double
@findex ncmpi_bput_vara_ushort
@findex ncmpi_bput_vara_unit
@findex ncmpi_bput_vara_longlong
@findex ncmpi_bput_vara_ulonglong
@findex ncmpi_bput_vars_text
@findex ncmpi_bput_vars_uchar
@findex ncmpi_bput_vars_schar
@findex ncmpi_bput_vars_short
@findex ncmpi_bput_vars_int
@findex ncmpi_bput_vars_float
@findex ncmpi_bput_vars_double
@findex ncmpi_bput_vars_ushort
@findex ncmpi_bput_vars_unit
@findex ncmpi_bput_vars_longlong
@findex ncmpi_bput_vars_ulonglong
@findex ncmpi_bput_varm_text
@findex ncmpi_bput_varm_uchar
@findex ncmpi_bput_varm_schar
@findex ncmpi_bput_varm_short
@findex ncmpi_bput_varm_int
@findex ncmpi_bput_varm_float
@findex ncmpi_bput_varm_double
@findex ncmpi_bput_varm_ushort
@findex ncmpi_bput_varm_unit
@findex ncmpi_bput_varm_longlong
@findex ncmpi_bput_varm_ulonglong
@findex ncmpi_buffer_attach
@findex ncmpi_buffer_detach
@cindex ncmpi_bput_var1_text, example
@cindex ncmpi_bput_var1_uchar, example
@cindex ncmpi_bput_var1_schar, example
@cindex ncmpi_bput_var1_short, example
@cindex ncmpi_bput_var1_int, example
@cindex ncmpi_bput_var1_float, example
@cindex ncmpi_bput_var1_double, example
@cindex ncmpi_bput_var1_ushort, example
@cindex ncmpi_bput_var1_unit, example
@cindex ncmpi_bput_var1_longlong, example
@cindex ncmpi_bput_var1_ulonglong, example
@cindex ncmpi_bput_var_text, example
@cindex ncmpi_bput_var_uchar, example
@cindex ncmpi_bput_var_schar, example
@cindex ncmpi_bput_var_short, example
@cindex ncmpi_bput_var_int, example
@cindex ncmpi_bput_var_float, example
@cindex ncmpi_bput_var_double, example
@cindex ncmpi_bput_var_ushort, example
@cindex ncmpi_bput_var_unit, example
@cindex ncmpi_bput_var_longlong, example
@cindex ncmpi_bput_var_ulonglong, example
@cindex ncmpi_bput_vara_text, example
@cindex ncmpi_bput_vara_uchar, example
@cindex ncmpi_bput_vara_schar, example
@cindex ncmpi_bput_vara_short, example
@cindex ncmpi_bput_vara_int, example
@cindex ncmpi_bput_vara_float, example
@cindex ncmpi_bput_vara_double, example
@cindex ncmpi_bput_vara_ushort, example
@cindex ncmpi_bput_vara_unit, example
@cindex ncmpi_bput_vara_longlong, example
@cindex ncmpi_bput_vara_ulonglong, example
@cindex ncmpi_bput_vars_text, example
@cindex ncmpi_bput_vars_uchar, example
@cindex ncmpi_bput_vars_schar, example
@cindex ncmpi_bput_vars_short, example
@cindex ncmpi_bput_vars_int, example
@cindex ncmpi_bput_vars_float, example
@cindex ncmpi_bput_vars_double, example
@cindex ncmpi_bput_vars_ushort, example
@cindex ncmpi_bput_vars_unit, example
@cindex ncmpi_bput_vars_longlong, example
@cindex ncmpi_bput_vars_ulonglong, example
@cindex ncmpi_bput_varm_text, example
@cindex ncmpi_bput_varm_uchar, example
@cindex ncmpi_bput_varm_schar, example
@cindex ncmpi_bput_varm_short, example
@cindex ncmpi_bput_varm_int, example
@cindex ncmpi_bput_varm_float, example
@cindex ncmpi_bput_varm_double, example
@cindex ncmpi_bput_varm_ushort, example
@cindex ncmpi_bput_varm_unit, example
@cindex ncmpi_bput_varm_longlong, example
@cindex ncmpi_bput_varm_ulonglong, example
@cindex buffered nonblocking write a subarray
@cindex buffered nonblocking, write a subarray
@cindex ncmpi_buffer_attach, example
@cindex ncmpi_buffer_detach, example
@vindex NC_REQ_ALL

The ncmpi_bput_var@var{<kind>}_@var{<type>} family of functions is the buffered
version of the nonblocking write functions
ncmpi_iput_var@var{<kind>}_@var{<type>}.

The write data is buffered (cached) internally by PnetCDF and will be flushed
to the file at the time of calling ncmpi_wait() or ncmpi_wait_all().
Unlike ncmpi_iput_var@var{<kind>}_@var{<type>}, once the call to this API
returns, the caller is free to change the contents of write buffer.

@var{<kind>}: <none>, '1', 'a', 's', or 'm'.

@heading Data types
@html
<table cellpadding="4" border="1">
<tr class="spacer" align=center>
    <td> &lt;<b>type  </b>&gt; for API names </td>
    <td> &lt;<b>C type</b>&gt; for API arguments </td>
</tr>
<tr align=center> <td>text     </td> <td>char             </td> </tr>
<tr align=center> <td>schar    </td> <td>signed char      </td> </tr>
<tr align=center> <td>short    </td> <td>short            </td> </tr>
<tr align=center> <td>int      </td> <td>int              </td> </tr>
<tr align=center> <td>float    </td> <td>float            </td> </tr>
<tr align=center> <td>double   </td> <td>double           </td> </tr>
<tr align=center> <td>uchar    </td> <td>unsigned char    </td> </tr>
<tr align=center> <td>ushort   </td> <td>unsigned short   </td> </tr>
<tr align=center> <td>uint     </td> <td>unsigned int     </td> </tr>
<tr align=center> <td>longlong </td> <td>long long        </td> </tr>
<tr align=center> <td>ulonglong</td> <td>unsigned longlong</td> </tr>
</table>
@end html

@heading Operational Mode
Prior to version 1.7.0, nonblocking APIs must be called while the netCDF file is in data mode.
Starting from 1.7.0, nonblocking APIs can be called in either define or data mode.
This API family can be called in either collective or independent data mode.

@heading Usage
@example
int ncmpi_buffer_attach    (int         ncid,
                            MPI_Offset  bufsize);

int ncmpi_buffer_detach    (int ncid);

int ncmpi_bput_var_@strong{<type>}  (int               ncid,
                            int                varid,
                            const @strong{<C type>}   *buf,
                            int               *request);

int ncmpi_bput_var1_@strong{<type>} (int               ncid,
                            int                varid,
                            const MPI_Offset   start[],
                            const @strong{<C type>}   *buf,
                            int               *request);

int ncmpi_bput_vara_@strong{<type>} (int               ncid,
                            int                varid,
                            const MPI_Offset   start[],
                            const MPI_Offset   count[],
                            const @strong{<C type>}   *buf,
                            int               *request);

int ncmpi_bput_vars_@strong{<type>} (int               ncid,
                            int                varid,
                            const MPI_Offset   start[],
                            const MPI_Offset   count[],
                            const MPI_Offset   stride[],
                            const @strong{<C type>}   *buf,
                            int               *request);

int ncmpi_bput_varm_@strong{<type>} (int               ncid,
                            int                varid,
                            const MPI_Offset   start[],
                            const MPI_Offset   count[],
                            const MPI_Offset   stride[],
                            const MPI_Offset   imap[],
                            const @strong{<C type>}   *buf,
                            int               *request);
@end example
Flexible APIs:
@example
int ncmpi_bput_var  (int                ncid,
                     int                varid,
                     const void        *buf,
                     MPI_Offset         bufcount,
                     MPI_Datatype       buftype,
                     int               *request);

int ncmpi_bput_var1 (int                ncid,
                     int                varid,
                     const MPI_Offset   start[],
                     const void        *buf,
                     MPI_Offset         bufcount,
                     MPI_Datatype       buftype,
                     int               *request);

int ncmpi_bput_vara (int                ncid,
                     int                varid,
                     const MPI_Offset   start[],
                     const MPI_Offset   count[],
                     const void        *buf,
                     MPI_Offset         bufcount,
                     MPI_Datatype       buftype,
                     int               *request);

int ncmpi_bput_vars (int                ncid,
                     int                varid,
                     const MPI_Offset   start[],
                     const MPI_Offset   count[],
                     const MPI_Offset   stride[],
                     const void        *buf,
                     MPI_Offset         bufcount,
                     MPI_Datatype       buftype,
                     int               *request);

int ncmpi_bput_varm (int                ncid,
                     int                varid,
                     const MPI_Offset   start[],
                     const MPI_Offset   count[],
                     const MPI_Offset   stride[],
                     const MPI_Offset   imap[],
                     const void        *buf,
                     MPI_Offset         bufcount,
                     MPI_Datatype       buftype,
                     int               *request);
@end example

@table @code

@item ncid
NetCDF ID, from a previous call to ncmpi_open or ncmpi_create.

@item varid
Variable ID. Different MPI processes may use different variable IDs.

@item start
A vector of MPI_Offset integers specifying the index in the variable
where the first of the data values will be written. The indices are
relative to 0, so for example, the first data value of a variable
would have index (0, 0, ... , 0). The elements of start correspond, in
order, to the variable's dimensions. Hence, if the variable is a
record variable, the first index corresponds to the starting record
number for writing the data values.

@item count
A vector of MPI_Offset integers specifying the number of indices selected
along each dimension. To write a single value, for example, specify
count as (1, 1, ... , 1). The elements of count correspond, in order,
to the variable's dimensions. Hence, if the variable is a record
variable, the first element of count corresponds to a count of the
number of records to write.

@item stride
A vector of MPI_Offset integers that specifies the sampling interval
along each dimension of the netCDF variable. The elements of the
stride vector correspond, in order, to the netCDF variable's
dimensions (stride[0] gives the sampling interval along the most
slowly varying dimension of the netCDF variable). Sampling intervals
are specified in type-independent units of elements (a value of 1
selects consecutive elements of the netCDF variable along the
corresponding dimension, a value of 2 selects every other element,
etc.). A NULL stride argument is treated as (1, 1, ... , 1).

@item imap
A vector of MPI_Offset integers that specifies the mapping between the
dimensions of a netCDF variable and the in-memory structure of the
internal data array. The elements of the index mapping vector
correspond, in order, to the netCDF variable's dimensions (imap[0]
gives the distance between elements of the internal array
corresponding to the most slowly varying dimension of the netCDF
variable). Distances between elements are specified in
type-independent units of elements (the distance between internal
elements that occupy adjacent memory locations is 1 and not the
element's byte-length as in netCDF 2). A NULL argument means the
memory-resident values have the same structure as the associated
netCDF variable.

@item buf
Pointer to the location used for computing where the data values will
be found; the data should be of the type appropriate for the function
called. If the type of data values differs from the netCDF variable
type, type conversion will occur.
@c @xref{Type Conversion,,, pnetcdf, The PnetCDF Users Guide}.

@item bufcount
An integer indicates the number of MPI derived data type elements in the buf to be written to the file.

@item buftype
An MPI derived data type that describes the memory layout of buf.
Starting from PnetCDF version 1.6.0, buftype can be MPI_DATATYPE_NULL.
In this case, bufcount is ignored and the buf's data type must match the type
of the variable defined in the file - no data conversion will be done.

@item request
The nonblocking request ID returned by PnetCDF. It is to be used in a successive call to ncmpi_wait_all() or ncmpi_wait() for the completion of the nonblocking operation.

@item bufsize
The size of buffer users allow PnetCDF to allocate and use internally. The
internal buffer will be used to aggregate multiple nonblocking buffered
requests for better performance. The value can be different across processes.

@end table

@heading Return Error Codes
ncmpi_bput_var@var{<kind>}_@var{<type>} returns the value NC_NOERR if no errors
occurred. Otherwise, the returned status indicates an error. Possible
causes of errors include:
@itemize
@item NC_EBADID: The specified netCDF ID does not refer to an opened netCDF file.
@item NC_EPERM: Attempt write operations in read-only file.
@item NC_ENOTVAR: The variable ID is invalid for the specified netCDF file.
@item NC_EGLOBAL: NC_GLOBAL is considered invalid for these APIs.
@item NC_EINVALCOORDS: The specified corner indices were out of range for the rank of the specified variable. For example, a negative index, or an index that is larger than the corresponding dimension length will cause an error.
@item NC_EEDGE: The specified edge lengths added to the specified corner would have referenced data out of range for the rank of the specified variable. For example, an edge length that is larger than the corresponding dimension length minus the corner index will cause an error.
@item NC_ERANGE: One or more of the specified values are out of the range of values representable by the external data type of the variable. (Does not apply to the ncmpi_get_var() and ncmpi_get_var_all()). Note NC_ERANGE is not a fatal error. The nonblocking request will be still added to the queue when NC_ERANGE is returned. Users are responsible to ensure no pending request exists when closing the file.
@item NC_ECHAR: Attempt to convert numerical values to or from text data.
@item NC_ENOMEM: Out of memory.
@item NC_ENULLSTART: It is illegal for argument starts being a NULL.
@item NC_EINSUFFBUF: The attached buffer ran out of space.
@item NC_EIOMISMATCH: The number of variable elements requested in (bufcount, buftype) mismatches the one calculated from count. This error may only occur for flexible APIs.
@item NC_ENOTSUPPORT: This API for NetCDF-4 files is not yet supported.
@end itemize


@heading Example
Here is an example using ncmpi_bput_vara_double to add or change all the values
of the variable named rh to 0.5 in an existing netCDF file named foo.nc. For
simplicity in this example, we assume that we know that rh is dimensioned with
time, lat, and lon, and that there are three time values, five lat values, and
ten lon values.

@example
#include <pnetcdf.h>
   ...
#define TIMES 0
#define LATS  5
#define LONS  10
int  status;                       /* error status */
int  ncid;                         /* netCDF ID */
int  rh_id;                        /* variable ID */
int  request[2];                   /* nonblocking request ID */
int  st[2];                        /* nonblocking request status */
MPI_Offset start[3] = @{0, 0, 0@};    /* start at first value */
MPI_Offset count[3] = @{TIMES, LATS/2, LONS/2@};
double rh_vals[LATS/2*LONS/2];   /* array to hold values */
int i;
   ...
status = @ref{ncmpi_create}(MPI_COMM_WORLD, "foo.nc", NC_CLOBBER | NC_64BIT_DATA, MPI_INFO_NULL, &ncid);
if (status != NC_NOERR) handle_error(status);
   ...
/* define dimensions and variable */
   ...

/* attach buffer */
status = @ref{ncmpi_bput_var@var{<kind>}_@var{<type>}, ncmpi_buffer_attach}(ncid, LATS*LONS*sizeof(double));
if (status != NC_NOERR) handle_error(status);

/* write values into netCDF variable */
status = @ref{ncmpi_bput_var@var{<kind>}_@var{<type>}, ncmpi_bput_vara_double}(ncid, rh_id, start, count, rh_vals, &request[0]);
if (status != NC_NOERR) handle_error(status);

start[1] = LATS/2;
start[2] = LONS/2;
count[1] = LATS - LATS/2;
count[2] = LONS - LONS/2;
/* change contents of rh_vals[] */
status = @ref{ncmpi_bput_var@var{<kind>}_@var{<type>}, ncmpi_bput_vara_double}(ncid, rh_id, start, count, rh_vals, &request[1]);
if (status != NC_NOERR) handle_error(status);

status = @ref{ncmpi_wait/wait_all, ncmpi_wait_all}(ncid, 2, request, st);
if (status != NC_NOERR) handle_error(status);

status = @ref{ncmpi_bput_var@var{<kind>}_@var{<type>}, ncmpi_buffer_detach}(ncid);
if (status != NC_NOERR) handle_error(status);
@end example

@heading Full example C program
@itemize
@item
@url{https://github.com/Parallel-NetCDF/PnetCDF/tree/master/examples/C/nonblocking_write.c, nonblocking_write.c}
@item
The above programs are available in all PnetCDF releases under directory examples/C.
@end itemize

@node ncmpi_bput_varn_@var{<type>}, ncmpi_wait/wait_all, ncmpi_bput_var@var{<kind>}_@var{<type>}, Variables
@section Nonblockingly Buffered Write a List of Subarrays: ncmpi_bput_varn_@var{<type>}
@findex ncmpi_bput_varn_text
@findex ncmpi_bput_varn_uchar
@findex ncmpi_bput_varn_schar
@findex ncmpi_bput_varn_short
@findex ncmpi_bput_varn_int
@findex ncmpi_bput_varn_float
@findex ncmpi_bput_varn_double
@findex ncmpi_bput_varn_ushort
@findex ncmpi_bput_varn_unit
@findex ncmpi_bput_varn_longlong
@findex ncmpi_bput_varn_ulonglong
@cindex ncmpi_bput_varn_text, example
@cindex ncmpi_bput_varn_uchar, example
@cindex ncmpi_bput_varn_schar, example
@cindex ncmpi_bput_varn_short, example
@cindex ncmpi_bput_varn_int, example
@cindex ncmpi_bput_varn_float, example
@cindex ncmpi_bput_varn_double, example
@cindex ncmpi_bput_varn_ushort, example
@cindex ncmpi_bput_varn_unit, example
@cindex ncmpi_bput_varn_longlong, example
@cindex ncmpi_bput_varn_ulonglong, example
@cindex nonblocking buffered write a list of subarrays
@vindex NC_REQ_ALL

The ncmpi_bput_varn_@var{<type>} family of functions is the buffered version of
ncmpi_iput_varn_@var{<type>} family.  The functions write, in a nonblocking
fashion, a list of subarrays into a netCDF variable of an opened netCDF
file.

The write data is buffered (cached) internally by PnetCDF and will be flushed
to the file at the time of calling ncmpi_wait() or ncmpi_wait_all().
Unlike ncmpi_iput_varn_@var{<type>}, once the call to this API returns,
the caller is free to change the contents of write buffer.

The part of the netCDF variable to write is specified by giving a list of
subarrays and each subarray is specified by a corner and a vector of edge
lengths that refer to an array section of the netCDF variable. For each
subarray, the values to be written are associated with the netCDF variable by
assuming that the last dimension of the netCDF variable varies fastest in the C
interface.

This API essentially has the same effect of making multiple calls to ncmpi_iput_vara_@var{<type>} with the same variable ID.

@heading Data types
@html
<table cellpadding="4" border="1">
<tr class="spacer" align=center>
    <td> &lt;<b>type  </b>&gt; for API names </td>
    <td> &lt;<b>C type</b>&gt; for API arguments </td>
</tr>
<tr align=center> <td>text     </td> <td>char             </td> </tr>
<tr align=center> <td>schar    </td> <td>signed char      </td> </tr>
<tr align=center> <td>short    </td> <td>short            </td> </tr>
<tr align=center> <td>int      </td> <td>int              </td> </tr>
<tr align=center> <td>float    </td> <td>float            </td> </tr>
<tr align=center> <td>double   </td> <td>double           </td> </tr>
<tr align=center> <td>uchar    </td> <td>unsigned char    </td> </tr>
<tr align=center> <td>ushort   </td> <td>unsigned short   </td> </tr>
<tr align=center> <td>uint     </td> <td>unsigned int     </td> </tr>
<tr align=center> <td>longlong </td> <td>long long        </td> </tr>
<tr align=center> <td>ulonglong</td> <td>unsigned longlong</td> </tr>
</table>
@end html

@heading Operational Mode
Prior to version 1.7.0, nonblocking APIs must be called while the netCDF file is in data mode.
Starting from 1.7.0, nonblocking APIs can be called in either define or data mode.
This API family can be called in either collective or independent data mode.

@heading Usage
@example
int ncmpi_bput_varn_@strong{<type>}     (int               ncid,
                                int               varid,
                                int               num,
                                const MPI_Offset  starts[num][],
                                const MPI_Offset  counts[num][],
                                const @strong{<C type>}   *buf,
                                int              *request);

int ncmpi_bput_varn            (int               ncid,
                                int               varid,
                                int               num,
                                const MPI_Offset  starts[num][],
                                const MPI_Offset  counts[num][],
                                const void       *buf,
                                MPI_Offset        bufcount,
                                MPI_Datatype      buftype,
                                int              *request);
@end example

@table @code

@item ncid
NetCDF ID, from a previous call to ncmpi_open or ncmpi_create.

@item varid
Variable ID. Different MPI processes may use different variable IDs.

@item num
Nnumber of subarray requests.

@item starts
A double pointer that mimics a 2D array of size [num][ndims].
See below for example of how to allocate space and construct such a 2D array.
Each starts[i] is a vector specifying the index in the variable where the first of the data values will be written.
The indices are relative to 0, so for example, the first data value of a variable would have index (0, 0, ... , 0).
The size of starts must be [num][ndims], where ndims is the number of dimensions of the specified variable.
The elements of each starts[i] must correspond to the variable's dimensions in order.
Hence, if the variable is a record variable, the first index of each starts[i] would correspond to the starting record number for writing the data values.

@item counts
A double pointer that mimics a 2D array of size [num][ndims].
See below for example of how to allocate space and construct such a 2D array.
Each counts[i] is a vector specifying the edge lengths along each dimension of the block of data values to be written.
To write a single value, for example, specify count as (1, 1, ... , 1).
The size of counts should be [num][ndims], where ndims is the number of dimensions of the specified variable.
The elements of count correspond to the variable's dimensions.
Hence, if the variable is a record variable, the first element of each counts[i] corresponds to a count of the number of records to write.
This argument can be NULL, in which case it is equivalent to providing counts[*][*]=(1, 1, ... , 1).

@item buf
A pointer to the memory address that contains the data values to be written. If the type of data values differs from the netCDF variable type, type conversion will occur.
@c @xref{Type Conversion,,, pnetcdf, The PnetCDF Users Guide}.

@item bufcount
An integer indicates the number of MPI derived data type elements in the buffer pointed by buf to be written to the file.

@item buftype
An MPI derived data type that describes the memory layout of buf.
Starting from PnetCDF version 1.6.0, buftype can be MPI_DATATYPE_NULL.
In this case, bufcount is ignored and the buf's data type must match the type
of the variable defined in the file - no data conversion will be done.

@item request
The nonblocking request ID returned by PnetCDF. It is to be used in a successive call to ncmpi_wait_all() or ncmpi_wait() for the completion of the nonblocking operation.

Starting from 1.7.0, the request argument can be NULL, meaning the caller does not
intend to track the requests IDs. In this case, a call to
ncmpi_wait_all/ncmpi_wait must use NC_REQ_ALL in its second argument "num" to
flush all pending nonblocking requests.

@end table

@heading Return Error Codes
ncmpi_bput_varn_@var{<type>} returns the value NC_NOERR if no errors
occurred. Otherwise, the returned status indicates an error. Possible
causes of errors include:
@itemize
@item NC_EBADID: The specified netCDF ID does not refer to an opened netCDF file.
@item NC_EPERM: Attempt write operations in read-only file.
@item NC_ENOTVAR: The variable ID is invalid for the specified netCDF file.
@item NC_EGLOBAL: NC_GLOBAL is considered invalid for these APIs.
@item NC_EINVALCOORDS: The specified corner indices were out of range for the rank of the specified variable. For example, a negative index, or an index that is larger than the corresponding dimension length will cause an error.
@item NC_EEDGE: The specified edge lengths added to the specified corner would have referenced data out of range for the rank of the specified variable. For example, an edge length that is larger than the corresponding dimension length minus the corner index will cause an error.
@item NC_ERANGE: One or more of the specified values are out of the range of values representable by the external data type of the variable. (Does not apply to the ncmpi_get_var() and ncmpi_get_var_all()).
@item NC_ECHAR: Attempt to convert numerical values to or from text data.
@item NC_ENOMEM: Out of memory.
@item NC_ENULLSTART: It is illegal for argument starts being a NULL.
@item NC_EIOMISMATCH: The number of variable elements requested in (bufcount, buftype) mismatches the one calculated from counts. This error may only occur for flexible APIs.
@item NC_ENOTSUPPORT: This API for NetCDF-4 files is not yet supported.
@end itemize


@heading Example

This example shows how to use a single call of ncmpi_put_varn_float_all()
to write a sequence of requests with arbitrary array indices.

@example
#include <pnetcdf.h>
    ...
#define MAX_NUM_REQS 6
#define NDIMS        2

int  i, j;
int  rank;                         /* MPI process rank ID */
int  err;                          /* error status */
int  ncid;                         /* netCDF ID */
int  varid;                        /* variable ID */
int  num_reqs;                     /* number of subarray requests */
int  dimid[2];                     /* dimension IDs */
int  request[1];                   /* nonblocking request ID */
int  st[1];                        /* nonblocking request status */
int  buf_len;                      /* number of elements in buffer */
float *buffer;                     /* write buffer to hold values */
MPI_Offset **starts, **counts;
    ...
MPI_Comm_rank(MPI_COMM_WORLD, &rank);

err = @ref{ncmpi_create}(MPI_COMM_WORLD, "foo.nc", NC_CLOBBER, MPI_INFO_NULL, &ncid);

if (err != NC_NOERR) handle_error(err);

err = @ref{ncmpi_def_dim}(ncid, "Y", 4,  &dimid[0]);
err = @ref{ncmpi_def_dim}(ncid, "X", 10, &dimid[1]);
err = @ref{ncmpi_def_var}(ncid, "var", NC_FLOAT, 2, dimid, &varid);
err = @ref{ncmpi_enddef}(ncid);

/* allocate starts and counts */
starts    = (MPI_Offset**) malloc(MAX_NUM_REQS*       sizeof(MPI_Offset*));
starts[0] = (MPI_Offset*)  calloc(MAX_NUM_REQS*NDIMS, sizeof(MPI_Offset));
for (i=1; i<MAX_NUM_REQS; i++)
    starts[i] = starts[i-1] + NDIMS;

counts    = (MPI_Offset**) malloc(MAX_NUM_REQS*       sizeof(MPI_Offset*));
counts[0] = (MPI_Offset*)  calloc(MAX_NUM_REQS*NDIMS, sizeof(MPI_Offset));
for (i=1; i<MAX_NUM_REQS; i++)
    counts[i] = counts[i-1] + NDIMS;

if (rank == 0) @{
    num_reqs = 4;
    starts[0][0] = 0; starts[0][1] = 5; counts[0][0] = 1; counts[0][1] = 2;
    starts[1][0] = 1; starts[1][1] = 0; counts[1][0] = 1; counts[1][1] = 1;
    starts[2][0] = 2; starts[2][1] = 6; counts[2][0] = 1; counts[2][1] = 2;
    starts[3][0] = 3; starts[3][1] = 0; counts[3][0] = 1; counts[3][1] = 3;
    /* rank 0 is writing the following locations: ("-" means skip)
              -  -  -  -  -  0  0  -  -  -
              0  -  -  -  -  -  -  -  -  -
              -  -  -  -  -  -  0  0  -  -
              0  0  0  -  -  -  -  -  -  -
     */
@} else if (rank == 1) @{
    num_reqs = 6;
    starts[0][0] = 0; starts[0][1] = 3; counts[0][0] = 1; counts[0][1] = 2;
    starts[1][0] = 0; starts[1][1] = 8; counts[1][0] = 1; counts[1][1] = 2;
    starts[2][0] = 1; starts[2][1] = 5; counts[2][0] = 1; counts[2][1] = 2;
    starts[3][0] = 2; starts[3][1] = 0; counts[3][0] = 1; counts[3][1] = 2;
    starts[4][0] = 2; starts[4][1] = 8; counts[4][0] = 1; counts[4][1] = 2;
    starts[5][0] = 3; starts[5][1] = 4; counts[5][0] = 1; counts[5][1] = 3;
    /* rank 1 is writing the following locations: ("-" means skip)
              -  -  -  1  1  -  -  -  1  1
              -  -  -  -  -  1  1  -  -  -
              1  1  -  -  -  -  -  -  1  1
              -  -  -  -  1  1  1  -  -  -
     */
@} else if (rank == 2) @{
    num_reqs = 5;
    starts[0][0] = 0; starts[0][1] = 7; counts[0][0] = 1; counts[0][1] = 1;
    starts[1][0] = 1; starts[1][1] = 1; counts[1][0] = 1; counts[1][1] = 3;
    starts[2][0] = 1; starts[2][1] = 7; counts[2][0] = 1; counts[2][1] = 3;
    starts[3][0] = 2; starts[3][1] = 2; counts[3][0] = 1; counts[3][1] = 1;
    starts[4][0] = 3; starts[4][1] = 3; counts[4][0] = 1; counts[4][1] = 1;
    /* rank 2 is writing the following locations: ("-" means skip)
              -  -  -  -  -  -  -  2  -  -
              -  2  2  2  -  -  -  2  2  2
              -  -  2  -  -  -  -  -  -  -
              -  -  -  2  -  -  -  -  -  -
     */
@} else if (rank == 3) @{
    num_reqs = 4;
    starts[0][0] = 0; starts[0][1] = 0; counts[0][0] = 1; counts[0][1] = 3;
    starts[1][0] = 1; starts[1][1] = 4; counts[1][0] = 1; counts[1][1] = 1;
    starts[2][0] = 2; starts[2][1] = 3; counts[2][0] = 1; counts[2][1] = 3;
    starts[3][0] = 3; starts[3][1] = 7; counts[3][0] = 1; counts[3][1] = 3;
    /* rank 3 is writing the following locations: ("-" means skip)
              3  3  3  -  -  -  -  -  -  -
              -  -  -  -  3  -  -  -  -  -
              -  -  -  3  3  3  -  -  -  -
              -  -  -  -  -  -  -  3  3  3
     */
@} else @{
    num_reqs = 0;
@}

/* allocate write buffer */
buf_len = 0;
for (i=0; i<num_reqs; i++) @{
    MPI_Offset w_req_len=1;
    for (j=0; j<NDIMS; j++)
        w_req_len *= counts[i][j];
    buf_len += w_req_len;
@}
buffer = (float*) malloc(buf_len * sizeof(float));
for (i=0; i<buf_len; i++) buffer[i] = (float)rank;

 /* write values into netCDF variable */
 err = @ref{ncmpi_bput_varn_@var{<type>}, ncmpi_bput_varn_float}(ncid, varid, num_reqs, starts, counts, buffer, &request[0]);
 if (err != NC_NOERR) handle_error(err);
    ...
 /* wait for the nonblocking operation to complete */
 status = @ref{ncmpi_wait/wait_all, ncmpi_wait_all}(ncid, 1, request, st);
 if (status != NC_NOERR) handle_error(status);

 err = @ref{ncmpi_close}(ncid);
 if (err != NC_NOERR) handle_error(err);

/*    % ncmpidump foo.nc
 *    netcdf foo @{
 *    dimensions:
 *             Y = 4 ;
 *             X = 10 ;
 *    variables:
 *             float var(Y, X) ;
 *    data:
 *
 *     var =
 *       3, 3, 3, 1, 1, 0, 0, 2, 1, 1,
 *       0, 2, 2, 2, 3, 1, 1, 2, 2, 2,
 *       1, 1, 2, 3, 3, 3, 0, 0, 1, 1,
 *       0, 0, 0, 2, 1, 1, 1, 3, 3, 3 ;
 *    @}
 */
@end example

@heading Full example C program
@itemize
@item
@url{https://github.com/Parallel-NetCDF/PnetCDF/tree/master/examples/C/bput_varn_uint.c, bput_varn_uint.c}
@item
The above programs are available in all PnetCDF releases under directory examples/C.
@end itemize

@node ncmpi_wait/wait_all, ncmpi_inq_nreqs, ncmpi_bput_varn_@var{<type>}, Variables
@section Nonblocking I/O Completion: ncmpi_wait/wait_all
@findex ncmpi_wait
@findex ncmpi_wait_all
@cindex ncmpi_wait/wait_all, example
@cindex nonblocking I/O completion
@vindex NC_REQ_ALL
@vindex NC_GET_REQ_ALL
@vindex NC_PUT_REQ_ALL

APIs ncmpi_wait and ncmpi_wait_all are blocking calls that wait for the completion of nonblocking I/O
requests. The nonblocking requests intended to complete are specified in the
array of request IDs, array_of_requests[]. The request IDs can be all or a
subset of nonblocking requests made earlier. The array can contain mixed read
and write request IDs. Argument array_of_statuses will be returned with the
statuses of individual requests. The request can be used later to query the
status of the put operation or wait for the write to complete. These APIs must
be called in data mode. After the called return, the caller are free to access
the put buffers used in the nonblocking requests.

@heading Operational Mode
API ncmpi_wait is an independent subroutine and must be called while the file is in independent data mode.

API ncmpi_wait_all is a collective subroutine and must be called while the file is in collective data mode.

@heading Usage
@example
int ncmpi_wait     (int ncid,
                    int num,
                    int array_of_requests[],
                    int array_of_statuses[]);

int ncmpi_wait_all (int ncid,
                    int num,
                    int array_of_requests[],
                    int array_of_statuses[]);
@end example

@table @code
@item ncid
NetCDF ID, from a previous call to ncmpi_open or ncmpi_create.
@item num
Number of requests. It is also the array size of the next two arguments,
array_of_requests and array_of_statuses.

Starting from 1.7.0, NC_REQ_ALL can be used, indicating to flush all pending nonblocking requests. In this case, the next two argument, array_of_requests and array_of_statuses will be ignored. Thus array_of_requests and array_of_statuses can be NULLs.
Starting from 1.7.1, NC_GET_REQ_ALL and NC_PUT_REQ_ALL can be used, indicating to flush all pending nonblocking GET and PUT requests, respectively. In this case, the next two argument, array_of_requests and array_of_statuses will be ignored.

@item array_of_requests[]
A vector of integers specifying the nonblocking request IDs that were made
earlier. The size of the vector should be equal to the values given in 'num'.

For each nonblocking request of a successful completion, its corresponding request ID in the array is set to NC_REQ_NULL.

@item array_of_statuses[]
A vector of integers returned from the call, specifying the statuses of
corresponding nonblocking requests. The size of the vector should be equal to
the values given in 'num'. The values can be used in a call to ncmpi_strerror()
to obtain the status messages.

Starting from 1.7.0, this argument can be NULL, indicating the caller's intention to ignore the errors for individual nonblocking requests and rely on the error code returned from this API call.
The error code returned from this API call is the first error encountered while flushing the requests.

@end table

@heading Return Error Codes
ncmpi_wait/ncmpi_wait_all returns the value NC_NOERR if no errors
occurred. Otherwise, the returned status indicates an error. Possible
causes of errors include:
@itemize
@item NC_EBADID: The specified netCDF ID does not refer to an opened netCDF file.
@item NC_EINDEP: Attempt collective I/O operations in independent data mode.
@item NC_ENOTINDEP: Attempt independent I/O operations in collective data mode.
@item NC_ENOTSUPPORT: This API for NetCDF-4 files is not yet supported.
@end itemize

@heading Example
Here is an example using ncmpi_wait_all and checking the returned status.

@example
#include <pnetcdf.h>
   ...
int request[10];    /* nonblocking request IDs */
int st[10];         /* nonblocking request statuses */
int i, err;
   ...

err = @ref{ncmpi_wait/wait_all, ncmpi_wait_all}(ncid, 10, request, st);

if (err != NC_NOERR)
    fprintf(stderr, "Error on calling ncmpi_wait_all (%s)\n",
            @ref{ncmpi_strerror}(err));

for (i=0; i<10; i++)
    if (st[i] != NC_NOERR)
        fprintf(stderr, "Error on request %d (%s)\n", i,
                @ref{ncmpi_strerror}(st[i]));
@end example

@node ncmpi_inq_nreqs, ncmpi_inq_buffer Family, ncmpi_wait/wait_all, Variables
@section Inquire the number of pending nonblocking requests: ncmpi_inq_nreqs
@findex ncmpi_inq_nreqs
@cindex ncmpi_inq_nreqs, example
@cindex inquire nonblocking I/O

This API reports the number of pending nonblocking requests.

@heading Operational Mode
This API is an independent subroutine.

This API can be called while the file is in either define or data mode (collective or independent).

@heading Usage
@example
int ncmpi_inq_nreqs(int  ncid,
                    int *nreqs);
@end example

@table @code
@item ncid
NetCDF ID, from a previous call to ncmpi_open or ncmpi_create.
@item nreqs
Number of pending requests.
Prior to 1.9.0, if this argument is NULL, error code NC_EINVAL is returned.
Starting from 1.9.0, if this argument is NULL, it is ignored.
@end table

@heading Return Error Codes
ncmpi_inq_nreqs returns the value NC_NOERR if no errors occurred. Otherwise, the returned status indicates an error. Possible causes of errors include:
@itemize
@item NC_EBADID: The specified netCDF ID does not refer to an opened netCDF file.
@item NC_ENOTSUPPORT: This API for NetCDF-4 files is not yet supported.
@end itemize

@heading Example
Here is an example using ncmpi_inq_nreqs.

@example
#include <pnetcdf.h>
   ...
int nreqs, err;
   ...

err = @ref{ncmpi_inq_nreqs}(ncid, &nreqs);

if (err != NC_NOERR)
    fprintf(stderr, "Error on calling ncmpi_inq_nreqs (%s)\n",
            @ref{ncmpi_strerror}(err));
@end example

@node ncmpi_inq_buffer Family, ncmpi_cancel, ncmpi_inq_nreqs, Variables
@section Inquire the metadata of attached buffer used in buffered nonblocking put APIs
@findex ncmpi_inq_buffer_usage
@findex ncmpi_inq_buffer_size
@cindex ncmpi_inq_buffer_usage, example
@cindex ncmpi_inq_buffer_size, example
@cindex inquire the metadata of attached buffer used in buffered nonblocking put APIs

A family of functions that returns information about the attached buffer
used by buffered nonblocking put APIs.

ncmpi_inq_buffer_usage returns the current usage (in bytes) of the attached buffer (version 1.3.1 and later).

ncmpi_inq_buffer_size returns the size (in bytes) of the attached buffer (version 1.6.0 and later).

@heading Operational Mode
These APIs are independent subroutines.

These APIs can be called while the file is in either define or data mode (collective or independent).

@heading Usage
@example
int ncmpi_inq_buffer_usage(int         ncid,
                           MPI_Offset *usage);

int ncmpi_inq_buffer_size (int         ncid,
                           MPI_Offset *buf_size);
@end example

@table @code
@item ncid
NetCDF ID, from a previous call to ncmpi_open or ncmpi_create.
@item usage
The current usage of the internal buffer. Its value in bytes shows much space
is left for any further buffered APIs calls.
Prior to 1.9.0, if this argument is NULL, error code NC_EINVAL is returned.
Starting from 1.9.0, if this argument is NULL, it is ignored.
@item buf_size
The size (in number of bytes) of the attached buffer.
This value is the same as the one used in a call to ncmpi_buffer_attach() earlier.
Prior to 1.9.0, if this argument is NULL, error code NC_EINVAL is returned.
Starting from 1.9.0, if this argument is NULL, it is ignored.
@end table

@heading Return Error Codes
ncmpi_inq_buffer_usage/ncmpi_inq_buffer_size returns the value NC_NOERR if no errors occurred.
Otherwise, the returned status indicates an error. Possible causes of errors include:
@itemize
@item NC_EBADID: The specified netCDF ID does not refer to an opened netCDF file.
@item NC_ENULLABUF: no attached buffer is found
@item NC_ENOTSUPPORT: This API for NetCDF-4 files is not yet supported.
@end itemize

@heading Example
Here is an example using ncmpi_inq_buffer_usage and ncmpi_inq_buffer_size.

@example
#include <pnetcdf.h>
   ...
int varid1, varid2, varid3, nreqs, err;
int i_buf[8], req_ids[10], st[10];
long long ll_buf[10];
double d_buf[20], d2_buf[12];
MPI_Offset start1[2], count1[2], start2[3], count2[3];
MPI_Offset start3[2], count3[2], usage, buf_size;
   ...

/* attach buffer of size 1MB */
status = @ref{ncmpi_bput_var@var{<kind>}_@var{<type>}, ncmpi_buffer_attach}(ncid, 1048576);
if (status != NC_NOERR) handle_error(status);

/* several writes into netCDF variables */
status = @ref{ncmpi_bput_var@var{<kind>}_@var{<type>}, ncmpi_bput_vara_double}(ncid, varid1, start1, count1, d_buf, &request[0]);
if (status != NC_NOERR) handle_error(status);

status = @ref{ncmpi_bput_var@var{<kind>}_@var{<type>}, ncmpi_bput_vara_int}(ncid, varid2, start2, count2, i_buf, &request[1]);
if (status != NC_NOERR) handle_error(status);

status = @ref{ncmpi_bput_var@var{<kind>}_@var{<type>}, ncmpi_bput_vars_longlong}(ncid, varid3, start3, count3, stride3, ll_buf, &request[2]);
if (status != NC_NOERR) handle_error(status);

/* check the usage of the buffer */
status = @ref{ncmpi_inq_buffer Family, ncmpi_inq_buffer_usage}(ncid, &usage);
if (status != NC_NOERR) handle_error(status);

/* inquire the attached buffer size */
status = @ref{ncmpi_inq_buffer Family, ncmpi_inq_buffer_size}(ncid, &buf_size);
if (status != NC_NOERR) handle_error(status);

status = @ref{ncmpi_bput_var@var{<kind>}_@var{<type>}, ncmpi_bput_var_double}(ncid, varid4, d2_buf, &request[3]);
if (status != NC_NOERR) handle_error(status);

/* wait here for all 4 nonblocking APIs to complete */
status = @ref{ncmpi_wait/wait_all, ncmpi_wait_all}(ncid, 4, request, st);
if (status != NC_NOERR) handle_error(status);

/* release buffer */
status = @ref{ncmpi_bput_var@var{<kind>}_@var{<type>}, ncmpi_buffer_detach}(ncid);
if (status != NC_NOERR) handle_error(status);
@end example


@node ncmpi_cancel, , ncmpi_inq_buffer Family, Variables
@section Cancel pending nonblocking requests: ncmpi_cancel
@findex ncmpi_cancel
@cindex ncmpi_cancel, example
@cindex nonblocking I/O
@vindex NC_REQ_ALL
@vindex NC_GET_REQ_ALL
@vindex NC_PUT_REQ_ALL

This API cancels a list of pending nonblocking requests made by
ncmpi_iput_var@var{<kind>}_@var{<type>},
ncmpi_iget_var@var{<kind>}_@var{<type>} or
ncmpi_bput_var@var{<kind>}_@var{<type>} API families.

@heading Operational Mode
This API is an independent subroutine.

This API can be called in either independent or collective data mode.
Starting from 1.7.1, this API can also be called in define mode.

@heading Usage
@example
int ncmpi_cancel(int  ncid,
                 int  num_req,
                 int *req_ids,
                 int *statuses);
@end example

@table @code
@item ncid
NetCDF ID, from a previous call to ncmpi_open or ncmpi_create.
@item num_reqs
Number of pending requests.

Starting from 1.7.0, NC_REQ_ALL can be used, indicating to cancel all pending nonblocking requests.
Starting from 1.7.1, NC_GET_REQ_ALL and NC_PUT_REQ_ALL can be used, indicating to cancel all pending nonblocking GET and PUT requests, respectively.
@item req_ids
An integer array contains the nonblocking request IDs.
Starting from 1.7.0, the request argument can be NULL, meaning the caller does not
intend to track the requests IDs. In this case, a call to
ncmpi_wait_all/ncmpi_wait must use NC_REQ_ALL in its second argument "num" to
flush all pending nonblocking requests.

For each nonblocking request of a successful cancellation, its corresponding request ID in the array is set to NC_REQ_NULL.

@item statuses
An integer array of cancellation statuses, each of which corresponds to the
nonblocking request IDs.
@end table

@heading Return Error Codes
ncmpi_cancel returns the value NC_NOERR if no errors occurred. Otherwise, the
returned status indicates an error. Possible causes of errors include:
@itemize
@item NC_EBADID: The specified netCDF ID does not refer to an opened netCDF file.
@item NC_EINVAL_REQUEST: Invalid nonblocking request ID (individual errors in statuses array)
@item NC_ENOTSUPPORT: This API for NetCDF-4 files is not yet supported.
@end itemize

@heading Example
@example
#include <pnetcdf.h>
   ...
int i, ncid, num_reqs, err;
int req_ids[3], statuses[3];
   ...

num_reqs = 3;
err = @ref{ncmpi_cancel}(ncid, num_req, req_ids, statuses);

if (err != NC_NOERR)
    handle_error(err);

for (i=0; i<num_req; i++)
    if (statuses[i] != NC_NOERR)
        handle_error(statuses[i]);
@end example

@node Attributes, Run-time Environment Variables, Variables, Top
@chapter Attributes

@menu
* Attributes Introduction::     What are Attributes?
* ncmpi_put_att_@var{<type>}::  Write an Attribute
* ncmpi_inq_att Family::        Get Information about an Attribute
* ncmpi_get_att_@var{<type>}::  Read an Attribute
* ncmpi_copy_att::              Copy an Attribute
* ncmpi_rename_att::            Rename an Attribute
* ncmpi_del_att::               Delete an Attribute
@end menu

@node Attributes Introduction, ncmpi_put_att_@var{<type>}, Attributes, Attributes
@section Introduction
@cindex attributes, introduction
@cindex attributes, operations on

Attributes may be associated with each netCDF variable to specify such
properties as units, special values, maximum and minimum valid values,
scaling factors, and offsets. Attributes for a netCDF file are
defined when the file is first created, while the netCDF dataset is
in define mode. Additional attributes may be added later by reentering
define mode. A netCDF attribute has a netCDF variable to which it is
assigned, a name, a type, a length, and a sequence of one or more
values. An attribute is designated by its variable ID and name. When
an attribute name is not known, it may be designated by its variable
ID and number in order to determine its name, using the function
ncmpi_inq_attname.

The attributes associated with a variable are typically defined
immediately after the variable is created, while still in define
mode. The data type, length, and value of an attribute may be changed
even when in data mode, as long as the changed attribute requires no
more space than the attribute as originally defined.

It is also possible to have attributes that are not associated with
any variable. These are called global attributes and are identified by
using NC_GLOBAL as a variable pseudo-ID. Global attributes are usually
related to the netCDF file as a whole and may be used for purposes
such as providing a title or processing history for a netCDF file.

Operations supported on attributes are:
@itemize

@item
Create an attribute, given its variable ID, name, data type, length, and value.

@item
Get attribute's data type and length from its variable ID and name.

@item
Get attribute's value from its variable ID and name.

@item
Copy attribute from one netCDF variable to another.

@item
Get name of attribute from its number.

@item
Rename an attribute.

@item
Delete an attribute.
@end itemize

@node ncmpi_put_att_@var{<type>}, ncmpi_inq_att Family, Attributes Introduction, Attributes
@section Create an Attribute: ncmpi_put_att_@var{<type>}
@findex ncmpi_put_att
@findex ncmpi_put_att_text
@findex ncmpi_put_att_uchar
@findex ncmpi_put_att_schar
@findex ncmpi_put_att_short
@findex ncmpi_put_att_int
@findex ncmpi_put_att_float
@findex ncmpi_put_att_double
@findex ncmpi_put_att_ushort
@findex ncmpi_put_att_unit
@findex ncmpi_put_att_longlong
@findex ncmpi_put_att_ulonglong
@cindex ncmpi_put_att_text, example
@cindex ncmpi_put_att_uchar, example
@cindex ncmpi_put_att_schar, example
@cindex ncmpi_put_att_short, example
@cindex ncmpi_put_att_int, example
@cindex ncmpi_put_att_float, example
@cindex ncmpi_put_att_double, example
@cindex ncmpi_put_att_ushort, example
@cindex ncmpi_put_att_unit, example
@cindex ncmpi_put_att_longlong, example
@cindex ncmpi_put_att_ulonglong, example
@cindex attributes, creating
@cindex attributes, writing
@cindex writing attributes

The function ncmpi_put_att_@var{<type>} adds or changes a variable attribute or
global attribute of an opened netCDF file. If this attribute is new,
or if the space required to store the attribute is greater than
before, the netCDF file must be in define mode.

@heading Data types
@html
<table cellpadding="4" border="1">
<tr class="spacer" align=center>
    <td> &lt;<b>type  </b>&gt; for API names </td>
    <td> &lt;<b>C type</b>&gt; for API arguments </td>
</tr>
<tr align=center> <td>text     </td> <td>char             </td> </tr>
<tr align=center> <td>schar    </td> <td>signed char      </td> </tr>
<tr align=center> <td>short    </td> <td>short            </td> </tr>
<tr align=center> <td>int      </td> <td>int              </td> </tr>
<tr align=center> <td>float    </td> <td>float            </td> </tr>
<tr align=center> <td>double   </td> <td>double           </td> </tr>
<tr align=center> <td>uchar    </td> <td>unsigned char    </td> </tr>
<tr align=center> <td>ushort   </td> <td>unsigned short   </td> </tr>
<tr align=center> <td>uint     </td> <td>unsigned int     </td> </tr>
<tr align=center> <td>longlong </td> <td>long long        </td> </tr>
<tr align=center> <td>ulonglong</td> <td>unsigned longlong</td> </tr>
</table>
@end html

@heading Operational Mode
These APIs are collective subroutines.

These APIs must be called while the file is in define mode.

@heading Usage
@example
int ncmpi_put_att        (int              ncid,
                          int              varid,
                          const char      *name,
                          nc_type          xtype,
                          MPI_Offset       nelems,
                          const char      *buf);

int ncmpi_put_att_text   (int              ncid,
                          int              varid,
                          const char      *name,
                          MPI_Offset       nelems,
                          const char      *buf);

int ncmpi_put_att_@strong{<type>}(int              ncid,
                          int              varid,
                          const char      *name,
                          nc_type          xtype,
                          MPI_Offset       nelems,
                          const @strong{<C type>} *buf);
@end example

@table @code
@item ncid
NetCDF ID, from a previous call to ncmpi_open or ncmpi_create.

@item varid
Variable ID of the variable to which the attribute will be assigned or
NC_GLOBAL for a global attribute.

@item name
Attribute name. Must be a legal netCDF identifier.
@legalidshort
Attribute name conventions are assumed by
some netCDF generic applications, e.g., units as the name for a string
attribute that gives the units for a netCDF variable. For examples of
attribute conventions see @ref{Attribute Conventions,,, netcdf,
@value{n-man}}.

@item xtype
One of the set of predefined netCDF external data types. The type of
this parameter, nc_type, is defined in the netCDF header file. The
valid netCDF external data types are NC_BYTE, NC_CHAR, NC_SHORT,
NC_INT, NC_FLOAT, and NC_DOUBLE. Although it's possible to create
attributes of all types, NC_CHAR and NC_DOUBLE attributes are adequate
for most purposes.
For CDF-5 file format, the following data types are also supported: NC_UBYTE, NC _USHORT, NC_UINT, NC_INT64, and NC_UINT64.

@item nelems
Number of values provided for the attribute.

@item buf
Pointer to one or more values. If the type of values differs from the
netCDF attribute type specified as xtype, type conversion will
occur.
@c @xref{Type Conversion,,, netcdf, The NetCDF Users Guide}.
@end table

@heading Return Error Codes
ncmpi_put_att_@var{<type>} returns the value NC_NOERR if no errors
occurred. Otherwise, the returned status indicates an error. Possible
causes of errors include:
@itemize
@item NC_EBADID: The specified netCDF ID does not refer to an opened netCDF file.
@item NC_EPERM: Attempt write operations in read-only file.
@item NC_ENOTVAR: The input or output variable ID is invalid for the specified netCDF file.
@item NC_EGLOBAL: Using NC_GLOBAL is illegal in this context.
@item NC_EINVAL: nelems < 0, or nelems > 0 when buf is NULL, or must be 1 for fill attribute.
@item NC_EBADNAME: Name contains illegal characters.
@item NC_EBADTYPE: Fill value must be of the same type.
@item NC_ESTRICTCDF2: Attempting CDF-5 operation on strict CDF or CDF-2 file (the NC data type specified in xtype is only valid in CDF-5 files).
@item NC_ECHAR: Attempt to convert numerical values to or from text data.
@item NC_ENOTINDEFINE: The specified netCDF file is in data mode when adding a new attribute or the new name of an existing attribute is longer than the old name.
NC_EMAXATTS: Maximum number of attributes exceeds the limit, NC_MAX_ATTRS.
@item NC_EMULTIDEFINE_ATTR_NAME: Attribute name is inconsistent among processes.
@item NC_EMULTIDEFINE_ATTR_LEN: Attribute length is inconsistent among processes.
@item NC_EMULTIDEFINE_ATTR_TYPE: Attribute type is inconsistent among processes.
@item NC_EMULTIDEFINE_ATTR_VAL: Attribute value is inconsistent among processes.
@item NC_EMULTIDEFINE_FNC_ARGS: Inconsistent function arguments used in collective API.
@end itemize

@heading Example

Here is an example using ncmpi_put_att_double to add a variable attribute
named valid_range for a netCDF variable named rh and a global
attribute named title to an existing netCDF file named foo.nc:

@example
#include <pnetcdf.h>
   ...
int  status;                            /* error status */
int  ncid;                              /* netCDF ID */
int  rh_id;                             /* variable ID */
static double rh_range[] = @{0.0, 100.0@};/* attribute vals */
static char title[] = "example netCDF file";
   ...
status = @ref{ncmpi_open}(MPI_COMM_WORLD, "foo.nc", NC_WRITE, MPI_INFO_NULL,  &ncid);
if (status != NC_NOERR) handle_error(status);
   ...
status = @ref{ncmpi_redef}(ncid);                /* enter define mode */
if (status != NC_NOERR) handle_error(status);
status = @ref{ncmpi_inq_varid}(ncid, "rh", &rh_id);
if (status != NC_NOERR) handle_error(status);
   ...
status = @ref{ncmpi_put_att_@var{<type>}, ncmpi_put_att_double}(ncid, rh_id, "valid_range", NC_DOUBLE, 2, rh_range);
if (status != NC_NOERR) handle_error(status);
status = @ref{ncmpi_put_att_@var{<type>}, ncmpi_put_att_text}(ncid, NC_GLOBAL, "title", strlen(title), title)
if (status != NC_NOERR) handle_error(status);
   ...
status = @ref{ncmpi_enddef}(ncid);               /* leave define mode */
if (status != NC_NOERR) handle_error(status);
@end example

@heading Full example C program
@itemize
@item
@url{https://github.com/Parallel-NetCDF/PnetCDF/tree/master/examples/C/global_attributes.c, global_attributes.c}
@item
@url{https://github.com/Parallel-NetCDF/PnetCDF/tree/master/examples/C/put_vara.c, put_vara.c}
@item
@url{https://github.com/Parallel-NetCDF/PnetCDF/tree/master/examples/C/fill_mode.c, fill_mode.c}
@item
The above programs are available in all PnetCDF releases under directory examples/C.
@end itemize

@node ncmpi_inq_att Family, ncmpi_get_att_@var{<type>}, ncmpi_put_att_@var{<type>}, Attributes
@section Get Information about an Attribute: ncmpi_inq_att Family
@findex ncmpi_inq_att Family
@findex ncmpi_inq_att
@findex ncmpi_inq_atttype
@findex ncmpi_inq_attlen
@findex ncmpi_inq_attname
@findex ncmpi_inq_attid
@cindex ncmpi_inq_att Family, example
@cindex attributes, ID
@cindex attributes, getting information about
@cindex attributes, inquiring about
@cindex attributes, finding length
@cindex length of attributes
@cindex inquiring about attributes

This family of functions returns information about a netCDF
attribute. All but one of these functions require the variable ID and
attribute name; the exception is ncmpi_inq_attname. Information about an
attribute includes its type, length, name, and number. See the
ncmpi_get_att family for getting attribute values.

The function ncmpi_inq_attname gets the name of an attribute, given its
variable ID and number. This function is useful in generic
applications that need to get the names of all the attributes
associated with a variable, since attributes are accessed by name
rather than number in all other attribute functions. The number of an
attribute is more volatile than the name, since it can change when
other attributes of the same variable are deleted. This is why an
attribute number is not called an attribute ID.

The function ncmpi_inq_att returns the attribute's type and length. The
other functions each return just one item of information about an
attribute.

@heading Operational Mode
These APIs are independent subroutines.

These APIs can be called while the file is in either define or data mode (collective or independent).

@heading Usage
@example
int ncmpi_inq_att     (int ncid, int varid, const char *name, nc_type *xtypep,
                       MPI_Offset *lenp);
int ncmpi_inq_atttype (int ncid, int varid, const char *name, nc_type *xtypep);
int ncmpi_inq_attlen  (int ncid, int varid, const char *name,
                       MPI_Offset *lenp);
int ncmpi_inq_attname (int ncid, int varid, int attnum, char *name);
int ncmpi_inq_attid   (int ncid, int varid, const char *name, int *idp);
@end example

@vtable @code

@item ncid
NetCDF ID, from a previous call to ncmpi_open or ncmpi_create.

@item varid
Variable ID of the attribute's variable, or NC_GLOBAL for a global
attribute.

@item name
Attribute name. For ncmpi_inq_attname, this is a pointer to the location
for the returned attribute name.

@item xtypep
Pointer to location for returned attribute type, one of the set of
predefined netCDF external data types. The type of this parameter,
nc_type, is defined in the netCDF header file. The valid netCDF
external data types are NC_BYTE, NC_CHAR, NC_SHORT, NC_INT, NC_FLOAT,
and NC_DOUBLE. If this parameter is given as '0' (a null pointer), no
type will be returned so no variable to hold the type needs to be
declared.
For CDF-5 file format, the following data types are also supported: NC_UBYTE, NC _USHORT, NC_UINT, NC_INT64, and NC_UINT64.

@item lenp
Pointer to location for returned number of values currently stored in
the attribute. For attributes of type NC_CHAR, you should not assume
that this includes a trailing zero byte; it doesn't if the attribute
was stored without a trailing zero byte, for example from a FORTRAN
program. Before using the value as a C string, make sure it is
null-terminated. If this parameter is given as '0' (a null pointer),
no length will be returned so no variable to hold this information
needs to be declared.

@item attnum
For ncmpi_inq_attname, attribute ID. The attributes for each
variable are numbered from 0 (the first attribute) to natts-1, where
natts is the number of attributes for the variable, as returned from a
call to ncmpi_inq_varnatts.

@item idp
For ncmpi_inq_attid, pointer to location for returned attribute ID
that specifies which attribute this is for this variable (or which
global attribute). If you already know the attribute name, knowing its
ID is not very useful, because accessing information about an
attribute requires its name.

@end vtable

@heading Return Error Codes
APIs in this group return the value NC_NOERR if no errors
occurred. Otherwise, the returned status indicates an error. Possible
causes of errors include:
@itemize
@item NC_EBADID: The specified netCDF ID does not refer to an opened netCDF file.
@item NC_ENOTVAR: The input or output variable ID is invalid for the specified netCDF file.
@item NC_ENOTATT: The specified attribute does not exist in ncid.
For ncmpi_inq_attname, the specified attribute number is negative or more
than the number of attributes defined for the specified variable.
@end itemize

@heading Example

Here is an example using ncmpi_inq_att to find out the type and length of
a variable attribute named valid_range for a netCDF variable named rh
and a global attribute named title in an existing netCDF file named
foo.nc:

@example
#include <pnetcdf.h>
   ...
int  status;               /* error status */
int  ncid;                 /* netCDF ID */
int  rh_id;                /* variable ID */
nc_type vr_type, t_type;   /* attribute types */
MPI_Offset vr_len, t_len;  /* attribute lengths */

   ...
status = @ref{ncmpi_open}(MPI_COMM_WORLD, "foo.nc", NC_NOWRITE, MPI_INFO_NULL, &ncid);
if (status != NC_NOERR) handle_error(status);
   ...
status = @ref{ncmpi_inq_varid}(ncid, "rh", &rh_id);
if (status != NC_NOERR) handle_error(status);
   ...
status = @ref{ncmpi_inq_att Family, ncmpi_inq_att}(ncid, rh_id, "valid_range", &vr_type, &vr_len);
if (status != NC_NOERR) handle_error(status);
status = @ref{ncmpi_inq_att Family, ncmpi_inq_att}(ncid, NC_GLOBAL, "title", &t_type, &t_len);
if (status != NC_NOERR) handle_error(status);
@end example

@heading Full example C program
@itemize
@item
@url{https://github.com/Parallel-NetCDF/PnetCDF/tree/master/examples/C/global_attributes.c, global_attributes.c}
@item
@url{https://github.com/Parallel-NetCDF/PnetCDF/tree/master/examples/C/put_vara.c, put_vara.c}
@item
The above programs are available in all PnetCDF releases under directory examples/C.
@end itemize

@node ncmpi_get_att_@var{<type>}, ncmpi_copy_att, ncmpi_inq_att Family, Attributes
@section Get Attribute's Values:ncmpi_get_att_@var{<type>}
@findex ncmpi_get_att
@findex ncmpi_get_att_text
@findex ncmpi_get_att_uchar
@findex ncmpi_get_att_schar
@findex ncmpi_get_att_short
@findex ncmpi_get_att_int
@findex ncmpi_get_att_float
@findex ncmpi_get_att_double
@findex ncmpi_get_att_ushort
@findex ncmpi_get_att_unit
@findex ncmpi_get_att_longlong
@findex ncmpi_get_att_ulonglong
@cindex ncmpi_get_att_text, example
@cindex ncmpi_get_att_uchar, example
@cindex ncmpi_get_att_schar, example
@cindex ncmpi_get_att_short, example
@cindex ncmpi_get_att_int, example
@cindex ncmpi_get_att_float, example
@cindex ncmpi_get_att_double, example
@cindex ncmpi_get_att_ushort, example
@cindex ncmpi_get_att_unit, example
@cindex ncmpi_get_att_longlong, example
@cindex ncmpi_get_att_ulonglong, example
@cindex attributes, reading
@cindex reading attributes

Members of the ncmpi_get_att_@var{<type>} family of functions get the value(s)
of a netCDF attribute, given its variable ID and name.

@heading Data types
@html
<table cellpadding="4" border="1">
<tr class="spacer" align=center>
    <td> &lt;<b>type  </b>&gt; for API names </td>
    <td> &lt;<b>C type</b>&gt; for API arguments </td>
</tr>
<tr align=center> <td>text     </td> <td>char             </td> </tr>
<tr align=center> <td>schar    </td> <td>signed char      </td> </tr>
<tr align=center> <td>short    </td> <td>short            </td> </tr>
<tr align=center> <td>int      </td> <td>int              </td> </tr>
<tr align=center> <td>float    </td> <td>float            </td> </tr>
<tr align=center> <td>double   </td> <td>double           </td> </tr>
<tr align=center> <td>uchar    </td> <td>unsigned char    </td> </tr>
<tr align=center> <td>ushort   </td> <td>unsigned short   </td> </tr>
<tr align=center> <td>uint     </td> <td>unsigned int     </td> </tr>
<tr align=center> <td>longlong </td> <td>long long        </td> </tr>
<tr align=center> <td>ulonglong</td> <td>unsigned longlong</td> </tr>
</table>
@end html

@heading Operational Mode
These APIs are independent subroutines.

These APIs can be called while the file is in either define or data mode (collective or independent).

@heading Usage
@example
int ncmpi_get_att        (int         ncid,
                          int         varid,
                          const char *name,
                          void       *buf);

int ncmpi_get_att_@strong{<type>}(int         ncid,
                          int         varid,
                          const char *name,
                          @strong{<C type>}  *buf);
@end example

@table @code

@item ncid
NetCDF ID, from a previous call to ncmpi_open or ncmpi_create.

@item varid
Variable ID of the attribute's variable, or NC_GLOBAL for a global attribute.

@item name
Attribute name.

@item buf
Pointer to location for returned attribute value(s). All elements of
the vector of attribute values are returned, so you must allocate
enough space to hold them. For attributes of type NC_CHAR, you should
not assume that the returned values include a trailing zero byte; they
won't if the attribute was stored without a trailing zero byte, for
example from a FORTRAN program. Before using the value as a C string,
make sure it is null-terminated. If you don't know how much space to
reserve, call ncmpi_inq_attlen first to find out the length of the
attribute.

@end table

@heading Return Error Codes
ncmpi_get_att_@var{<type>} returns the value NC_NOERR if no errors
occurred. Otherwise, the returned status indicates an error. Possible
causes of errors include:
@itemize
@item NC_EBADID: The specified netCDF ID does not refer to an opened netCDF file.
@item NC_ENOTVAR: The input or output variable ID is invalid for the specified netCDF file.
@item NC_EBADNAME: Name contains illegal characters.
@item NC_EMAXNAME: NC_MAX_NAME exceeded.
@item NC_ENOMEM: Out of memory.
@item NC_ENOTATT: The specified attribute does not exist in ncid.
@item NC_ECHAR: Attempt to convert numerical values to or from text data.
@item NC_EINVAL: buf is NULL.
@item NC_ERANGE: One or more elements of the external attribute are out of the range of values representable by the internal data type of read buffer, buf.
@end itemize

@heading Example

Here is an example using ncmpi_get_att_double to determine the values of
a variable attribute named valid_range for a netCDF variable named rh
and a global attribute named title in an existing netCDF file named
foo.nc. In this example, it is assumed that we don't know how many
values will be returned, but that we do know the types of the
attributes. Hence, to allocate enough space to store them, we must
first inquire about the length of the attributes.

@example
#include <pnetcdf.h>
   ...
int  status;               /* error status */
int  ncid;                 /* netCDF ID */
int  rh_id;                /* variable ID */
MPI_Offset  vr_len, t_len; /* attribute lengths */
double *vr_val;            /* pointer to attribute values */
char *title;               /* pointer to attribute values */
extern char *malloc();     /* memory allocator */

   ...
status = @ref{ncmpi_open}(MPI_COMM_WORLD, "foo.nc", NC_NOWRITE, MPI_INFO_NULL, &ncid);
if (status != NC_NOERR) handle_error(status);
   ...
status = @ref{ncmpi_inq_varid}(ncid, "rh", &rh_id);
if (status != NC_NOERR) handle_error(status);
   ...
/* find out how much space is needed for attribute values */
status = @ref{ncmpi_inq_att Family, ncmpi_inq_attlen}(ncid, rh_id, "valid_range", &vr_len);
if (status != NC_NOERR) handle_error(status);
status = @ref{ncmpi_inq_att Family, ncmpi_inq_attlen}(ncid, NC_GLOBAL, "title", &t_len);
if (status != NC_NOERR) handle_error(status);

/* allocate required space before retrieving values */
vr_val = (double *) malloc(vr_len * sizeof(double));
title = (char *) malloc(t_len + 1);  /* + 1 for trailing null */

/* get attribute values */
status = @ref{ncmpi_get_att_@var{<type>}, ncmpi_get_att_double}(ncid, rh_id, "valid_range", vr_val);
if (status != NC_NOERR) handle_error(status);
status = @ref{ncmpi_get_att_@var{<type>}, ncmpi_get_att_text}(ncid, NC_GLOBAL, "title", title);
if (status != NC_NOERR) handle_error(status);
title[t_len] = '\0';       /* null terminate */
   ...
@end example

@heading Full example C program
@itemize
@item
@url{https://github.com/Parallel-NetCDF/PnetCDF/tree/master/examples/C/global_attributes.c, global_attributes.c}
@item
@url{https://github.com/Parallel-NetCDF/PnetCDF/tree/master/examples/C/put_vara.c, put_vara.c}
@item
The above programs are available in all PnetCDF releases under directory examples/C.
@end itemize

@node ncmpi_copy_att, ncmpi_rename_att, ncmpi_get_att_@var{<type>}, Attributes
@section Copy Attribute from One NetCDF to Another: ncmpi_copy_att
@findex ncmpi_copy_att
@cindex ncmpi_copy_att, example
@cindex attributes, copying
@cindex copying attributes

The function ncmpi_copy_att copies an attribute from one opened netCDF
file to another. It can also be used to copy an attribute from one
variable to another within the same netCDF.

@heading Operational Mode
This API is a collective subroutine for processes that opened ncid_out.

This API can be called under the following condition.
@itemize
@item If the attribute does not exist in ncid_out, then this API must be called when ncid_out is in define mode.
@item If the attribute does exist in ncid_out and the attribute in ncid_in is smaller than the one in ncid_out, then this API can be called when ncid_out is in either define or data mode.
@item If the attribute does exist in ncid_out and the attribute in ncid_in is larger than the one in ncid_out, then this API must be called when ncid_out is in define mode.
@end itemize

@heading Usage
@example
int ncmpi_copy_att (int         ncid_in,
                    int         varid_in,
                    const char *name,
                    int         ncid_out,
                    int         varid_out);
@end example

@table @code
@item ncid_in
The netCDF ID of an input netCDF file from which the attribute
will be copied, from a previous call to ncmpi_open or ncmpi_create.

@item varid_in
ID of the variable in the input netCDF file from which the
attribute will be copied, or NC_GLOBAL for a global attribute.

@item name
Name of the attribute in the input netCDF file to be copied.

@item ncid_out
The netCDF ID of the output netCDF file to which the attribute
will be copied, from a previous call to ncmpi_open or ncmpi_create. It is
permissible for the input and output netCDF IDs to be the same. The
output netCDF file should be in define mode if the attribute to be
copied does not already exist for the target variable, or if it would
cause an existing target attribute to grow.

@item varid_out
ID of the variable in the output netCDF file to which the
attribute will be copied, or NC_GLOBAL to copy to a global attribute.
@end table

@heading Return Error Codes
ncmpi_copy_att returns the value NC_NOERR if no errors
occurred. Otherwise, the returned status indicates an error. Possible
causes of errors include:
@itemize
@item NC_EBADID: The input or output netCDF ID does not refer to an opened netCDF file.
@item NC_EPERM: Write permission to ncid_out is denied.
@item NC_EMAXATTS: Maximum number of attributes exceeds the limit, NC_MAX_ATTRS.
@item NC_ENOTVAR: The input or output variable ID is invalid for the specified netCDF file.
@item NC_ENOTATT: The specified attribute does not exist in ncid_in.
@item NC_ENOTINDEFINE: The output netCDF is not in define mode and the attribute is new for the output file is larger than the existing attribute.
@end itemize

@heading Example

Here is an example using ncmpi_copy_att to copy the variable attribute
units from the variable rh in an existing netCDF file named foo.nc
to the variable avgrh in another existing netCDF file named bar.nc,
assuming that the variable avgrh already exists, but does not yet have
a units attribute:

@example
#include <pnetcdf.h>
   ...
int  status;               /* error status */
int  ncid1, ncid2;         /* netCDF IDs */
int  rh_id, avgrh_id;      /* variable IDs */
   ...
status = @ref{ncmpi_open}(MPI_COMM_WORLD, "foo.nc", NC_NOWRITE, MPI_INFO_NULL, &ncid1);
if (status != NC_NOERR) handle_error(status);
status = @ref{ncmpi_open}(MPI_COMM_WORLD, "bar.nc", NC_WRITE, MPI_INFO_NULL, &ncid2);
if (status != NC_NOERR) handle_error(status);
   ...
status = @ref{ncmpi_inq_varid}(ncid1, "rh", &rh_id);
if (status != NC_NOERR) handle_error(status);
status = @ref{ncmpi_inq_varid}(ncid2, "avgrh", &avgrh_id);
if (status != NC_NOERR) handle_error(status);
   ...
status = @ref{ncmpi_redef}(ncid2);  /* enter define mode */
if (status != NC_NOERR) handle_error(status);
/* copy variable attribute from "rh" to "avgrh" */
status = @ref{ncmpi_copy_att}(ncid1, rh_id, "units", ncid2, avgrh_id);
if (status != NC_NOERR) handle_error(status);
   ...
status = @ref{ncmpi_enddef}(ncid2); /* leave define mode */
if (status != NC_NOERR) handle_error(status);
@end example

@node ncmpi_rename_att, ncmpi_del_att, ncmpi_copy_att, Attributes
@section Rename an Attribute: ncmpi_rename_att
@findex ncmpi_rename_att
@cindex ncmpi_rename_att, example
@cindex attributes, renaming
@cindex renaming attributes

The function ncmpi_rename_att changes the name of an attribute.
It is illegal to rename an attribute to the same name
as another attribute of the same variable.

@heading Operational Mode
This API is a collective subroutine.

If the new name is longer than the original name, the netCDF file must be
in define mode.
Otherwise, the netCDF file can be in either define or data mode.


@heading Usage
@example
int ncmpi_rename_att(int         ncid,
                     int         varid,
                     const char *name,
                     const char *newname);
@end example

@table @code
@item ncid
NetCDF ID, from a previous call to ncmpi_open or ncmpi_create

@item varid
ID of the attribute's variable, or NC_GLOBAL for a global attribute

@item name
The current attribute name.

@item newname
The new name to be assigned to the specified attribute. If the new
name is longer than the current name, the netCDF file must be in
define mode.
@end table

@heading Return Error Codes
ncmpi_rename_att returns the value NC_NOERR if no errors
occurred. Otherwise, the returned status indicates an error. Possible
causes of errors include:
@itemize
@item NC_EBADID: The specified netCDF ID does not refer to an opened netCDF file.
@item NC_EPERM: Attempt write operations in read-only file.
@item NC_ENOTVAR: The input or output variable ID is invalid for the specified netCDF file.
@item NC_EBADNAME: Name contains illegal characters.
@item NC_ENOTATT: The specified attribute does not exist.
@item NC_ENAMEINUSE: The new attribute name is already in use for another attribute of the specified variable.
@item NC_ENOTINDEFINE: The specified netCDF file is in data mode and the new name is longer than the old name.
@item NC_EMULTIDEFINE_ATTR_NAME: Attribute name is inconsistent among processes.
@item NC_EMULTIDEFINE_FNC_ARGS: Inconsistent function arguments used in collective API.
@end itemize

@heading Example

Here is an example using ncmpi_rename_att to rename the variable
attribute units to Units for a variable rh in an existing netCDF
file named foo.nc:

@example
#include <pnetcdf.h>
   ...
int  status;      /* error status */
int  ncid;        /* netCDF ID */
int  rh_id;       /* variable id */
   ...
status = @ref{ncmpi_open}(MPI_COMM_WORLD, "foo.nc", NC_NOWRITE, MPI_INFO_NULL, &ncid);
if (status != NC_NOERR) handle_error(status);
   ...
status = @ref{ncmpi_inq_varid}(ncid, "rh", &rh_id);
if (status != NC_NOERR) handle_error(status);
   ...
/* rename attribute */
status = @ref{ncmpi_rename_att}(ncid, rh_id, "units", "Units");
if (status != NC_NOERR) handle_error(status);
@end example

@node ncmpi_del_att,  , ncmpi_rename_att, Attributes
@section Delete an Attribute: ncmpi_del_att
@findex ncmpi_del_att
@cindex ncmpi_del_att, example
@cindex attributes, deleting
@cindex deleting attributes

The function ncmpi_del_att deletes a netCDF attribute from an opened netCDF
file.

Note that once an attribute is deleted, the attribute IDs of other attributes
obtained prior to the deletion may no longer be valid. Users should call
@ref{ncmpi_inq_att Family, ncmpi_inq_attid()} to obtain the up-to-date
attribute IDs.

@heading Operational Mode
This API is a collective subroutine.

These APIs must be called while the file is in define mode.

@heading Usage
@example
int ncmpi_del_att(int         ncid,
                  int         varid,
                  const char *name);
@end example

@table @code
@item ncid
NetCDF ID, from a previous call to ncmpi_open or ncmpi_create.

@item varid
ID of the attribute's variable, or NC_GLOBAL for a global attribute.

@item name
The name of the attribute to be deleted.
@end table

@heading Return Error Codes
ncmpi_del_att returns the value NC_NOERR if no errors
occurred. Otherwise, the returned status indicates an error. Possible
causes of errors include:
@itemize
@item NC_EBADID: The specified netCDF ID does not refer to an opened netCDF file.
@item NC_EPERM: Attempt write operations in read-only file.
@item NC_ENOTINDEFINE: Operation not allowed in data mode.
@item NC_ENOTVAR: The variable ID is invalid for the specified netCDF file.
@item NC_EBADNAME: Name contains illegal characters.
@item NC_EMAXNAME: NC_MAX_NAME exceeded.
@item NC_ENOMEM: Out of memory.
@item NC_ENOTATT: The specified attribute does not exist.
@end itemize

@heading Example

Here is an example using ncmpi_del_att to delete the variable attribute
Units for a variable rh in an existing netCDF file named foo.nc:

@example
#include <pnetcdf.h>
   ...
int  status;      /* error status */
int  ncid;        /* netCDF ID */
int  rh_id;       /* variable ID */
   ...
status = @ref{ncmpi_open}(MPI_COMM_WORLD, "foo.nc", NC_WRITE, MPI_INFO_NULL, &ncid);
if (status != NC_NOERR) handle_error(status);
   ...
status = @ref{ncmpi_inq_varid}(ncid, "rh", &rh_id);
if (status != NC_NOERR) handle_error(status);
   ...
/* delete attribute */
status = @ref{ncmpi_redef}(ncid);        /* enter define mode */
if (status != NC_NOERR) handle_error(status);
status = @ref{ncmpi_del_att}(ncid, rh_id, "Units");
if (status != NC_NOERR) handle_error(status);
status = @ref{ncmpi_enddef}(ncid);       /* leave define mode */
if (status != NC_NOERR) handle_error(status);
@end example

@node Run-time Environment Variables, Utility programs, Attributes, Top
@chapter Run-time Environment Variables
@menu
* PNETCDF_SAFE_MODE::     Enable/disable checking for data consistency
* PNETCDF_VERBOSE_DEBUG_MODE::     Enable/disable printing verbose debugging messages
* PNETCDF_HINTS::         I/O hints for performance improvement
@end menu

@node PNETCDF_SAFE_MODE, PNETCDF_VERBOSE_DEBUG_MODE, , Run-time Environment Variables
@cindex PNETCDF_SAFE_MODE
This environment variable enables/disables the internal checking for
attribute/argument consistency across all processes.

Set it to 1 to enable the checking. Default is 0, i.e. disabled.

@node PNETCDF_VERBOSE_DEBUG_MODE, PNETCDF_HINTS, PNETCDF_SAFE_MODE, Run-time Environment Variables
@cindex PNETCDF_VERBOSE_DEBUG_MODE

Available in 1.7.0 and later.

PNETCDF_VERBOSE_DEBUG_MODE environment variable can be used to print the
location in the source code where the error code is originated, no matter the
error is intended or not. This run-time environment variable only takes effect
when PnetCDF is configure with debug mode, i.e.  @t{--enable-debug} is used at
the configure command line.  Users are warned that enabling this mode may
result in a lot of debugging messages printed in stderr.

Set this variable to 1 to enable. Set it to 0 or keep it unset disables this
mode. Default is 0, i.e. disabled.

@node PNETCDF_HINTS, , PNETCDF_VERBOSE_DEBUG_MODE, Run-time Environment Variables
@cindex PNETCDF_HINTS
@vindex nc_header_align_size
@vindex nc_var_align_size
@vindex nc_record_align_size
@vindex nc_header_read_chunk_size
@vindex pnetcdf_subfiling
@vindex nc_in_place_swap

Starting from release of 1.4.0 version, this environment variable allows users
to pass I/O hints to PnetCDF library.  Hints can be a combination of both
PnetCDF and MPI-IO hints.

The value is a string of hints separated by ";" and each hint is in the form of "hint=value". E.g. under csh/tcsh environment, use command:
@example
setenv PNETCDF_HINTS "romio_ds_write=disable;nc_header_align_size=1048576"
@end example
Under bash environment, use command:
@example
export PNETCDF_HINTS="romio_ds_write=disable;nc_header_align_size=1048576"
@end example

Note the environment variables precede the (hint) values set in the application
program, i.e. through MPI info object passed to @xref{ncmpi_create} and
@xref{ncmpi_open}. Hints nc_header_align_size, nc_var_align_size, and
nc_record_align_size precede the arguments v_align and r_align passed to
@xref{ncmpi__enddef}.

@heading Available PnetCDF hints
@table @code
@item nc_header_align_size
(Before version 1.4.0)
It aligns the size of header extent of a newly created file.
This hint was first introduced in version 1.1.0, but can only be passed to
PnetCDF through an MPI info object, rather than setting the environment
variable PNETCDF_HINTS.

(Between version 1.4.0 and 1.13.0)
It aligns the size of header extent of a newly created file. The default is 512
bytes. If the file striping size is known and the total size of all fixed-size
variables is larger than 4 times the file striping size, then this hint will be
set to the file striping size, i.e. the size of header extent will be the
smallest multiple of striping size that is larger than the file header size.
Set the value to 1 to disable the alignment.

(Version 1.13.0 and later)
Starting from 1.13.0, the file striping size is no longer used to set the
file header extent. This is because it can result in a large header extent
than wanted, especially when the file striping size is large, e.g. 16 MB, and
the header size is much smaller, e.g. less than 1 MB.
@item nc_var_align_size
(Before version 1.4.0)
It aligns the size of header extent of a newly created file.
This hint was first introduced in version 1.1.0, but can only be passed to
PnetCDF through an MPI info object, rather than setting the environment
variable PNETCDF_HINTS.

(Between version 1.4.0 and 1.13.0)
This hint aligns the starting file offsets of individual fixed-size variables.
In PnetCDF version 1.10.0 and prior, the default is 512 bytes if file striping
size is not obtainable by PnetCDF. If the file striping size is known and the
total size of all fixed-size variables is larger than 4 times the file striping
size, then the starting file offsets of all individual fixed-size variables are
aligned to the file striping size, i.e. the smallest multiple of stripe size
that is larger than the end offset of the variable defined immediately prior to
this variable. Set the value to 1 to disable the alignment. Starting from
version 1.11.0, the default has changed to 1, i.e. no alignment. If
applications use PnetCDF nonblocking APIs to aggregate write requests to
multiple variables, then the best practice is to disable the alignment.
Disabling this alignment will prevent creating gaps in file space between two
consecutive variables and thus the writes to file system can be contiguous.

(Version 1.13.0 and later)
Starting from version 1.13.0, this hint will only align the starting offset of
the entire data section, rather than individual fixed-size variables.
@item nc_header_read_chunk_size
(version 1.4.0 and later)
PnetCDF reads the file headers in chunks. This hint indicates the chunk size
(in bytes). The default is 256 KB.
@item nc_record_align_size
(version 1.5.0 and later)
This hint aligns the starting file offset of the record variable section. Note
this is for the entire section, not individual records.
@item pnetcdf_subfiling
(version 1.6.0 and later)
This hint enables or disables the subfiling feature.  Its string value is
either "enable" or "disable".
@item nc_in_place_swap
(version 1.10.0 and later)
This hint enables or disables in-place byte swap on Little Endian
architectures.  When the hint is set to "enable", PnetCDF performs byte swap on
user I/O buffers whenever possible. This option results in the least amount of
internal memory usage. However, if an immutable user buffer is used,
segmentation fault may occur when byte swap is performed on user buffer in
place.  When the hint is set to "disabled", PnetCDF allocates an internal
buffer for byte swap without altering the contents of user buffer, when byte
swap is required.  This option will increase internal memory footprint.  When
the hint is set to "auto", PnetCDF allocates an internal buffer for byte swap
only when the I/O request size is less than 4 KiB. For larger requests, user
buffers are used for in-place byte swap.  Note this hint takes effect only on
Little Endian machines, as no byte swap is necessary on Big Endian machines.
@item nc_ibuf_size
(version 1.11.0 and later)
It sets the size of a temporal buffer to be allocated by PnetCDF internally to
pack noncontiguous user write buffers supplied to the nonblocking requests into
a contiguous space. Similarly for read case to unpack the temporal buffer to
user read buffers if they are noncontiguous. This affects both blocking and
nonblocking APIs. On some systems, using noncontiguous user buffers in MPI
collective read/write functions performs significantly worse than using
contiguous buffers. Note if the size of aggregated user buffers is larger than
@t{nc_ibuf_size}, packing/unpacking will be disabled to save memory footprint.
The default value is 16 MiB.
@item nc_num_aggrs_per_node
(version 1.14.0 and later)
The intra-node aggregation is a new feature introduced in version 1.14.0, which
is designed for the I/O patterns that contain many noncontiguous requests
interleaved among processes, and spreading across a wide range of file space.
It is particularly useful when the number of MPI processes allocated to a
compute node is large. Setting this hint to a positive integral value to
indicate the desired number of processes per compute node to be selected as the
intra-node I/O aggregators. Each process is assigned a unique aggregator. The
non-aggregators send their requests to the assigned aggregators, and then the
aggregators make MPI-IO requests to the file. Such strategy can effectively
reduce communication congestion due to many pending asynchronous messages
produced in the collective write inside of MPI-IO.  Setting this hint to 0
disables the aggregation, the default mode.

@end table

@node Utility programs, Summary of C Interface, Run-time Environment Variables, Top
@chapter Utility programs
@menu
* ncmpidiff::       Compare two netCDF files and report differences
* cdfdiff::         A serial version of ncmpidiff (1.12.0 and later)
* pnetcdf_version:: Report version information of PnetCDF library (1.5.0 and later)
* ncoffsets::       Report starting/ending file offsets of netCDF variables (1.7.0 and later)
* ncvalidator::  Validates a classic netCDF file against CDF file formats (1.9.0 and later)
* pnetcdf-config::  Report configure options used to build PnetCDF library (1.8.0 and later)
@end menu

@node ncmpidiff, pnetcdf_version, , Utility programs
@cindex ncmpidiff
@cindex cdfdiff
@b{ncmpidiff} is a parallel utility program that compares the contents of the
two files and reports the difference to the standard output. When comparing
file headers, the differences of all metadata are reported, including dimensions,
attributes, variable types and dimensionality. When comparing variables, only
the indices of first array element found differently is reported when option
@b{-t} is not used.  When option @b{-t} is used, it reports the element with
the largest difference that fails to meet the tolerance requirements.

When comparing two files entirely, @b{ncmpidiff} skips the gaps between header
and variables and gaps between any two consecutive variables. Note this
behavior differs from the Unix command @b{diff} which compares two files byte
by byte.

The gaps occur when the alignment feature is enabled when creating a new file,
which allows to allocate a larger space for the file header and aligns the
starting file offsets of fixed-size variables to a user specified file offset
boundary(see @ref{ncmpi__enddef} and @ref{PNETCDF_HINTS}). Oftentimes, the
contents of gaps are arbitrary. Thus, it is possible that two netCDF files of
same or different sizes are reported identical by @b{ncmpidiff} but not by
@b{diff}.

@anchor{cdfdiff}@b{cdfdiff} is a serial version of @b{ncmpidiff}. It can be
compiled by gcc without MPI compiler. Thus, it can be useful to run on login
nodes in a cross-compile environment.

@heading Synopsis
@example
mpiexec -n NP ncmpidiff [-b] [-q] [-h] [-v var1,...] [-t diff,ratio] file1 file2

cdfdiff [-b] [-q] [-h] [-v var1,...]  file1 file2
@end example

@heading Command-line Options
@table @code
@item -b
Verbose mode - print results (same or different) for all  components (file,
header, or variables) in comparison
@item -q
Quiet mode - print nothing when two components in comparison are the same
@item -h
Compare file header only
@item -v var1,...,varn
Compare only the given list of variables, with names separated by comma and no
space in between (file header comparison is skipped, unless -h is used.)
@item -t diff,ratio
Compare variables elementwisely with tolerance (diff and ratio separated by
comma without space). @strong{diff} is the absolute value of element-wise
difference of any two variables. @strong{ratio} is the relative element-wise
ratio, for instance, MAX(x,y) / MIN(x,y) - 1, where x is an array element from
a variable in the first file and y is the corresponding array element of the
same variable in the second file. Note when this option is used, the comparison
will compare the entire variables and reports the array indices of element with
the largest difference that fails to meet the both tolerance requirements.
(This option was first added in version 1.12.0.)
@end table

@heading Example output on screen
Below shows an example when comparing two files in verbose mode.
@example
% mpiexec -n 1 ncmpidiff -b tst_rec.nc1 tst_recx.nc2
DIFF: file format (CDF-1) != (CDF-2)
SAME: number of dimensions (3)
SAME: number of variables (2)
SAME: number of global attributes (1)
Global attribute "history":
	SAME: data type (NC_CHAR)
	SAME: length (24)
	SAME: attribute contents
Dimension:
	SAME: dimension "time" length (0)
	SAME: dimension "Y" length (4)
	SAME: dimension "X" length (12)
Variables:
Variable "rec_var":
	SAME: data type (NC_FLOAT)
	SAME: number of dimensions (2)
	dimension 0:
		SAME: name (time)
		SAME: length (0)
	dimension 1:
		SAME: name (X)
		SAME: length (12)
	SAME: number of attributes (0)
Variable "fix_var":
	SAME: data type (NC_FLOAT)
	SAME: number of dimensions (2)
	dimension 0:
		SAME: name (Y)
		SAME: length (4)
	dimension 1:
		SAME: name (X)
		SAME: length (12)
	SAME: number of attributes (0)
number of variables to be compared = 2
DIFF: variable "rec_var" of type "NC_FLOAT" at element [1, 1]
	SAME: variable "rec_var" contents
DIFF: variable "fix_var" of type "NC_FLOAT" at element [1, 2]
Number of differences in header: 1
Number of differences in variables: 2
@end example

@node pnetcdf_version, ncoffsets, ncmpidiff, Utility programs
@cindex pnetcdf_version
@b{pnetcdf_version} prints the version information of PnetCDF library and the
configure command line used to build the library.

@heading Synopsis
@example
pnetcdf_version [-v] [-d] [-c] [-b] [-h]
@end example

@heading Command-line Options
@table @code
@item -v
Version number of this PnetCDF release.
@item -d
Release date.
@item -c
Configure command-line arguments used to build this PnetCDF.
@item -b
MPI compilers used to build this PnetCDF library
@item -h
Print the available command-line options of pnetcdf_version.
@end table

@heading Example
@example
% pnetcdf_version

  PnetCDF Version:         1.4.2.pre1
  PnetCDF Release date:    15 Apr 2014
  PnetCDF configure:  --with-mpi=/usr/local/bin
  MPICC:  /usr/local/bin/mpicc -g -O2
  MPICXX: /usr/local/bin/mpicxx -g -O2
  MPIF77: /usr/local/bin/mpif77 -g -O2
  MPIF90: /usr/local/bin/mpif90 -g -O2
@end example

@node ncoffsets, ncvalidator, pnetcdf-config, Utility programs
@cindex ncoffsets
@b{ncoffsets} prints the file offsets of variables defined in a given
netCDF file. The print order is fixed-size variables first followed by record
variables. The ending offsets reported are exclusive offsets, i.e. 1 byte more
than the last byte occupied by the variable. In other words, the ending offset
is equal to the sum of starting offset and the variable size. For record
variables, only the offsets of first record are printed. Adding option -r
prints the offsets of all records.

If no argument is given, command usage information is printed.

Note this utility checks only the file header and does not report any file
offset violation against the CDF file format specifications. For validating
a given netCDF file, use utility @ref{ncvalidator}.

@heading Synopsis
@example
ncoffsets [-h] | [-x] | [-sgr] [-v var1[,...]]  file
@end example

@heading Command-line Options
@table @code
@item -v var1[,...]
The output include starting file offsets for the specified variables.
One or more variables must be specified by names in a comma-delimited
list following this option. The list must be a single
argument to the command, hence cannot contain blanks or other
white space characters. The named variables must be valid
netCDF variables defined in the input file. The default, without this
option is to print the starting offsets for all variables.
@item -s
Print the variable size in bytes. For record variables, only the size of one
record is printed.
@item -g
Print the gap in bytes of a variable's starting offset from its immediately
previous variable. For the first defined
variable, print the gap from the end of file header. For record variables,
there is no gap between records.
@item -r
Output the offset information for all records of the selected record variables.
Without this option, only the offsets of first record are printed.
@item -x
Check all fixed-size variable for file space gaps in between any two
immediately adjacent variables. It prints "1" on stdout if gaps are found,
"0" for otherwise. This option disables all other options.
@item -h
Print the available command-line options
@end table

@heading Example
Print the file offset information for all variables in a netCDF file.
@example
% ncoffsets -sg testfile.nc
netcdf test_double.nc @{
//file format: CDF-1

file header:
        size   = 340 bytes
        extent = 340 bytes

dimensions:
        x = 100
        y = 100
        z = 100
        time = UNLIMITED // (100 currently)

fixed-size variables:
        double square(x, y):
               start file offset =         340
               end   file offset =       80340
               size in bytes     =       80000
               gap from prev var =           0
        double cube(x, y, z):
               start file offset =       80340
               end   file offset =     8080340
               size in bytes     =     8000000
               gap from prev var =           0

record variables:
        double time(time):
               start file offset =     8080340    (record 0)
               end   file offset =     8081140    (record 0)
               size in bytes     =           8    (of one record)
               gap from prev var =           0
        double xytime(time, x, y):
               start file offset =     8080348    (record 0)
               end   file offset =    16080348    (record 0)
               size in bytes     =       80000    (of one record)
               gap from prev var =           0
@}
@end example
Check if there are gaps in between two adjacent fixed-size variables.
@example
% ncoffsets -x testfile.nc
0
@end example

@node ncvalidator, pnetcdf_version, ncoffsets, Utility programs
@cindex ncvalidator
@b{ncvalidator} checks the header of a netCDF file for whether it conforms the
classic CDF file formats. If the input file is a valid NetCDF file, then a
message of successful validation is printed on command-line output, for
example, File "testfile.nc" is a valid NetCDF file. Otherwise, a NetCDF error
message is printed.

If no argument is given, command usage information is printed.

@heading Synopsis
@example
ncvalidator [-h] | [-t] [-x] [-q] input_file
@end example

@heading Command-line Options
@table @code
@item -t
Turn on tracing mode, printing progress of validation (version 1.10.0 and
later).
@item -x
Repair the null-byte padding in file header. The null-byte padding is required
by the NetCDF Classic Format Specifications. PnetCDF enforces this requirement,
but NetCDF has never enforced it. This option checks the header for locations
where null bytes are expected and replaces them with null bytes if non-null
bytes are found. The repaired file is then conformed with the specification and
allows both PnetCDF and NetCDF libraries to read the file without reporting
error code NC_ENOTNC or NC_ENULLPAD. Noted that this repair is done in place
and users might want to backup the input file first. Once the file is repaired,
one may run @ref{ncmpidiff} or @xref{cdfdiff} command to compare the contents of
two files.

@item -q
Quiet mode. Print nothing on the command-line output. When in quiet mode, users
should check exit status.
@item -h
Print the available command-line options
@end table

@heading Example
Print the file offset information for all variables in a netCDF file.
@example
% ncvalidator test/cdf_format/bad_dimid.nc1
Error @ [0x0000005c]:
	Variable "var0": dimid[0]=5 is larger than the number of dimensions defined in file (3)
File "test/cdf_format/bad_dimid.nc1" fails to conform with CDF file format specifications
@end example

@node pnetcdf-config, , ncvalidator, Utility programs
@cindex pnetcdf-config
@b{pnetcdf-config} prints the configure command-line options used to build the PnetCDF library.

@heading Synopsis
@example
pnetcdf-config [OPTION]
@end example

@heading Command-line Options
@example
  --help                      display this help message and exit
  --all                       display all options
  --cc                        C compiler
  --cflags                    C compiler flags
  --cppflags                  C pre-processor flags
  --has-c++                   whether C++ API is installed
  --c++                       C++ compiler
  --cxxflags                  C++ compiler flags
  --has-fortran               whether Fortran API is installed
  --f77                       Fortran 77 compiler
  --fflags                    Fortran 77 compiler flags
  --fppflags                  Fortran pre-processor flags
  --fc                        Fortran 9x compiler
  --fcflags                   Fortran 9x compiler flags
  --ldflags                   Linker options
  --libs                      Libraries used to build PnetCDF
  --netcdf4                   Whether NetCDF-4 support is enabled or disabled
  --relax-coord-bound         Whether using a relaxed coordinate boundary check
  --in-place-swap             Whether using buffer in-place Endianness byte swap
  --erange-fill               Whether using fill values for NC_ERANGE error
  --subfiling                 Whether subfiling is enabled or disabled
  --large-single-req          Whether to allow large (>2GiB) single MPI-IO requests
  --null-byte-header-padding  Whether to check null-byte padding in header
  --burst-buffering           Whether burst buffer driver is built or not
  --profiling                 Whether internal profiling is enabled or not
  --debug                     Whether PnetCDF is built with debug mode
  --prefix                    Install prefix
  --includedir                Include directory
  --libdir                    Library directory
  --version                   Library version
  --release-date              Date of PnetCDF source was released
  --config-date               Date of PnetCDF library was configured
@end example

@heading Example
@example
% pnetcdf-config --all

This parallel-netcdf 1.10.0 has been built with the following features:

  --cc                        -> /usr/local/bin/mpicc
  --cflags                    -> -O2
  --cppflags                  ->
  --ldflags                   ->
  --libs                      ->

  --has-c++                   -> yes
  --cxx                       -> /usr/local/bin/mpicxx
  --cxxflags                  -> -O2

  --has-fortran               -> yes
  --f77                       -> /usr/local/bin/mpif77
  --fflags                    -> -O2

  --fc                        -> /usr/local/bin/mpif90
  --fcflags                   -> -O2

  --netcdf4                   -> enabled
  --relax-coord-bound         -> enabled
  --in-place-swap             -> auto
  --erange-fill               -> enabled
  --subfiling                 -> enabled
  --large-single-req          -> disabled
  --null-byte-header-padding  -> disabled
  --burst-buffering           -> enabled
  --profiling                 -> enabled
  --debug                     -> disabled

  --prefix                    -> /usr/local
  --includedir                -> /usr/local/include
  --libdir                    -> /usr/local/lib
  --version                   -> parallel-netcdf 1.10.0
  --release-date              -> 2 Jul 2018
  --config-date               -> Mon Jul  9 11:01:38 CDT 2018
@end example

@node Summary of C Interface, Summary of Fortran 77 Interface, Error Codes, Top
@appendix Summary of C Interface
@cindex API, C summary
@cindex C API summary

@heading File APIs
@example
const char* ncmpi_strerror(int err);
const char* ncmpi_strerrno(int err);

int ncmpi_create             (MPI_Comm comm, const char *path, int cmode, MPI_Info info, int *ncidp);
int ncmpi_open               (MPI_Comm comm, const char *path, int omode, MPI_Info info, int *ncidp);
int ncmpi_delete             (const char *filename, MPI_Info info);
int ncmpi_enddef             (int ncid);
int ncmpi__enddef            (int ncid, MPI_Offset h_minfree, MPI_Offset v_align, MPI_Offset v_minfree, MPI_Offset r_align);
int ncmpi_redef              (int ncid);
int ncmpi_set_default_format (int format, int *old_formatp);
int ncmpi_inq_default_format (int *formatp);
int ncmpi_flush              (int ncid);
int ncmpi_sync               (int ncid);
int ncmpi_sync_numrecs       (int ncid);
int ncmpi_abort              (int ncid);
int ncmpi_begin_indep_data   (int ncid);
int ncmpi_end_indep_data     (int ncid);
int ncmpi_close              (int ncid);
int ncmpi_set_fill           (int ncid, int fillmode, int *old_modep);
@end example

@heading Dimension APIs
@example
int ncmpi_def_dim    (int ncid, const char *name, MPI_Offset len, int *idp);
int ncmpi_def_var    (int ncid, const char *name, nc_type xtype, int ndims, const int *dimidsp, int *varidp);
int ncmpi_rename_dim (int ncid, int dimid, const char *name);
int ncmpi_rename_var (int ncid, int varid, const char *name);
@end example

@heading Inquiry APIs
@example
const char* ncmpi_inq_libvers (void);

int ncmpi_inq                 (int ncid, int *ndimsp, int *nvarsp, int *ngattsp, int *unlimdimidp);
int ncmpi_inq_format          (int ncid, int *formatp);
int ncmpi_inq_file_format     (const char *filename, int *formatp);
int ncmpi_inq_version         (int ncid, int *nc_mode);
int ncmpi_inq_striping        (int ncid, int *striping_size, int *striping_count);
int ncmpi_inq_ndims           (int ncid, int *ndimsp);
int ncmpi_inq_nvars           (int ncid, int *nvarsp);
int ncmpi_inq_num_rec_vars    (int ncid, int *num_rec_varsp);
int ncmpi_inq_num_fix_vars    (int ncid, int *num_fix_varsp);
int ncmpi_inq_natts           (int ncid, int *ngattsp);
int ncmpi_inq_unlimdim        (int ncid, int *unlimdimidp);
int ncmpi_inq_dimid           (int ncid, const char *name, int *idp);
int ncmpi_inq_dim             (int ncid, int dimid, char *name, MPI_Offset *lenp);
int ncmpi_inq_dimname         (int ncid, int dimid, char *name);
int ncmpi_inq_dimlen          (int ncid, int dimid, MPI_Offset *lenp);
int ncmpi_inq_var             (int ncid, int varid, char *name, nc_type *xtypep, int *ndimsp, int *dimidsp, int *nattsp);
int ncmpi_inq_varid           (int ncid, const char *name, int *varidp);
int ncmpi_inq_varname         (int ncid, int varid, char *name);
int ncmpi_inq_vartype         (int ncid, int varid, nc_type *xtypep);
int ncmpi_inq_varndims        (int ncid, int varid, int *ndimsp);
int ncmpi_inq_vardimid        (int ncid, int varid, int *dimidsp);
int ncmpi_inq_varnatts        (int ncid, int varid, int *nattsp);
int ncmpi_inq_varoffset       (int ncid, int varid, MPI_Offset *offset);
int ncmpi_inq_put_size        (int ncid, MPI_Offset *size);
int ncmpi_inq_get_size        (int ncid, MPI_Offset *size);
int ncmpi_inq_header_size     (int ncid, MPI_Offset *size);
int ncmpi_inq_header_extent   (int ncid, MPI_Offset *extent);
int ncmpi_inq_file_info       (int ncid, MPI_Info *info_used);
int ncmpi_get_file_info       (int ncid, MPI_Info *info_used);
int ncmpi_inq_malloc_size     (MPI_Offset *size);
int ncmpi_inq_malloc_max_size (MPI_Offset *size);
int ncmpi_inq_malloc_list     (void);
int ncmpi_inq_files_opened    (int *num, int *ncids);
int ncmpi_inq_recsize         (int ncid, MPI_Offset *recsize);
int ncmpi_def_var_fill        (int ncid, int varid, int no_fill, const void *fill_value);
int ncmpi_inq_var_fill        (int ncid, int varid, int *no_fill, void *fill_value);
int ncmpi_inq_path            (int ncid, int *pathlen, char *path);
@end example

@heading Attribute APIs
@example
int ncmpi_inq_att          (int ncid, int varid, const char *name, nc_type *xtypep, MPI_Offset *lenp);
int ncmpi_inq_attid        (int ncid, int varid, const char *name, int *idp);
int ncmpi_inq_atttype      (int ncid, int varid, const char *name, nc_type *xtypep);
int ncmpi_inq_attlen       (int ncid, int varid, const char *name, MPI_Offset *lenp);
int ncmpi_inq_attname      (int ncid, int varid, int attnum, char *name);
int ncmpi_copy_att         (int ncid, int varid, const char *name, int ncid_out, int varid_out);
int ncmpi_rename_att       (int ncid, int varid, const char *name, const char *newname);
int ncmpi_del_att          (int ncid, int varid, const char *name);
int ncmpi_put_att          (int ncid, int varid, const char *name, nc_type xtype, MPI_Offset len, const void *op);
int ncmpi_put_att_text     (int ncid, int varid, const char *name, MPI_Offset len, const char *op);
int ncmpi_put_att_schar    (int ncid, int varid, const char *name, nc_type xtype, MPI_Offset len, const signed char *op);
int ncmpi_put_att_short    (int ncid, int varid, const char *name, nc_type xtype, MPI_Offset len, const short *op);
int ncmpi_put_att_int      (int ncid, int varid, const char *name, nc_type xtype, MPI_Offset len, const int *op);
int ncmpi_put_att_float    (int ncid, int varid, const char *name, nc_type xtype, MPI_Offset len, const float *op);
int ncmpi_put_att_double   (int ncid, int varid, const char *name, nc_type xtype, MPI_Offset len, const double *op);
int ncmpi_put_att_longlong (int ncid, int varid, const char *name, nc_type xtype, MPI_Offset len, const long long *op);
int ncmpi_get_att          (int ncid, int varid, const char *name, void *ip);
int ncmpi_get_att_text     (int ncid, int varid, const char *name, char *ip);
int ncmpi_get_att_schar    (int ncid, int varid, const char *name, signed char *ip);
int ncmpi_get_att_short    (int ncid, int varid, const char *name, short *ip);
int ncmpi_get_att_int      (int ncid, int varid, const char *name, int *ip);
int ncmpi_get_att_float    (int ncid, int varid, const char *name, float *ip);
int ncmpi_get_att_double   (int ncid, int varid, const char *name, double *ip);
int ncmpi_get_att_longlong (int ncid, int varid, const char *name, long long *ip);
@end example

The following attribute APIs are skipped for Fortran binding as Fortran APIs does not support the following C types: uchar, ubyte, ushort, uint, long, ulonglong, string.
@example
int ncmpi_put_att_uchar     (int ncid, int varid, const char *name, nc_type xtype, MPI_Offset len, const unsigned char *op);
int ncmpi_put_att_ubyte     (int ncid, int varid, const char *name, nc_type xtype, MPI_Offset len, const unsigned char *op);
int ncmpi_put_att_ushort    (int ncid, int varid, const char *name, nc_type xtype, MPI_Offset len, const unsigned short *op);
int ncmpi_put_att_uint      (int ncid, int varid, const char *name, nc_type xtype, MPI_Offset len, const unsigned int *op);
int ncmpi_put_att_long      (int ncid, int varid, const char *name, nc_type xtype, MPI_Offset len, const long *op);
int ncmpi_put_att_ulonglong (int ncid, int varid, const char *name, nc_type xtype, MPI_Offset len, const unsigned long long *op);
int ncmpi_get_att_uchar     (int ncid, int varid, const char *name, unsigned char *ip);
int ncmpi_get_att_ubyte     (int ncid, int varid, const char *name, unsigned char *ip);
int ncmpi_get_att_ushort    (int ncid, int varid, const char *name, unsigned short *ip);
int ncmpi_get_att_uint      (int ncid, int varid, const char *name, unsigned int *ip);
int ncmpi_get_att_long      (int ncid, int varid, const char *name, long *ip);
int ncmpi_get_att_ulonglong (int ncid, int varid, const char *name, unsigned long long *ip);
@end example

@heading Variable read/write APIs
int ncmpi_fill_var_rec       (int ncid, int varid, MPI_Offset recno);

@heading put/ger var1 APIs
@example
int ncmpi_put_var1              (int ncid, int varid, const MPI_Offset index[], const void *buf, MPI_Offset bufcount, MPI_Datatype buftype);
int ncmpi_put_var1_all          (int ncid, int varid, const MPI_Offset index[], const void *buf, MPI_Offset bufcount, MPI_Datatype buftype);
int ncmpi_put_var1_text         (int ncid, int varid, const MPI_Offset index[], const char *op);
int ncmpi_put_var1_text_all     (int ncid, int varid, const MPI_Offset index[], const char *op);
int ncmpi_put_var1_schar        (int ncid, int varid, const MPI_Offset index[], const signed char *op);
int ncmpi_put_var1_schar_all    (int ncid, int varid, const MPI_Offset index[], const signed char *op);
int ncmpi_put_var1_short        (int ncid, int varid, const MPI_Offset index[], const short *op);
int ncmpi_put_var1_short_all    (int ncid, int varid, const MPI_Offset index[], const short *op);
int ncmpi_put_var1_int          (int ncid, int varid, const MPI_Offset index[], const int *op);
int ncmpi_put_var1_int_all      (int ncid, int varid, const MPI_Offset index[], const int *op);
int ncmpi_put_var1_float        (int ncid, int varid, const MPI_Offset index[], const float *op);
int ncmpi_put_var1_float_all    (int ncid, int varid, const MPI_Offset index[], const float *op);
int ncmpi_put_var1_double       (int ncid, int varid, const MPI_Offset index[], const double *op);
int ncmpi_put_var1_double_all   (int ncid, int varid, const MPI_Offset index[], const double *op);
int ncmpi_put_var1_longlong     (int ncid, int varid, const MPI_Offset index[], const long long *op);
int ncmpi_put_var1_longlong_all (int ncid, int varid, const MPI_Offset index[], const long long *op);
int ncmpi_get_var1              (int ncid, int varid, const MPI_Offset index[], void *buf, MPI_Offset bufcount, MPI_Datatype buftype);
int ncmpi_get_var1_all          (int ncid, int varid, const MPI_Offset index[], void *buf, MPI_Offset bufcount, MPI_Datatype buftype);
int ncmpi_get_var1_text         (int ncid, int varid, const MPI_Offset index[], char *ip);
int ncmpi_get_var1_text_all     (int ncid, int varid, const MPI_Offset index[], char *ip);
int ncmpi_get_var1_schar        (int ncid, int varid, const MPI_Offset index[], signed char *ip);
int ncmpi_get_var1_schar_all    (int ncid, int varid, const MPI_Offset index[], signed char *ip);
int ncmpi_get_var1_short        (int ncid, int varid, const MPI_Offset index[], short *ip);
int ncmpi_get_var1_short_all    (int ncid, int varid, const MPI_Offset index[], short *ip);
int ncmpi_get_var1_int          (int ncid, int varid, const MPI_Offset index[], int *ip);
int ncmpi_get_var1_int_all      (int ncid, int varid, const MPI_Offset index[], int *ip);
int ncmpi_get_var1_float        (int ncid, int varid, const MPI_Offset index[], float *ip);
int ncmpi_get_var1_float_all    (int ncid, int varid, const MPI_Offset index[], float *ip);
int ncmpi_get_var1_double       (int ncid, int varid, const MPI_Offset index[], double *ip);
int ncmpi_get_var1_double_all   (int ncid, int varid, const MPI_Offset index[], double *ip);
int ncmpi_get_var1_longlong     (int ncid, int varid, const MPI_Offset index[], long long *ip);
int ncmpi_get_var1_longlong_all (int ncid, int varid, const MPI_Offset index[], long long *ip);
@end example

The following put/get var1 APIs are skipped for Fortran binding as Fortran APIs does not support the following C types: uchar, ubyte, ushort, uint, long, ulonglong, string.
@example
int ncmpi_put_var1_uchar         (int ncid, int varid, const MPI_Offset index[], const unsigned char *op);
int ncmpi_put_var1_uchar_all     (int ncid, int varid, const MPI_Offset index[], const unsigned char *op);
int ncmpi_put_var1_ushort        (int ncid, int varid, const MPI_Offset index[], const unsigned short *op);
int ncmpi_put_var1_ushort_all    (int ncid, int varid, const MPI_Offset index[], const unsigned short *op);
int ncmpi_put_var1_uint          (int ncid, int varid, const MPI_Offset index[], const unsigned int *op);
int ncmpi_put_var1_uint_all      (int ncid, int varid, const MPI_Offset index[], const unsigned int *op);
int ncmpi_put_var1_long          (int ncid, int varid, const MPI_Offset index[], const long *ip);
int ncmpi_put_var1_long_all      (int ncid, int varid, const MPI_Offset index[], const long *ip);
int ncmpi_put_var1_ulonglong     (int ncid, int varid, const MPI_Offset index[], const unsigned long long *ip);
int ncmpi_put_var1_ulonglong_all (int ncid, int varid, const MPI_Offset index[], const unsigned long long *ip);
int ncmpi_get_var1_uchar         (int ncid, int varid, const MPI_Offset index[], unsigned char *ip);
int ncmpi_get_var1_uchar_all     (int ncid, int varid, const MPI_Offset index[], unsigned char *ip);
int ncmpi_get_var1_ushort        (int ncid, int varid, const MPI_Offset index[], unsigned short *ip);
int ncmpi_get_var1_ushort_all    (int ncid, int varid, const MPI_Offset index[], unsigned short *ip);
int ncmpi_get_var1_uint          (int ncid, int varid, const MPI_Offset index[], unsigned int *ip);
int ncmpi_get_var1_uint_all      (int ncid, int varid, const MPI_Offset index[], unsigned int *ip);
int ncmpi_get_var1_long          (int ncid, int varid, const MPI_Offset index[], long *ip);
int ncmpi_get_var1_long_all      (int ncid, int varid, const MPI_Offset index[], long *ip);
int ncmpi_get_var1_ulonglong     (int ncid, int varid, const MPI_Offset index[], unsigned long long *ip);
int ncmpi_get_var1_ulonglong_all (int ncid, int varid, const MPI_Offset index[], unsigned long long *ip);
@end example

@heading put/ger var APIs
@example
int ncmpi_put_var              (int ncid, int varid, const void *buf, MPI_Offset bufcount, MPI_Datatype buftype);
int ncmpi_put_var_all          (int ncid, int varid, const void *buf, MPI_Offset bufcount, MPI_Datatype buftype);
int ncmpi_put_var_text         (int ncid, int varid, const char *op);
int ncmpi_put_var_text_all     (int ncid, int varid, const char *op);
int ncmpi_put_var_schar        (int ncid, int varid, const signed char *op);
int ncmpi_put_var_schar_all    (int ncid, int varid, const signed char *op);
int ncmpi_put_var_short        (int ncid, int varid, const short *op);
int ncmpi_put_var_short_all    (int ncid, int varid, const short *op);
int ncmpi_put_var_int          (int ncid, int varid, const int *op);
int ncmpi_put_var_int_all      (int ncid, int varid, const int *op);
int ncmpi_put_var_float        (int ncid, int varid, const float *op);
int ncmpi_put_var_float_all    (int ncid, int varid, const float *op);
int ncmpi_put_var_double       (int ncid, int varid, const double *op);
int ncmpi_put_var_double_all   (int ncid, int varid, const double *op);
int ncmpi_put_var_longlong     (int ncid, int varid, const long long *op);
int ncmpi_put_var_longlong_all (int ncid, int varid, const long long *op);
int ncmpi_get_var              (int ncid, int varid, void *buf, MPI_Offset bufcount, MPI_Datatype buftype);
int ncmpi_get_var_all          (int ncid, int varid, void *buf, MPI_Offset bufcount, MPI_Datatype buftype);
int ncmpi_get_var_text         (int ncid, int varid, char *ip);
int ncmpi_get_var_text_all     (int ncid, int varid, char *ip);
int ncmpi_get_var_schar        (int ncid, int varid, signed char *ip);
int ncmpi_get_var_schar_all    (int ncid, int varid, signed char *ip);
int ncmpi_get_var_short        (int ncid, int varid, short *ip);
int ncmpi_get_var_short_all    (int ncid, int varid, short *ip);
int ncmpi_get_var_int          (int ncid, int varid, int *ip);
int ncmpi_get_var_int_all      (int ncid, int varid, int *ip);
int ncmpi_get_var_float        (int ncid, int varid, float *ip);
int ncmpi_get_var_float_all    (int ncid, int varid, float *ip);
int ncmpi_get_var_double       (int ncid, int varid, double *ip);
int ncmpi_get_var_double_all   (int ncid, int varid, double *ip);
int ncmpi_get_var_longlong     (int ncid, int varid, long long *ip);
int ncmpi_get_var_longlong_all (int ncid, int varid, long long *ip);
@end example

The following put/get var APIs are skipped for Fortran binding as Fortran APIs does not support the following C types: uchar, ubyte, ushort, uint, long, ulonglong, string.
@example
int ncmpi_put_var_uchar         (int ncid, int varid, const unsigned char *op);
int ncmpi_put_var_uchar_all     (int ncid, int varid, const unsigned char *op);
int ncmpi_put_var_ushort        (int ncid, int varid, const unsigned short *op);
int ncmpi_put_var_ushort_all    (int ncid, int varid, const unsigned short *op);
int ncmpi_put_var_uint          (int ncid, int varid, const unsigned int *op);
int ncmpi_put_var_uint_all      (int ncid, int varid, const unsigned int *op);
int ncmpi_put_var_long          (int ncid, int varid, const long *op);
int ncmpi_put_var_long_all      (int ncid, int varid, const long *op);
int ncmpi_put_var_ulonglong     (int ncid, int varid, const unsigned long long *op);
int ncmpi_put_var_ulonglong_all (int ncid, int varid, const unsigned long long *op);
int ncmpi_get_var_uchar         (int ncid, int varid, unsigned char *ip);
int ncmpi_get_var_uchar_all     (int ncid, int varid, unsigned char *ip);
int ncmpi_get_var_ushort        (int ncid, int varid, unsigned short *ip);
int ncmpi_get_var_ushort_all    (int ncid, int varid, unsigned short *ip);
int ncmpi_get_var_uint          (int ncid, int varid, unsigned int *ip);
int ncmpi_get_var_uint_all      (int ncid, int varid, unsigned int *ip);
int ncmpi_get_var_long          (int ncid, int varid, long *ip);
int ncmpi_get_var_long_all      (int ncid, int varid, long *ip);
int ncmpi_get_var_ulonglong     (int ncid, int varid, unsigned long long *ip);
int ncmpi_get_var_ulonglong_all (int ncid, int varid, unsigned long long *ip);
@end example

@heading put/get vara APIs
@example
int ncmpi_put_vara              (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const void *buf, MPI_Offset bufcount, MPI_Datatype buftype);
int ncmpi_put_vara_all          (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const void *buf, MPI_Offset bufcount, MPI_Datatype buftype);
int ncmpi_put_vara_text         (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const char *op);
int ncmpi_put_vara_text_all     (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const char *op);
int ncmpi_put_vara_schar        (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const signed char *op);
int ncmpi_put_vara_schar_all    (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const signed char *op);
int ncmpi_put_vara_short        (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const short *op);
int ncmpi_put_vara_short_all    (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const short *op);
int ncmpi_put_vara_int          (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const int *op);
int ncmpi_put_vara_int_all      (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const int *op);
int ncmpi_put_vara_float        (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const float *op);
int ncmpi_put_vara_float_all    (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const float *op);
int ncmpi_put_vara_double       (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const double *op);
int ncmpi_put_vara_double_all   (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const double *op);
int ncmpi_put_vara_longlong     (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const long long *op);
int ncmpi_put_vara_longlong_all (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const long long *op);
int ncmpi_get_vara              (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], void *buf, MPI_Offset bufcount, MPI_Datatype buftype);
int ncmpi_get_vara_all          (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], void *buf, MPI_Offset bufcount, MPI_Datatype buftype);
int ncmpi_get_vara_text         (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], char *ip);
int ncmpi_get_vara_text_all     (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], char *ip);
int ncmpi_get_vara_schar        (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], signed char *ip);
int ncmpi_get_vara_schar_all    (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], signed char *ip);
int ncmpi_get_vara_short        (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], short *ip);
int ncmpi_get_vara_short_all    (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], short *ip);
int ncmpi_get_vara_int          (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], int *ip);
int ncmpi_get_vara_int_all      (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], int *ip);
int ncmpi_get_vara_float        (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], float *ip);
int ncmpi_get_vara_float_all    (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], float *ip);
int ncmpi_get_vara_double       (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], double *ip);
int ncmpi_get_vara_double_all   (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], double *ip);
int ncmpi_get_vara_longlong     (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], long long *ip);
int ncmpi_get_vara_longlong_all (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], long long *ip);
@end example

The following put/get vara APIs are skipped for Fortran binding as Fortran APIs does not support the following C types: uchar, ubyte, ushort, uint, long, ulonglong, string.
@example
int ncmpi_put_vara_uchar         (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const unsigned char *op);
int ncmpi_put_vara_uchar_all     (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const unsigned char *op);
int ncmpi_put_vara_ushort        (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const unsigned short *op);
int ncmpi_put_vara_ushort_all    (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const unsigned short *op);
int ncmpi_put_vara_uint          (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const unsigned int *op);
int ncmpi_put_vara_uint_all      (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const unsigned int *op);
int ncmpi_put_vara_long          (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const long *op);
int ncmpi_put_vara_long_all      (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const long *op);
int ncmpi_put_vara_ulonglong     (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const unsigned long long *op);
int ncmpi_put_vara_ulonglong_all (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const unsigned long long *op);
int ncmpi_get_vara_uchar         (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], unsigned char *ip);
int ncmpi_get_vara_uchar_all     (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], unsigned char *ip);
int ncmpi_get_vara_ushort        (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], unsigned short *ip);
int ncmpi_get_vara_ushort_all    (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], unsigned short *ip);
int ncmpi_get_vara_uint          (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], unsigned int *ip);
int ncmpi_get_vara_uint_all      (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], unsigned int *ip);
int ncmpi_get_vara_long          (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], long *ip);
int ncmpi_get_vara_long_all      (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], long *ip);
int ncmpi_get_vara_ulonglong     (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], unsigned long long *ip);
int ncmpi_get_vara_ulonglong_all (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], unsigned long long *ip);
@end example

@heading put/get vars APIs
@example
int ncmpi_put_vars              (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const void *buf, MPI_Offset bufcount, MPI_Datatype buftype);
int ncmpi_put_vars_all          (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const void *buf, MPI_Offset bufcount, MPI_Datatype buftype);
int ncmpi_put_vars_text         (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const char *op);
int ncmpi_put_vars_text_all     (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const char *op);
int ncmpi_put_vars_schar        (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const signed char *op);
int ncmpi_put_vars_schar_all    (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const signed char *op);
int ncmpi_put_vars_short        (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const short *op);
int ncmpi_put_vars_short_all    (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const short *op);
int ncmpi_put_vars_int          (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const int *op);
int ncmpi_put_vars_int_all      (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const int *op);
int ncmpi_put_vars_float        (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const float *op);
int ncmpi_put_vars_float_all    (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const float *op);
int ncmpi_put_vars_double       (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const double *op);
int ncmpi_put_vars_double_all   (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const double *op);
int ncmpi_put_vars_longlong     (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const long long *op);
int ncmpi_put_vars_longlong_all (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const long long *op);
int ncmpi_get_vars              (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], void *buf, MPI_Offset bufcount, MPI_Datatype buftype);
int ncmpi_get_vars_all          (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], void *buf, MPI_Offset bufcount, MPI_Datatype buftype);
int ncmpi_get_vars_schar        (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], signed char *ip);
int ncmpi_get_vars_schar_all    (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], signed char *ip);
int ncmpi_get_vars_text         (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], char *ip);
int ncmpi_get_vars_text_all     (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], char *ip);
int ncmpi_get_vars_short        (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], short *ip);
int ncmpi_get_vars_short_all    (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], short *ip);
int ncmpi_get_vars_int          (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], int *ip);
int ncmpi_get_vars_int_all      (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], int *ip);
int ncmpi_get_vars_float        (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], float *ip);
int ncmpi_get_vars_float_all    (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], float *ip);
int ncmpi_get_vars_double       (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], double *ip);
int ncmpi_get_vars_double_all   (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], double *ip);
int ncmpi_get_vars_longlong     (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], long long *ip);
int ncmpi_get_vars_longlong_all (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], long long *ip);
@end example

The following put/get vars APIs are skipped for Fortran binding as Fortran APIs does not support the following C types: uchar, ubyte, ushort, uint, long, ulonglong, string.
@example
int ncmpi_put_vars_uchar         (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const unsigned char *op);
int ncmpi_put_vars_uchar_all     (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const unsigned char *op);
int ncmpi_put_vars_ushort        (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const unsigned short *op);
int ncmpi_put_vars_ushort_all    (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const unsigned short *op);
int ncmpi_put_vars_uint          (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const unsigned int *op);
int ncmpi_put_vars_uint_all      (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const unsigned int *op);
int ncmpi_put_vars_long          (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const long *op);
int ncmpi_put_vars_long_all      (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const long *op);
int ncmpi_put_vars_ulonglong     (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const unsigned long long *op);
int ncmpi_put_vars_ulonglong_all (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const unsigned long long *op);
int ncmpi_get_vars_uchar         (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], unsigned char *ip);
int ncmpi_get_vars_uchar_all     (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], unsigned char *ip);
int ncmpi_get_vars_ushort        (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], unsigned short *ip);
int ncmpi_get_vars_ushort_all    (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], unsigned short *ip);
int ncmpi_get_vars_uint          (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], unsigned int *ip);
int ncmpi_get_vars_uint_all      (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], unsigned int *ip);
int ncmpi_get_vars_long          (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], long *ip);
int ncmpi_get_vars_long_all      (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], long *ip);
int ncmpi_get_vars_ulonglong     (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], unsigned long long *ip);
int ncmpi_get_vars_ulonglong_all (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], unsigned long long *ip);
@end example

@heading put/get varm APIs
@example
int ncmpi_put_varm              (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], const void *buf, MPI_Offset bufcount, MPI_Datatype buftype);
int ncmpi_put_varm_all          (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], const void *buf, MPI_Offset bufcount, MPI_Datatype buftype);
int ncmpi_put_varm_text         (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], const char *op);
int ncmpi_put_varm_text_all     (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], const char *op);
int ncmpi_put_varm_schar        (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], const signed char *op);
int ncmpi_put_varm_schar_all    (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], const signed char *op);
int ncmpi_put_varm_short        (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], const short *op);
int ncmpi_put_varm_short_all    (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], const short *op);
int ncmpi_put_varm_int          (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], const int *op);
int ncmpi_put_varm_int_all      (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], const int *op);
int ncmpi_put_varm_float        (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], const float *op);
int ncmpi_put_varm_float_all    (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], const float *op);
int ncmpi_put_varm_double       (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], const double *op);
int ncmpi_put_varm_double_all   (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], const double *op);
int ncmpi_put_varm_longlong     (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], const long long *op);
int ncmpi_put_varm_longlong_all (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], const long long *op);
int ncmpi_get_varm              (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], void *buf, MPI_Offset bufcount, MPI_Datatype buftype);
int ncmpi_get_varm_all          (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], void *buf, MPI_Offset bufcount, MPI_Datatype buftype);
int ncmpi_get_varm_schar        (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], signed char *ip);
int ncmpi_get_varm_schar_all    (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], signed char *ip);
int ncmpi_get_varm_text         (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], char *ip);
int ncmpi_get_varm_text_all     (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], char *ip);
int ncmpi_get_varm_short        (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], short *ip);
int ncmpi_get_varm_short_all    (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], short *ip);
int ncmpi_get_varm_int          (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], int *ip);
int ncmpi_get_varm_int_all      (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], int *ip);
int ncmpi_get_varm_float        (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], float *ip);
int ncmpi_get_varm_float_all    (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], float *ip);
int ncmpi_get_varm_double       (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], double *ip);
int ncmpi_get_varm_double_all   (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], double *ip);
int ncmpi_get_varm_longlong     (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], long long *ip);
int ncmpi_get_varm_longlong_all (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], long long *ip);
@end example

The following iput/iget/bput varm APIs are skipped for Fortran binding as Fortran APIs does not support the following C types: uchar, ubyte, ushort, uint, long, ulonglong, string.
@example
int ncmpi_put_varm_uchar        (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], const unsigned char *op);
int ncmpi_put_varm_uchar_all    (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], const unsigned char *op);
int ncmpi_put_varm_ushort       (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], const unsigned short *op);
int ncmpi_put_varm_ushort_all   (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], const unsigned short *op);
int ncmpi_put_varm_uint         (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], const unsigned int *op);
int ncmpi_put_varm_uint_all     (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], const unsigned int *op);
int ncmpi_put_varm_long         (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], const long *op);
int ncmpi_put_varm_long_all     (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], const long *op);
int ncmpi_put_varm_ulonglong    (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], const unsigned long long *op);
int ncmpi_put_varm_ulonglong_all(int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], const unsigned long long *op);
int ncmpi_get_varm_uchar        (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], unsigned char *ip);
int ncmpi_get_varm_uchar_all    (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], unsigned char *ip);
int ncmpi_get_varm_ushort       (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], unsigned short *ip);
int ncmpi_get_varm_ushort_all   (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], unsigned short *ip);
int ncmpi_get_varm_uint         (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], unsigned int *ip);
int ncmpi_get_varm_uint_all     (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], unsigned int *ip);
int ncmpi_get_varm_long         (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], long *ip);
int ncmpi_get_varm_long_all     (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], long *ip);
int ncmpi_get_varm_ulonglong    (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], unsigned long long *ip);
int ncmpi_get_varm_ulonglong_all(int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], unsigned long long *ip);
@end example

@heading Non-blocking APIs
@example
int ncmpi_wait             (int ncid, int count, int array_of_requests[], int array_of_statuses[]);
int ncmpi_wait_all         (int ncid, int count, int array_of_requests[], int array_of_statuses[]);
int ncmpi_cancel           (int ncid, int num, int *requests, int *statuses);
int ncmpi_buffer_attach    (int ncid, MPI_Offset bufsize);
int ncmpi_buffer_detach    (int ncid);
int ncmpi_inq_buffer_usage (int ncid, MPI_Offset *usage);
int ncmpi_inq_buffer_size  (int ncid, MPI_Offset *buf_size);
int ncmpi_inq_nreqs        (int ncid, int *nreqs);
@end example

@heading Non-blocking iput/iget/bput var1 APIs
@example
int ncmpi_iput_var1          (int ncid, int varid, const MPI_Offset index[], const void *buf, MPI_Offset bufcount, MPI_Datatype buftype, int *request);
int ncmpi_iput_var1_text     (int ncid, int varid, const MPI_Offset index[], const char *op, int *request);
int ncmpi_iput_var1_schar    (int ncid, int varid, const MPI_Offset index[], const signed char *op, int *request);
int ncmpi_iput_var1_short    (int ncid, int varid, const MPI_Offset index[], const short *op, int *request);
int ncmpi_iput_var1_int      (int ncid, int varid, const MPI_Offset index[], const int *op, int *request);
int ncmpi_iput_var1_float    (int ncid, int varid, const MPI_Offset index[], const float *op, int *request);
int ncmpi_iput_var1_double   (int ncid, int varid, const MPI_Offset index[], const double *op, int *request);
int ncmpi_iput_var1_longlong (int ncid, int varid, const MPI_Offset index[], const long long *op, int *request);
int ncmpi_iget_var1          (int ncid, int varid, const MPI_Offset index[], void *buf, MPI_Offset bufcount, MPI_Datatype buftype, int *request);
int ncmpi_iget_var1_schar    (int ncid, int varid, const MPI_Offset index[], signed char *ip, int *request);
int ncmpi_iget_var1_text     (int ncid, int varid, const MPI_Offset index[], char *ip, int *request);
int ncmpi_iget_var1_short    (int ncid, int varid, const MPI_Offset index[], short *ip, int *request);
int ncmpi_iget_var1_int      (int ncid, int varid, const MPI_Offset index[], int *ip, int *request);
int ncmpi_iget_var1_float    (int ncid, int varid, const MPI_Offset index[], float *ip, int *request);
int ncmpi_iget_var1_double   (int ncid, int varid, const MPI_Offset index[], double *ip, int *request);
int ncmpi_iget_var1_longlong (int ncid, int varid, const MPI_Offset index[], long long *ip, int *request);
int ncmpi_bput_var1          (int ncid, int varid, const MPI_Offset index[], const void *buf, MPI_Offset bufcount, MPI_Datatype buftype, int *request);
int ncmpi_bput_var1_text     (int ncid, int varid, const MPI_Offset index[], const char *op, int *request);
int ncmpi_bput_var1_schar    (int ncid, int varid, const MPI_Offset index[], const signed char *op, int *request);
int ncmpi_bput_var1_short    (int ncid, int varid, const MPI_Offset index[], const short *op, int *request);
int ncmpi_bput_var1_int      (int ncid, int varid, const MPI_Offset index[], const int *op, int *request);
int ncmpi_bput_var1_float    (int ncid, int varid, const MPI_Offset index[], const float *op, int *request);
int ncmpi_bput_var1_double   (int ncid, int varid, const MPI_Offset index[], const double *op, int *request);
int ncmpi_bput_var1_longlong (int ncid, int varid, const MPI_Offset index[], const long long *op, int *request);
@end example

The following iput/iget/bput var1 APIs are skipped for Fortran binding as Fortran APIs does not support the following C types: uchar, ubyte, ushort, uint, long, ulonglong, string.
@example
int ncmpi_iput_var1_uchar     (int ncid, int varid, const MPI_Offset index[], const unsigned char *op, int *request);
int ncmpi_iput_var1_ushort    (int ncid, int varid, const MPI_Offset index[], const unsigned short *op, int *request);
int ncmpi_iput_var1_uint      (int ncid, int varid, const MPI_Offset index[], const unsigned int *op, int *request);
int ncmpi_iput_var1_long      (int ncid, int varid, const MPI_Offset index[], const long *ip, int *request);
int ncmpi_iput_var1_ulonglong (int ncid, int varid, const MPI_Offset index[], const unsigned long long *op, int *request);
int ncmpi_iget_var1_uchar     (int ncid, int varid, const MPI_Offset index[], unsigned char *ip, int *request);
int ncmpi_iget_var1_ushort    (int ncid, int varid, const MPI_Offset index[], unsigned short *ip, int *request);
int ncmpi_iget_var1_uint      (int ncid, int varid, const MPI_Offset index[], unsigned int *ip, int *request);
int ncmpi_iget_var1_long      (int ncid, int varid, const MPI_Offset index[], long *ip, int *request);
int ncmpi_iget_var1_ulonglong (int ncid, int varid, const MPI_Offset index[], unsigned long long *ip, int *request);
int ncmpi_bput_var1_uchar     (int ncid, int varid, const MPI_Offset index[], const unsigned char *op, int *request);
int ncmpi_bput_var1_ushort    (int ncid, int varid, const MPI_Offset index[], const unsigned short *op, int *request);
int ncmpi_bput_var1_uint      (int ncid, int varid, const MPI_Offset index[], const unsigned int *op, int *request);
int ncmpi_bput_var1_long      (int ncid, int varid, const MPI_Offset index[], const long *ip, int *request);
int ncmpi_bput_var1_ulonglong (int ncid, int varid, const MPI_Offset index[], const unsigned long long *op, int *request);
@end example

@heading Non-blocking iput/iget/bput var APIs
@example
int ncmpi_iput_var          (int ncid, int varid, const void *buf, MPI_Offset bufcount, MPI_Datatype buftype, int *request);
int ncmpi_iput_var_schar    (int ncid, int varid, const signed char *op, int *request);
int ncmpi_iput_var_text     (int ncid, int varid, const char *op, int *request);
int ncmpi_iput_var_short    (int ncid, int varid, const short *op, int *request);
int ncmpi_iput_var_int      (int ncid, int varid, const int *op, int *request);
int ncmpi_iput_var_float    (int ncid, int varid, const float *op, int *request);
int ncmpi_iput_var_double   (int ncid, int varid, const double *op, int *request);
int ncmpi_iput_var_longlong (int ncid, int varid, const long long *op, int *request);
int ncmpi_iget_var          (int ncid, int varid, void *buf, MPI_Offset bufcount, MPI_Datatype buftype, int *request);
int ncmpi_iget_var_schar    (int ncid, int varid, signed char *ip, int *request);
int ncmpi_iget_var_text     (int ncid, int varid, char *ip, int *request);
int ncmpi_iget_var_short    (int ncid, int varid, short *ip, int *request);
int ncmpi_iget_var_int      (int ncid, int varid, int *ip, int *request);
int ncmpi_iget_var_float    (int ncid, int varid, float *ip, int *request);
int ncmpi_iget_var_double   (int ncid, int varid, double *ip, int *request);
int ncmpi_iget_var_longlong (int ncid, int varid, long long *ip, int *request);
int ncmpi_bput_var          (int ncid, int varid, const void *buf, MPI_Offset bufcount, MPI_Datatype buftype, int *request);
int ncmpi_bput_var_schar    (int ncid, int varid, const signed char *op, int *request);
int ncmpi_bput_var_text     (int ncid, int varid, const char *op, int *request);
int ncmpi_bput_var_short    (int ncid, int varid, const short *op, int *request);
int ncmpi_bput_var_int      (int ncid, int varid, const int *op, int *request);
int ncmpi_bput_var_float    (int ncid, int varid, const float *op, int *request);
int ncmpi_bput_var_double   (int ncid, int varid, const double *op, int *request);
int ncmpi_bput_var_longlong (int ncid, int varid, const long long *op, int *request);
@end example

The following iput/iget/bput var APIs are skipped for Fortran binding as Fortran APIs does not support the following C types: uchar, ubyte, ushort, uint, long, ulonglong, string.
@example
int ncmpi_iput_var_uchar     (int ncid, int varid, const unsigned char *op, int *request);
int ncmpi_iput_var_ushort    (int ncid, int varid, const unsigned short *op, int *request);
int ncmpi_iput_var_uint      (int ncid, int varid, const unsigned int *op, int *request);
int ncmpi_iput_var_long      (int ncid, int varid, const long *op, int *request);
int ncmpi_iput_var_ulonglong (int ncid, int varid, const unsigned long long *op, int *request);
int ncmpi_iget_var_uchar     (int ncid, int varid, unsigned char *ip, int *request);
int ncmpi_iget_var_ushort    (int ncid, int varid, unsigned short *ip, int *request);
int ncmpi_iget_var_uint      (int ncid, int varid, unsigned int *ip, int *request);
int ncmpi_iget_var_long      (int ncid, int varid, long *ip, int *request);
int ncmpi_iget_var_ulonglong (int ncid, int varid, unsigned long long *ip, int *request);
int ncmpi_bput_var_uchar     (int ncid, int varid, const unsigned char *op, int *request);
int ncmpi_bput_var_ushort    (int ncid, int varid, const unsigned short *op, int *request);
int ncmpi_bput_var_uint      (int ncid, int varid, const unsigned int *op, int *request);
int ncmpi_bput_var_long      (int ncid, int varid, const long *op, int *request);
int ncmpi_bput_var_ulonglong (int ncid, int varid, const unsigned long long *op, int *request);
@end example

@heading Non-blocking iput/iget/bput vara APIs
@example
int ncmpi_iput_vara          (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const void *buf, MPI_Offset bufcount, MPI_Datatype buftype, int *request);
int ncmpi_iput_vara_schar    (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const signed char *op, int *request);
int ncmpi_iput_vara_text     (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const char *op, int *request);
int ncmpi_iput_vara_short    (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const short *op, int *request);
int ncmpi_iput_vara_int      (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const int *op, int *request);
int ncmpi_iput_vara_float    (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const float *op, int *request);
int ncmpi_iput_vara_double   (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const double *op, int *request);
int ncmpi_iput_vara_longlong (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const long long *op, int *request);
int ncmpi_iget_vara          (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], void *buf, MPI_Offset bufcount, MPI_Datatype buftype, int *request);
int ncmpi_iget_vara_schar    (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], signed char *ip, int *request);
int ncmpi_iget_vara_text     (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], char *ip, int *request);
int ncmpi_iget_vara_short    (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], short *ip, int *request);
int ncmpi_iget_vara_int      (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], int *ip, int *request);
int ncmpi_iget_vara_float    (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], float *ip, int *request);
int ncmpi_iget_vara_double   (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], double *ip, int *request);
int ncmpi_iget_vara_longlong (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], long long *ip, int *request);
int ncmpi_bput_vara          (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const void *buf, MPI_Offset bufcount, MPI_Datatype buftype, int *request);
int ncmpi_bput_vara_schar    (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const signed char *op, int *request);
int ncmpi_bput_vara_text     (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const char *op, int *request);
int ncmpi_bput_vara_short    (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const short *op, int *request);
int ncmpi_bput_vara_int      (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const int *op, int *request);
int ncmpi_bput_vara_float    (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const float *op, int *request);
int ncmpi_bput_vara_double   (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const double *op, int *request);
int ncmpi_bput_vara_longlong (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const long long *op, int *request);
@end example

The following iput/iget/bput vara APIs are skipped for Fortran binding as Fortran APIs does not support the following C types: uchar, ubyte, ushort, uint, long, ulonglong, string.
@example
int ncmpi_iput_vara_uchar     (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const unsigned char *op, int *request);
int ncmpi_iput_vara_ushort    (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const unsigned short *op, int *request);
int ncmpi_iput_vara_uint      (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const unsigned int *op, int *request);
int ncmpi_iput_vara_long      (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const long *op, int *request);
int ncmpi_iput_vara_ulonglong (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const unsigned long long *op, int *request);
int ncmpi_iget_vara_uchar     (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], unsigned char *ip, int *request);
int ncmpi_iget_vara_ushort    (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], unsigned short *ip, int *request);
int ncmpi_iget_vara_uint      (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], unsigned int *ip, int *request);
int ncmpi_iget_vara_long      (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], long *ip, int *request);
int ncmpi_iget_vara_ulonglong (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], unsigned long long *ip, int *request);
int ncmpi_bput_vara_uchar     (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const unsigned char *op, int *request);
int ncmpi_bput_vara_ushort    (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const unsigned short *op, int *request);
int ncmpi_bput_vara_uint      (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const unsigned int *op, int *request);
int ncmpi_bput_vara_long      (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const long *op, int *request);
int ncmpi_bput_vara_ulonglong (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const unsigned long long *op, int *request);
@end example

@heading Non-blocking iput/iget/bput vars APIs
@example
int ncmpi_iput_vars          (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const void *buf, MPI_Offset bufcount, MPI_Datatype buftype, int *request);
int ncmpi_iput_vars_schar    (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const signed char *op, int *request);
int ncmpi_iput_vars_text     (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const char *op, int *request);
int ncmpi_iput_vars_short    (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const short *op, int *request);
int ncmpi_iput_vars_int      (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const int *op, int *request);
int ncmpi_iput_vars_float    (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const float *op, int *request);
int ncmpi_iput_vars_double   (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const double *op, int *request);
int ncmpi_iput_vars_longlong (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const long long *op, int *request);
int ncmpi_iget_vars          (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], void *buf, MPI_Offset bufcount, MPI_Datatype buftype, int *request);
int ncmpi_iget_vars_schar    (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], signed char *ip, int *request);
int ncmpi_iget_vars_text     (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], char *ip, int *request);
int ncmpi_iget_vars_short    (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], short *ip, int *request);
int ncmpi_iget_vars_int      (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], int *ip, int *request);
int ncmpi_iget_vars_float    (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], float *ip, int *request);
int ncmpi_iget_vars_double   (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], double *ip, int *request);
int ncmpi_iget_vars_longlong (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], long long *ip, int *request);
int ncmpi_bput_vars          (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const void *buf, MPI_Offset bufcount, MPI_Datatype buftype, int *request);
int ncmpi_bput_vars_schar    (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const signed char *op, int *request);
int ncmpi_bput_vars_text     (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const char *op, int *request);
int ncmpi_bput_vars_short    (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const short *op, int *request);
int ncmpi_bput_vars_int      (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const int *op, int *request);
int ncmpi_bput_vars_float    (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const float *op, int *request);
int ncmpi_bput_vars_double   (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const double *op, int *request);
int ncmpi_bput_vars_longlong (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const long long *op, int *request);
@end example

The following iput/iget/bput vars APIs are skipped for Fortran binding as Fortran APIs does not support the following C types: uchar, ubyte, ushort, uint, long, ulonglong, string.
@example
int ncmpi_iput_vars_uchar     (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const unsigned char *op, int *request);
int ncmpi_iput_vars_ushort    (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const unsigned short *op, int *request);
int ncmpi_iput_vars_uint      (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const unsigned int *op, int *request);
int ncmpi_iput_vars_long      (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const long *op, int *request);
int ncmpi_iput_vars_ulonglong (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const unsigned long long *op, int *request);
int ncmpi_iget_vars_uchar     (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], unsigned char *ip, int *request);
int ncmpi_iget_vars_ushort    (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], unsigned short *ip, int *request);
int ncmpi_iget_vars_uint      (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], unsigned int *ip, int *request);
int ncmpi_iget_vars_long      (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], long *ip, int *request);
int ncmpi_iget_vars_ulonglong (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], unsigned long long *ip, int *request);
int ncmpi_bput_vars_uchar     (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const unsigned char *op, int *request);
int ncmpi_bput_vars_ushort    (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const unsigned short *op, int *request);
int ncmpi_bput_vars_uint      (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const unsigned int *op, int *request);
int ncmpi_bput_vars_long      (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const long *op, int *request);
int ncmpi_bput_vars_ulonglong (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const unsigned long long *op, int *request);
@end example

@heading Non-blocking iput/iget/bput varm APIs
@example
int ncmpi_iput_varm          (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], const void *buf, MPI_Offset bufcount, MPI_Datatype buftype, int *request);
int ncmpi_iput_varm_schar    (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], const signed char *op, int *request);
int ncmpi_iput_varm_text     (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], const char *op, int *request);
int ncmpi_iput_varm_short    (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], const short *op, int *request);
int ncmpi_iput_varm_int      (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], const int *op, int *request);
int ncmpi_iput_varm_float    (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], const float *op, int *request);
int ncmpi_iput_varm_double   (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], const double *op, int *request);
int ncmpi_iput_varm_longlong (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], const long long *op, int *request);
int ncmpi_iget_varm          (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], void *buf, MPI_Offset bufcount, MPI_Datatype buftype, int *request);
int ncmpi_iget_varm_schar    (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], signed char *ip, int *request);
int ncmpi_iget_varm_text     (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], char *ip, int *request);
int ncmpi_iget_varm_short    (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], short *ip, int *request);
int ncmpi_iget_varm_int      (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], int *ip, int *request);
int ncmpi_iget_varm_float    (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], float *ip, int *request);
int ncmpi_iget_varm_double   (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], double *ip, int *request);
int ncmpi_iget_varm_longlong (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], long long *ip, int *request);
int ncmpi_bput_varm          (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], const void *buf, MPI_Offset bufcount, MPI_Datatype buftype, int *request);
int ncmpi_bput_varm_schar    (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], const signed char *op, int *request);
int ncmpi_bput_varm_text     (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], const char *op, int *request);
int ncmpi_bput_varm_short    (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], const short *op, int *request);
int ncmpi_bput_varm_int      (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], const int *op, int *request);
int ncmpi_bput_varm_float    (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], const float *op, int *request);
int ncmpi_bput_varm_double   (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], const double *op, int *request);
int ncmpi_bput_varm_longlong (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], const long long *op, int *request);
@end example

The following iput/iget/bput varm APIs are skipped for Fortran binding as Fortran APIs does not support the following C types: uchar, ubyte, ushort, uint, long, ulonglong, string.
@example
int ncmpi_iput_varm_uchar     (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], const unsigned char *op, int *request);
int ncmpi_iput_varm_ushort    (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], const unsigned short *op, int *request);
int ncmpi_iput_varm_uint      (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], const unsigned int *op, int *request);
int ncmpi_iput_varm_long      (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], const long *op, int *request);
int ncmpi_iput_varm_ulonglong (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], const unsigned long long *op, int *request);
int ncmpi_iget_varm_uchar     (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], unsigned char *ip, int *request);
int ncmpi_iget_varm_ushort    (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], unsigned short *ip, int *request);
int ncmpi_iget_varm_uint      (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], unsigned int *ip, int *request);
int ncmpi_iget_varm_long      (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], long *ip, int *request);
int ncmpi_iget_varm_ulonglong (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], unsigned long long *ip, int *request);
int ncmpi_bput_varm_uchar     (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], const unsigned char *op, int *request);
int ncmpi_bput_varm_ushort    (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], const unsigned short *op, int *request);
int ncmpi_bput_varm_uint      (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], const unsigned int *op, int *request);
int ncmpi_bput_varm_long      (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], const long *op, int *request);
int ncmpi_bput_varm_ulonglong (int ncid, int varid, const MPI_Offset start[], const MPI_Offset count[], const MPI_Offset stride[], const MPI_Offset imap[], const unsigned long long *op, int *request);
@end example

@heading put/get varn APIs
@example
int ncmpi_put_varn              (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const void *buf, MPI_Offset bufcount, MPI_Datatype buftype);
int ncmpi_put_varn_all          (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const void *buf, MPI_Offset bufcount, MPI_Datatype buftype);
int ncmpi_get_varn              (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], void *buf, MPI_Offset bufcount, MPI_Datatype buftype);
int ncmpi_get_varn_all          (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], void *buf, MPI_Offset bufcount, MPI_Datatype buftype);
int ncmpi_put_varn_text         (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const char *buf);
int ncmpi_put_varn_schar        (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const signed char *buf);
int ncmpi_put_varn_short        (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const short *buf);
int ncmpi_put_varn_int          (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const int *buf);
int ncmpi_put_varn_float        (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const float *buf);
int ncmpi_put_varn_double       (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const double *buf);
int ncmpi_put_varn_longlong     (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const long long *buf);
int ncmpi_put_varn_text_all     (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const char *buf);
int ncmpi_put_varn_schar_all    (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const signed char *buf);
int ncmpi_put_varn_short_all    (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const short *buf);
int ncmpi_put_varn_int_all      (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const int *buf);
int ncmpi_put_varn_float_all    (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const float *buf);
int ncmpi_put_varn_double_all   (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const double *buf);
int ncmpi_put_varn_longlong_all (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const long long *buf);
int ncmpi_get_varn_text         (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], char *buf);
int ncmpi_get_varn_schar        (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], signed char *buf);
int ncmpi_get_varn_short        (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], short *buf);
int ncmpi_get_varn_int          (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], int *buf);
int ncmpi_get_varn_float        (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], float *buf);
int ncmpi_get_varn_double       (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], double *buf);
int ncmpi_get_varn_longlong     (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], long long *buf);
int ncmpi_get_varn_text_all     (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], char *buf);
int ncmpi_get_varn_schar_all    (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], signed char *buf);
int ncmpi_get_varn_short_all    (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], short *buf);
int ncmpi_get_varn_int_all      (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], int *buf);
int ncmpi_get_varn_float_all    (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], float *buf);
int ncmpi_get_varn_double_all   (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], double *buf);
int ncmpi_get_varn_longlong_all (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], long long *buf);
@end example

The following put/get varn APIs are skipped for Fortran binding as Fortran APIs does not support the following C types: uchar, ubyte, ushort, uint, long, ulonglong, string.
@example
int ncmpi_put_varn_uchar         (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const unsigned char *buf);
int ncmpi_put_varn_ushort        (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const unsigned short *buf);
int ncmpi_put_varn_uint          (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const unsigned int *buf);
int ncmpi_put_varn_long          (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const long *buf);
int ncmpi_put_varn_ulonglong     (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const unsigned long long *buf);
int ncmpi_put_varn_uchar_all     (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const unsigned char *buf);
int ncmpi_put_varn_ushort_all    (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const unsigned short *buf);
int ncmpi_put_varn_uint_all      (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const unsigned int *buf);
int ncmpi_put_varn_long_all      (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const long *buf);
int ncmpi_put_varn_ulonglong_all (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const unsigned long long *buf);
int ncmpi_get_varn_uchar         (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], unsigned char *buf);
int ncmpi_get_varn_ushort        (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], unsigned short *buf);
int ncmpi_get_varn_uint          (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], unsigned int *buf);
int ncmpi_get_varn_long          (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], long *buf);
int ncmpi_get_varn_ulonglong     (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], unsigned long long *buf);
int ncmpi_get_varn_uchar_all     (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], unsigned char *buf);
int ncmpi_get_varn_ushort_all    (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], unsigned short *buf);
int ncmpi_get_varn_uint_all      (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], unsigned int *buf);
int ncmpi_get_varn_long_all      (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], long *buf);
int ncmpi_get_varn_ulonglong_all (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], unsigned long long *buf);
@end example

@heading iput/iget varn APIs
@example
int ncmpi_iput_varn          (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const void *buf, MPI_Offset bufcount, MPI_Datatype buftype, int *request);
int ncmpi_iget_varn          (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[],  void *buf, MPI_Offset bufcount, MPI_Datatype buftype, int *request);
int ncmpi_iput_varn_text     (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const char *buf, int *request);
int ncmpi_iput_varn_schar    (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const signed char *buf, int *request);
int ncmpi_iput_varn_short    (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const short *buf, int *request);
int ncmpi_iput_varn_int      (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const int *buf, int *request);
int ncmpi_iput_varn_float    (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const float *buf, int *request);
int ncmpi_iput_varn_double   (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const double *buf, int *request);
int ncmpi_iput_varn_longlong (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const long long *buf, int *request);
int ncmpi_iget_varn_text     (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], char *buf, int *request);
int ncmpi_iget_varn_schar    (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], signed char *buf, int *request);
int ncmpi_iget_varn_short    (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], short *buf, int *request);
int ncmpi_iget_varn_int      (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], int *buf, int *request);
int ncmpi_iget_varn_float    (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], float *buf, int *request);
int ncmpi_iget_varn_double   (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], double *buf, int *request);
int ncmpi_iget_varn_longlong (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], long long *buf, int *request);
@end example
The following put/get varn APIs are skipped for Fortran binding as Fortran APIs does not support the following C types: uchar, ubyte, ushort, uint, long, ulonglong, string.
@example
int ncmpi_iput_varn_uchar     (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const unsigned char *buf, int *request);
int ncmpi_iput_varn_ushort    (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const unsigned short *buf, int *request);
int ncmpi_iput_varn_uint      (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const unsigned int *buf, int *request);
int ncmpi_iput_varn_long      (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const long *buf, int *request);
int ncmpi_iput_varn_ulonglong (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const unsigned long long *buf, int *request);
int ncmpi_iget_varn_uchar     (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], unsigned char *buf, int *request);
int ncmpi_iget_varn_ushort    (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], unsigned short *buf, int *request);
int ncmpi_iget_varn_uint      (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], unsigned int *buf, int *request);
int ncmpi_iget_varn_long      (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], long *buf, int *request);
int ncmpi_iget_varn_ulonglong (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], unsigned long long *buf, int *request);
@end example

@heading bput varn APIs
@example
int ncmpi_bput_varn          (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const void *buf, MPI_Offset bufcount, MPI_Datatype buftype, int *request);
int ncmpi_bput_varn_text     (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const char *buf, int *request);
int ncmpi_bput_varn_schar    (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const signed char *buf, int *request);
int ncmpi_bput_varn_short    (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const short *buf, int *request);
int ncmpi_bput_varn_int      (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const int *buf, int *request);
int ncmpi_bput_varn_float    (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const float *buf, int *request);
int ncmpi_bput_varn_double   (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const double *buf, int *request);
int ncmpi_bput_varn_longlong (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const long long *buf, int *request);
@end example
The following put/get varn APIs are skipped for Fortran binding as Fortran APIs does not support the following C types: uchar, ubyte, ushort, uint, long, ulonglong, string.
@example
int ncmpi_bput_varn_uchar     (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const unsigned char *buf, int *request);
int ncmpi_bput_varn_ushort    (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const unsigned short *buf, int *request);
int ncmpi_bput_varn_uint      (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const unsigned int *buf, int *request);
int ncmpi_bput_varn_long      (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const long *buf, int *request);
int ncmpi_bput_varn_ulonglong (int ncid, int varid, int num, MPI_Offset* const starts[], MPI_Offset* const counts[], const unsigned long long *buf, int *request);
@end example

@heading get/put vard APIs
@example
int ncmpi_get_vard     (int ncid, int varid, MPI_Datatype filetype,       void *buf, MPI_Offset bufcount, MPI_Datatype buftype);
int ncmpi_get_vard_all (int ncid, int varid, MPI_Datatype filetype,       void *buf, MPI_Offset bufcount, MPI_Datatype buftype);
int ncmpi_put_vard     (int ncid, int varid, MPI_Datatype filetype, const void *buf, MPI_Offset bufcount, MPI_Datatype buftype);
int ncmpi_put_vard_all (int ncid, int varid, MPI_Datatype filetype, const void *buf, MPI_Offset bufcount, MPI_Datatype buftype);
@end example

@heading mput/mget var APIs
All mput/mget APIs are skipped for Fortran binding.
@example
int ncmpi_mput_var               (int ncid, int num, int varids[], void *bufs[], MPI_Offset bufcounts[], MPI_Datatype datatypes[]);
int ncmpi_mput_var_all           (int ncid, int num, int varids[], void *bufs[], MPI_Offset bufcounts[], MPI_Datatype datatypes[]);
int ncmpi_mput_var_text          (int ncid, int num, int varids[], char *bufs[]);
int ncmpi_mput_var_schar         (int ncid, int num, int varids[], signed char *bufs[]);
int ncmpi_mput_var_uchar         (int ncid, int num, int varids[], unsigned char *bufs[]);
int ncmpi_mput_var_short         (int ncid, int num, int varids[], short *bufs[]);
int ncmpi_mput_var_ushort        (int ncid, int num, int varids[], unsigned short *bufs[]);
int ncmpi_mput_var_int           (int ncid, int num, int varids[], int *bufs[]);
int ncmpi_mput_var_uint          (int ncid, int num, int varids[], unsigned int *bufs[]);
int ncmpi_mput_var_long          (int ncid, int num, int varids[], long *bufs[]);
int ncmpi_mput_var_float         (int ncid, int num, int varids[], float *bufs[]);
int ncmpi_mput_var_double        (int ncid, int num, int varids[], double *bufs[]);
int ncmpi_mput_var_longlong      (int ncid, int num, int varids[], long long *bufs[]);
int ncmpi_mput_var_ulonglong     (int ncid, int num, int varids[], unsigned long long *bufs[]);
int ncmpi_mput_var_text_all      (int ncid, int num, int varids[], char *bufs[]);
int ncmpi_mput_var_schar_all     (int ncid, int num, int varids[], signed char *bufs[]);
int ncmpi_mput_var_uchar_all     (int ncid, int num, int varids[], unsigned char *bufs[]);
int ncmpi_mput_var_short_all     (int ncid, int num, int varids[], short *bufs[]);
int ncmpi_mput_var_ushort_all    (int ncid, int num, int varids[], unsigned short *bufs[]);
int ncmpi_mput_var_int_all       (int ncid, int num, int varids[], int *bufs[]);
int ncmpi_mput_var_uint_all      (int ncid, int num, int varids[], unsigned int *bufs[]);
int ncmpi_mput_var_long_all      (int ncid, int num, int varids[], long *bufs[]);
int ncmpi_mput_var_float_all     (int ncid, int num, int varids[], float *bufs[]);
int ncmpi_mput_var_double_all    (int ncid, int num, int varids[], double *bufs[]);
int ncmpi_mput_var_longlong_all  (int ncid, int num, int varids[], long long *bufs[]);
int ncmpi_mput_var_ulonglong_all (int ncid, int num, int varids[], unsigned long long *bufs[]);
int ncmpi_mput_var1              (int ncid, int num, int varids[], MPI_Offset* const starts[], void *bufs[], MPI_Offset bufcounts[], MPI_Datatype datatypes[]);
int ncmpi_mput_var1_all          (int ncid, int num, int varids[], MPI_Offset* const starts[], void *bufs[], MPI_Offset bufcounts[], MPI_Datatype datatypes[]);
int ncmpi_mput_var1_text         (int ncid, int num, int varids[], MPI_Offset* const starts[], char *bufs[]);
int ncmpi_mput_var1_schar        (int ncid, int num, int varids[], MPI_Offset* const starts[], signed char *bufs[]);
int ncmpi_mput_var1_uchar        (int ncid, int num, int varids[], MPI_Offset* const starts[], unsigned char *bufs[]);
int ncmpi_mput_var1_short        (int ncid, int num, int varids[], MPI_Offset* const starts[], short *bufs[]);
int ncmpi_mput_var1_ushort       (int ncid, int num, int varids[], MPI_Offset* const starts[], unsigned short *bufs[]);
int ncmpi_mput_var1_int          (int ncid, int num, int varids[], MPI_Offset* const starts[], int *bufs[]);
int ncmpi_mput_var1_uint         (int ncid, int num, int varids[], MPI_Offset* const starts[], unsigned int *bufs[]);
int ncmpi_mput_var1_long         (int ncid, int num, int varids[], MPI_Offset* const starts[], long *bufs[]);
int ncmpi_mput_var1_float        (int ncid, int num, int varids[], MPI_Offset* const starts[], float *bufs[]);
int ncmpi_mput_var1_double       (int ncid, int num, int varids[], MPI_Offset* const starts[], double *bufs[]);
int ncmpi_mput_var1_longlong     (int ncid, int num, int varids[], MPI_Offset* const starts[], long long *bufs[]);
int ncmpi_mput_var1_ulonglong    (int ncid, int num, int varids[], MPI_Offset* const starts[], unsigned long long *bufs[]);
int ncmpi_mput_var1_text_all     (int ncid, int num, int varids[], MPI_Offset* const starts[], char *bufs[]);
int ncmpi_mput_var1_schar_all    (int ncid, int num, int varids[], MPI_Offset* const starts[], signed char *bufs[]);
int ncmpi_mput_var1_uchar_all    (int ncid, int num, int varids[], MPI_Offset* const starts[], unsigned char *bufs[]);
int ncmpi_mput_var1_short_all    (int ncid, int num, int varids[], MPI_Offset* const starts[], short *bufs[]);
int ncmpi_mput_var1_ushort_all   (int ncid, int num, int varids[], MPI_Offset* const starts[], unsigned short *bufs[]);
int ncmpi_mput_var1_int_all      (int ncid, int num, int varids[], MPI_Offset* const starts[], int *bufs[]);
int ncmpi_mput_var1_uint_all     (int ncid, int num, int varids[], MPI_Offset* const starts[], unsigned int *bufs[]);
int ncmpi_mput_var1_long_all     (int ncid, int num, int varids[], MPI_Offset* const starts[], long *bufs[]);
int ncmpi_mput_var1_float_all    (int ncid, int num, int varids[], MPI_Offset* const starts[], float *bufs[]);
int ncmpi_mput_var1_double_all   (int ncid, int num, int varids[], MPI_Offset* const starts[], double *bufs[]);
int ncmpi_mput_var1_longlong_all (int ncid, int num, int varids[], MPI_Offset* const starts[], long long *bufs[]);
int ncmpi_mput_var1_ulonglong_all(int ncid, int num, int varids[], MPI_Offset* const starts[], unsigned long long *bufs[]);
int ncmpi_mput_vara              (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], void *bufs[], MPI_Offset bufcounts[], MPI_Datatype datatypes[]);
int ncmpi_mput_vara_all          (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], void *bufs[], MPI_Offset bufcounts[], MPI_Datatype datatypes[]);
int ncmpi_mput_vara_text         (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], char *bufs[]);
int ncmpi_mput_vara_schar        (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], signed char *bufs[]);
int ncmpi_mput_vara_uchar        (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], unsigned char *bufs[]);
int ncmpi_mput_vara_short        (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], short *bufs[]);
int ncmpi_mput_vara_ushort       (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], unsigned short *bufs[]);
int ncmpi_mput_vara_int          (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], int *bufs[]);
int ncmpi_mput_vara_uint         (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], unsigned int *bufs[]);
int ncmpi_mput_vara_long         (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], long *bufs[]);
int ncmpi_mput_vara_float        (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], float *bufs[]);
int ncmpi_mput_vara_double       (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], double *bufs[]);
int ncmpi_mput_vara_longlong     (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], long long *bufs[]);
int ncmpi_mput_vara_ulonglong    (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], unsigned long long *bufs[]);
int ncmpi_mput_vara_text_all     (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], char *bufs[]);
int ncmpi_mput_vara_schar_all    (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], signed char *bufs[]);
int ncmpi_mput_vara_uchar_all    (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], unsigned char *bufs[]);
int ncmpi_mput_vara_short_all    (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], short *bufs[]);
int ncmpi_mput_vara_ushort_all   (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], unsigned short *bufs[]);
int ncmpi_mput_vara_int_all      (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], int *bufs[]);
int ncmpi_mput_vara_uint_all     (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], unsigned int *bufs[]);
int ncmpi_mput_vara_long_all     (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], long *bufs[]);
int ncmpi_mput_vara_float_all    (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], float *bufs[]);
int ncmpi_mput_vara_double_all   (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], double *bufs[]);
int ncmpi_mput_vara_longlong_all (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], long long *bufs[]);
int ncmpi_mput_vara_ulonglong_all(int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], unsigned long long *bufs[]);
int ncmpi_mput_vars              (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], void *bufs[], MPI_Offset bufcounts[], MPI_Datatype datatypes[]);
int ncmpi_mput_vars_all          (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], void *bufs[], MPI_Offset bufcounts[], MPI_Datatype datatypes[]);
int ncmpi_mput_vars_text         (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], char *bufs[]);
int ncmpi_mput_vars_schar        (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], signed char *bufs[]);
int ncmpi_mput_vars_uchar        (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], unsigned char *bufs[]);
int ncmpi_mput_vars_short        (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], short *bufs[]);
int ncmpi_mput_vars_ushort       (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], unsigned short *bufs[]);
int ncmpi_mput_vars_int          (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], int *bufs[]);
int ncmpi_mput_vars_uint         (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], unsigned int *bufs[]);
int ncmpi_mput_vars_long         (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], long *bufs[]);
int ncmpi_mput_vars_float        (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], float *bufs[]);
int ncmpi_mput_vars_double       (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], double *bufs[]);
int ncmpi_mput_vars_longlong     (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], long long *bufs[]);
int ncmpi_mput_vars_ulonglong    (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], unsigned long long *bufs[]);
int ncmpi_mput_vars_text_all     (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], char *bufs[]);
int ncmpi_mput_vars_schar_all    (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], signed char *bufs[]);
int ncmpi_mput_vars_uchar_all    (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], unsigned char *bufs[]);
int ncmpi_mput_vars_short_all    (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], short *bufs[]);
int ncmpi_mput_vars_ushort_all   (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], unsigned short *bufs[]);
int ncmpi_mput_vars_int_all      (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], int *bufs[]);
int ncmpi_mput_vars_uint_all     (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], unsigned int *bufs[]);
int ncmpi_mput_vars_long_all     (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], long *bufs[]);
int ncmpi_mput_vars_float_all    (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], float *bufs[]);
int ncmpi_mput_vars_double_all   (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], double *bufs[]);
int ncmpi_mput_vars_longlong_all (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], long long *bufs[]);
int ncmpi_mput_vars_ulonglong_all(int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], unsigned long long *bufs[]);
int ncmpi_mput_varm              (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], MPI_Offset* const imaps[], void *bufs[], MPI_Offset bufcounts[], MPI_Datatype datatypes[]);
int ncmpi_mput_varm_all          (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], MPI_Offset* const imaps[], void *bufs[], MPI_Offset bufcounts[], MPI_Datatype datatypes[]);
int ncmpi_mput_varm_text         (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], MPI_Offset* const imaps[], char *bufs[]);
int ncmpi_mput_varm_schar        (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], MPI_Offset* const imaps[], signed char *bufs[]);
int ncmpi_mput_varm_uchar        (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], MPI_Offset* const imaps[], unsigned char *bufs[]);
int ncmpi_mput_varm_short        (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], MPI_Offset* const imaps[], short *bufs[]);
int ncmpi_mput_varm_ushort       (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], MPI_Offset* const imaps[], unsigned short *bufs[]);
int ncmpi_mput_varm_int          (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], MPI_Offset* const imaps[], int *bufs[]);
int ncmpi_mput_varm_uint         (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], MPI_Offset* const imaps[], unsigned int *bufs[]);
int ncmpi_mput_varm_long         (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], MPI_Offset* const imaps[], long *bufs[]);
int ncmpi_mput_varm_float        (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], MPI_Offset* const imaps[], float *bufs[]);
int ncmpi_mput_varm_double       (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], MPI_Offset* const imaps[], double *bufs[]);
int ncmpi_mput_varm_longlong     (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], MPI_Offset* const imaps[], long long *bufs[]);
int ncmpi_mput_varm_ulonglong    (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], MPI_Offset* const imaps[], unsigned long long *bufs[]);
int ncmpi_mput_varm_text_all     (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], MPI_Offset* const imaps[], char *bufs[]);
int ncmpi_mput_varm_schar_all    (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], MPI_Offset* const imaps[], signed char *bufs[]);
int ncmpi_mput_varm_uchar_all    (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], MPI_Offset* const imaps[], unsigned char *bufs[]);
int ncmpi_mput_varm_short_all    (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], MPI_Offset* const imaps[], short *bufs[]);
int ncmpi_mput_varm_ushort_all   (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], MPI_Offset* const imaps[], unsigned short *bufs[]);
int ncmpi_mput_varm_int_all      (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], MPI_Offset* const imaps[], int *bufs[]);
int ncmpi_mput_varm_uint_all     (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], MPI_Offset* const imaps[], unsigned int *bufs[]);
int ncmpi_mput_varm_long_all     (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], MPI_Offset* const imaps[], long *bufs[]);
int ncmpi_mput_varm_float_all    (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], MPI_Offset* const imaps[], float *bufs[]);
int ncmpi_mput_varm_double_all   (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], MPI_Offset* const imaps[], double *bufs[]);
int ncmpi_mput_varm_longlong_all (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], MPI_Offset* const imaps[], long long *bufs[]);
int ncmpi_mput_varm_ulonglong_all(int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], MPI_Offset* const imaps[], unsigned long long *bufs[]);
int ncmpi_mget_var               (int ncid, int num, int varids[], void *bufs[], MPI_Offset bufcounts[], MPI_Datatype datatypes[]);
int ncmpi_mget_var_all           (int ncid, int num, int varids[], void *bufs[], MPI_Offset bufcounts[], MPI_Datatype datatypes[]);
int ncmpi_mget_var_text          (int ncid, int num, int varids[], char *bufs[]);
int ncmpi_mget_var_schar         (int ncid, int num, int varids[], signed char *bufs[]);
int ncmpi_mget_var_uchar         (int ncid, int num, int varids[], unsigned char *bufs[]);
int ncmpi_mget_var_short         (int ncid, int num, int varids[], short *bufs[]);
int ncmpi_mget_var_ushort        (int ncid, int num, int varids[], unsigned short *bufs[]);
int ncmpi_mget_var_int           (int ncid, int num, int varids[], int *bufs[]);
int ncmpi_mget_var_uint          (int ncid, int num, int varids[], unsigned int *bufs[]);
int ncmpi_mget_var_long          (int ncid, int num, int varids[], long *bufs[]);
int ncmpi_mget_var_float         (int ncid, int num, int varids[], float *bufs[]);
int ncmpi_mget_var_double        (int ncid, int num, int varids[], double *bufs[]);
int ncmpi_mget_var_longlong      (int ncid, int num, int varids[], long long *bufs[]);
int ncmpi_mget_var_ulonglong     (int ncid, int num, int varids[], unsigned long long *bufs[]);
int ncmpi_mget_var_text_all      (int ncid, int num, int varids[], char *bufs[]);
int ncmpi_mget_var_schar_all     (int ncid, int num, int varids[], signed char *bufs[]);
int ncmpi_mget_var_uchar_all     (int ncid, int num, int varids[], unsigned char *bufs[]);
int ncmpi_mget_var_short_all     (int ncid, int num, int varids[], short *bufs[]);
int ncmpi_mget_var_ushort_all    (int ncid, int num, int varids[], unsigned short *bufs[]);
int ncmpi_mget_var_int_all       (int ncid, int num, int varids[], int *bufs[]);
int ncmpi_mget_var_uint_all      (int ncid, int num, int varids[], unsigned int *bufs[]);
int ncmpi_mget_var_long_all      (int ncid, int num, int varids[], long *bufs[]);
int ncmpi_mget_var_float_all     (int ncid, int num, int varids[], float *bufs[]);
int ncmpi_mget_var_double_all    (int ncid, int num, int varids[], double *bufs[]);
int ncmpi_mget_var_longlong_all  (int ncid, int num, int varids[], long long *bufs[]);
int ncmpi_mget_var_ulonglong_all (int ncid, int num, int varids[], unsigned long long *bufs[]);
int ncmpi_mget_var1              (int ncid, int num, int varids[], MPI_Offset* const starts[], void *bufs[], MPI_Offset bufcounts[], MPI_Datatype datatypes[]);
int ncmpi_mget_var1_all          (int ncid, int num, int varids[], MPI_Offset* const starts[], void *bufs[], MPI_Offset bufcounts[], MPI_Datatype datatypes[]);
int ncmpi_mget_var1_text         (int ncid, int num, int varids[], MPI_Offset* const starts[], char *bufs[]);
int ncmpi_mget_var1_schar        (int ncid, int num, int varids[], MPI_Offset* const starts[], signed char *bufs[]);
int ncmpi_mget_var1_uchar        (int ncid, int num, int varids[], MPI_Offset* const starts[], unsigned char *bufs[]);
int ncmpi_mget_var1_short        (int ncid, int num, int varids[], MPI_Offset* const starts[], short *bufs[]);
int ncmpi_mget_var1_ushort       (int ncid, int num, int varids[], MPI_Offset* const starts[], unsigned short *bufs[]);
int ncmpi_mget_var1_int          (int ncid, int num, int varids[], MPI_Offset* const starts[], int *bufs[]);
int ncmpi_mget_var1_uint         (int ncid, int num, int varids[], MPI_Offset* const starts[], unsigned int *bufs[]);
int ncmpi_mget_var1_long         (int ncid, int num, int varids[], MPI_Offset* const starts[], long *bufs[]);
int ncmpi_mget_var1_float        (int ncid, int num, int varids[], MPI_Offset* const starts[], float *bufs[]);
int ncmpi_mget_var1_double       (int ncid, int num, int varids[], MPI_Offset* const starts[], double *bufs[]);
int ncmpi_mget_var1_longlong     (int ncid, int num, int varids[], MPI_Offset* const starts[], long long *bufs[]);
int ncmpi_mget_var1_ulonglong    (int ncid, int num, int varids[], MPI_Offset* const starts[], unsigned long long *bufs[]);
int ncmpi_mget_var1_text_all     (int ncid, int num, int varids[], MPI_Offset* const starts[], char *bufs[]);
int ncmpi_mget_var1_schar_all    (int ncid, int num, int varids[], MPI_Offset* const starts[], signed char *bufs[]);
int ncmpi_mget_var1_uchar_all    (int ncid, int num, int varids[], MPI_Offset* const starts[], unsigned char *bufs[]);
int ncmpi_mget_var1_short_all    (int ncid, int num, int varids[], MPI_Offset* const starts[], short *bufs[]);
int ncmpi_mget_var1_ushort_all   (int ncid, int num, int varids[], MPI_Offset* const starts[], unsigned short *bufs[]);
int ncmpi_mget_var1_int_all      (int ncid, int num, int varids[], MPI_Offset* const starts[], int *bufs[]);
int ncmpi_mget_var1_uint_all     (int ncid, int num, int varids[], MPI_Offset* const starts[], unsigned int *bufs[]);
int ncmpi_mget_var1_long_all     (int ncid, int num, int varids[], MPI_Offset* const starts[], long *bufs[]);
int ncmpi_mget_var1_float_all    (int ncid, int num, int varids[], MPI_Offset* const starts[], float *bufs[]);
int ncmpi_mget_var1_double_all   (int ncid, int num, int varids[], MPI_Offset* const starts[], double *bufs[]);
int ncmpi_mget_var1_longlong_all (int ncid, int num, int varids[], MPI_Offset* const starts[], long long *bufs[]);
int ncmpi_mget_var1_ulonglong_all(int ncid, int num, int varids[], MPI_Offset* const starts[], unsigned long long *bufs[]);
int ncmpi_mget_vara              (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], void *bufs[], MPI_Offset bufcounts[], MPI_Datatype datatypes[]);
int ncmpi_mget_vara_all          (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], void *bufs[], MPI_Offset bufcounts[], MPI_Datatype datatypes[]);
int ncmpi_mget_vara_text         (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], char *bufs[]);
int ncmpi_mget_vara_schar        (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], signed char *bufs[]);
int ncmpi_mget_vara_uchar        (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], unsigned char *bufs[]);
int ncmpi_mget_vara_short        (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], short *bufs[]);
int ncmpi_mget_vara_ushort       (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], unsigned short *bufs[]);
int ncmpi_mget_vara_int          (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], int *bufs[]);
int ncmpi_mget_vara_uint         (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], unsigned int *bufs[]);
int ncmpi_mget_vara_long         (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], long *bufs[]);
int ncmpi_mget_vara_float        (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], float *bufs[]);
int ncmpi_mget_vara_double       (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], double *bufs[]);
int ncmpi_mget_vara_longlong     (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], long long *bufs[]);
int ncmpi_mget_vara_ulonglong    (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], unsigned long long *bufs[]);
int ncmpi_mget_vara_text_all     (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], char *bufs[]);
int ncmpi_mget_vara_schar_all    (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], signed char *bufs[]);
int ncmpi_mget_vara_uchar_all    (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], unsigned char *bufs[]);
int ncmpi_mget_vara_short_all    (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], short *bufs[]);
int ncmpi_mget_vara_ushort_all   (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], unsigned short *bufs[]);
int ncmpi_mget_vara_int_all      (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], int *bufs[]);
int ncmpi_mget_vara_uint_all     (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], unsigned int *bufs[]);
int ncmpi_mget_vara_long_all     (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], long *bufs[]);
int ncmpi_mget_vara_float_all    (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], float *bufs[]);
int ncmpi_mget_vara_double_all   (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], double *bufs[]);
int ncmpi_mget_vara_longlong_all (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], long long *bufs[]);
int ncmpi_mget_vara_ulonglong_all(int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], unsigned long long *bufs[]);
int ncmpi_mget_vars              (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], void *bufs[], MPI_Offset bufcounts[], MPI_Datatype datatypes[]);
int ncmpi_mget_vars_all          (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], void *bufs[], MPI_Offset bufcounts[], MPI_Datatype datatypes[]);
int ncmpi_mget_vars_text         (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], char *bufs[]);
int ncmpi_mget_vars_schar        (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], signed char *bufs[]);
int ncmpi_mget_vars_uchar        (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], unsigned char *bufs[]);
int ncmpi_mget_vars_short        (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], short *bufs[]);
int ncmpi_mget_vars_ushort       (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], unsigned short *bufs[]);
int ncmpi_mget_vars_int          (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], int *bufs[]);
int ncmpi_mget_vars_uint         (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], unsigned int *bufs[]);
int ncmpi_mget_vars_long         (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], long *bufs[]);
int ncmpi_mget_vars_float        (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], float *bufs[]);
int ncmpi_mget_vars_double       (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], double *bufs[]);
int ncmpi_mget_vars_longlong     (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], long long *bufs[]);
int ncmpi_mget_vars_ulonglong    (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], unsigned long long *bufs[]);
int ncmpi_mget_vars_text_all     (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], char *bufs[]);
int ncmpi_mget_vars_schar_all    (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], signed char *bufs[]);
int ncmpi_mget_vars_uchar_all    (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], unsigned char *bufs[]);
int ncmpi_mget_vars_short_all    (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], short *bufs[]);
int ncmpi_mget_vars_ushort_all   (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], unsigned short *bufs[]);
int ncmpi_mget_vars_int_all      (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], int *bufs[]);
int ncmpi_mget_vars_uint_all     (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], unsigned int *bufs[]);
int ncmpi_mget_vars_long_all     (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], long *bufs[]);
int ncmpi_mget_vars_float_all    (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], float *bufs[]);
int ncmpi_mget_vars_double_all   (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], double *bufs[]);
int ncmpi_mget_vars_longlong_all (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], long long *bufs[]);
int ncmpi_mget_vars_ulonglong_all(int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], unsigned long long *bufs[]);
int ncmpi_mget_varm              (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], MPI_Offset* const imaps[], void *bufs[], MPI_Offset bufcounts[], MPI_Datatype datatypes[]);
int ncmpi_mget_varm_all          (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], MPI_Offset* const imaps[], void *bufs[], MPI_Offset bufcounts[], MPI_Datatype datatypes[]);
int ncmpi_mget_varm_text         (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], MPI_Offset* const imaps[], char *bufs[]);
int ncmpi_mget_varm_schar        (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], MPI_Offset* const imaps[], signed char *bufs[]);
int ncmpi_mget_varm_uchar        (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], MPI_Offset* const imaps[], unsigned char *bufs[]);
int ncmpi_mget_varm_short        (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], MPI_Offset* const imaps[], short *bufs[]);
int ncmpi_mget_varm_ushort       (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], MPI_Offset* const imaps[], unsigned short *bufs[]);
int ncmpi_mget_varm_int          (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], MPI_Offset* const imaps[], int *bufs[]);
int ncmpi_mget_varm_uint         (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], MPI_Offset* const imaps[], unsigned int *bufs[]);
int ncmpi_mget_varm_long         (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], MPI_Offset* const imaps[], long *bufs[]);
int ncmpi_mget_varm_float        (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], MPI_Offset* const imaps[], float *bufs[]);
int ncmpi_mget_varm_double       (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], MPI_Offset* const imaps[], double *bufs[]);
int ncmpi_mget_varm_longlong     (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], MPI_Offset* const imaps[], long long *bufs[]);
int ncmpi_mget_varm_ulonglong    (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], MPI_Offset* const imaps[], unsigned long long *bufs[]);
int ncmpi_mget_varm_text_all     (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], MPI_Offset* const imaps[], char *bufs[]);
int ncmpi_mget_varm_schar_all    (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], MPI_Offset* const imaps[], signed char *bufs[]);
int ncmpi_mget_varm_uchar_all    (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], MPI_Offset* const imaps[], unsigned char *bufs[]);
int ncmpi_mget_varm_short_all    (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], MPI_Offset* const imaps[], short *bufs[]);
int ncmpi_mget_varm_ushort_all   (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], MPI_Offset* const imaps[], unsigned short *bufs[]);
int ncmpi_mget_varm_int_all      (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], MPI_Offset* const imaps[], int *bufs[]);
int ncmpi_mget_varm_uint_all     (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], MPI_Offset* const imaps[], unsigned int *bufs[]);
int ncmpi_mget_varm_long_all     (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], MPI_Offset* const imaps[], long *bufs[]);
int ncmpi_mget_varm_float_all    (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], MPI_Offset* const imaps[], float *bufs[]);
int ncmpi_mget_varm_double_all   (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], MPI_Offset* const imaps[], double *bufs[]);
int ncmpi_mget_varm_longlong_all (int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], MPI_Offset* const imaps[], long long *bufs[]);
int ncmpi_mget_varm_ulonglong_all(int ncid, int num, int varids[], MPI_Offset* const starts[], MPI_Offset* const counts[], MPI_Offset* const strides[], MPI_Offset* const imaps[], unsigned long long *bufs[]);
@end example

@node Summary of Fortran 77 Interface, Summary of Fortran 90 Interface, Summary of C Interface, Top
@appendix Summary of Fortran 77 Interface
@cindex API, Fortran 77 summary
@cindex Fortran 77 API summary

@enumerate
@item @ref{lib_api, Library APIs}
@item @ref{err_api, Error report APIs}
@item @ref{file_api, File APIs}
@item @ref{indep_api, Entering/exiting independent data mode APIs}
@item @ref{wait_api, Nonblocking I/O control APIs}
@item @ref{file_inq_api, File inquiry APIs}
@item @ref{dim_api, Dimension APIs}
@item @ref{attr_inq_api, Attribute inquiry APIs}
@item @ref{attr_api, Attribute put/get APIs}
@item @ref{def_var_api, General variable APIs}
@item @ref{var_api, Blocking put/get entire variable APIs}
@item @ref{var1_api, Blocking put/get a single variable element APIs}
@item @ref{vara_api, Blocking put/get variable subarray APIs}
@item @ref{vars_api, Blocking put/get variable strided subarray APIs}
@item @ref{varm_api, Blocking put/get variable mapped and strided APIs}
@item @ref{i_var_api, Nonblocking iput/iget the entire variable APIs}
@item @ref{i_var1_api, Nonblocking iput/iget a single variable element APIs}
@item @ref{i_vara_api, Nonblocking iput/iget a variable subarray APIs}
@item @ref{i_vars_api, Nonblocking iput/iget a variable strided subarray APIs}
@item @ref{i_varm_api, Nonblocking iput/iget a variable mapped and strided subarray APIs}
@item @ref{b_var_api, Nonblocking buffered put APIs}
@item @ref{vard_api, Blocking put/get an array of values using filetype}
@item @ref{varn_api, Blocking and nonblocking put/get a list of subarrays}
@end enumerate

@anchor{lib_api}
@heading Library APIs
@example
character(LEN=80) FUNCTION nfmpi_inq_libvers()
@end example

@anchor{err_api}
@heading Error report APIs
@example
character(LEN=80) FUNCTION nfmpi_strerror(ncerr)
                  INTEGER, INTENT(IN) :: ncerr

logical           FUNCTION nfmpi_issyserr(ncerr)
                  INTEGER, INTENT(IN) :: ncerr

character(LEN=80) FUNCTION nfmpi_strerrno(ncerr)
                  INTEGER, INTENT(IN) :: ncerr
@end example

@anchor{file_api}
@heading File APIs
@example
INTEGER FUNCTION nfmpi_create(mpi_comm, path, cmode, mpi_info, ncid)
                 INTEGER,                       INTENT(IN)  :: mpi_comm
                 CHARACTER(len=*),              INTENT(IN)  :: path
                 INTEGER,                       INTENT(IN)  :: cmode
                 INTEGER,                       INTENT(IN)  :: mpi_info
                 INTEGER,                       INTENT(OUT) :: ncid

INTEGER FUNCTION nfmpi_open(mpi_comm, path, mode, mpi_info, ncid)
                 INTEGER,                       INTENT(IN)  :: mpi_comm
                 CHARACTER(len=*),              INTENT(IN)  :: path
                 INTEGER,                       INTENT(IN)  :: mode
                 INTEGER,                       INTENT(IN)  :: mpi_info
                 INTEGER,                       INTENT(OUT) :: ncid

INTEGER FUNCTION nfmpi_enddef(ncid)
                 INTEGER,                       INTENT(IN)  :: ncid

INTEGER FUNCTION nfmpi__enddef(ncid, h_minfree, v_align, v_minfree, r_align)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: h_minfree
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: v_align
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: v_minfree
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: r_align

INTEGER FUNCTION nfmpi_redef(ncid)
                 INTEGER,                       INTENT(IN)  :: ncid

INTEGER FUNCTION nfmpi_flush(ncid)
                 INTEGER,                       INTENT(IN)  :: ncid

INTEGER FUNCTION nfmpi_sync(ncid)
                 INTEGER,                       INTENT(IN)  :: ncid

INTEGER FUNCTION nfmpi_sync_numrecs(ncid)
                 INTEGER,                       INTENT(IN)  :: ncid

INTEGER FUNCTION nfmpi_close(ncid)
                 INTEGER,                       INTENT(IN)  :: ncid

INTEGER FUNCTION nfmpi_set_fill(ncid, fillmode, old_mode)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: fillmode
                 INTEGER,                       INTENT(OUT) :: old_mode

INTEGER FUNCTION nfmpi_set_default_format(new_fmt, old_fmt)
                 INTEGER,                       INTENT(IN)  :: new_fmt
                 INTEGER,                       INTENT(OUT) :: old_fmt

INTEGER FUNCTION nfmpi_abort(ncid)
                 INTEGER,                       INTENT(IN)  :: ncid

INTEGER FUNCTION nfmpi_delete(path, mpi_info)
                 CHARACTER(len=*),              INTENT(IN)  :: path
                 INTEGER,                       INTENT(IN)  :: mpi_info
@end example

@anchor{indep_api}
@heading Entering/exiting independent data mode APIs
@example
INTEGER FUNCTION nfmpi_begin_indep_data(ncid)
                 INTEGER,                       INTENT(IN)  :: ncid

INTEGER FUNCTION nfmpi_end_indep_data(ncid)
                 INTEGER,                       INTENT(IN)  :: ncid
@end example

@anchor{wait_api}
@heading Nonblocking I/O control APIs
@example
INTEGER FUNCTION nfmpi_wait(ncid, count, req, status)
                 INTEGER,                       INTENT(IN)   :: ncid
                 INTEGER,                       INTENT(IN)   :: count
                 INTEGER,                       INTENT(INOUT):: req(count)
                 INTEGER,                       INTENT(OUT)  :: status(count)

INTEGER FUNCTION nfmpi_wait_all(ncid, count, req, status)
                 INTEGER,                       INTENT(IN)   :: ncid
                 INTEGER,                       INTENT(IN)   :: count
                 INTEGER,                       INTENT(INOUT):: req(count)
                 INTEGER,                       INTENT(OUT)  :: status(count)

INTEGER FUNCTION nfmpi_cancel(ncid, count, req, status)
                 INTEGER,                       INTENT(IN)   :: ncid
                 INTEGER,                       INTENT(IN)   :: count
                 INTEGER,                       INTENT(INOUT):: req(count)
                 INTEGER,                       INTENT(OUT)  :: status(count)
@end example

@anchor{file_inq_api}
@heading File inquiry APIs
@example
INTEGER FUNCTION nfmpi_inq(ncid, ndims, nvars, ngatts, unlimdimid)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(OUT) :: ndims
                 INTEGER,                       INTENT(OUT) :: nvars
                 INTEGER,                       INTENT(OUT) :: ngatts
                 INTEGER,                       INTENT(OUT) :: unlimdimid

INTEGER FUNCTION nfmpi_inq_ndims(ncid, ndims)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(OUT) :: ndims

INTEGER FUNCTION nfmpi_inq_nvars(ncid, nvars)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(OUT) :: nvars

INTEGER FUNCTION nfmpi_inq_natts(ncid, ngatts)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(OUT) :: ngatts

INTEGER FUNCTION nfmpi_inq_unlimdim(ncid, unlimdimid)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(OUT) :: unlimdimid

INTEGER FUNCTION nfmpi_inq_format(ncid, fmt)
                 INTEGER,                       INTENT(IN)   :: ncid
                 INTEGER,                       INTENT(OUT)  :: fmt

INTEGER FUNCTION nfmpi_inq_file_format(path, fmt)
                 CHARACTER(len=*),              INTENT(IN)  :: path
                 INTEGER,                       INTENT(OUT)  :: fmt

INTEGER FUNCTION nfmpi_inq_default_format(default_fmt)
                 INTEGER,                       INTENT(OUT) :: default_fmt

INTEGER FUNCTION nfmpi_inq_header_size(ncid, size)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(OUT) :: size

INTEGER FUNCTION nfmpi_inq_header_extent(ncid, extent)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(OUT) :: extent

INTEGER FUNCTION nfmpi_inq_files_opened(nfiles, ncids)
                 INTEGER,                       INTENT(OUT) :: nfiles
                 INTEGER,                       INTENT(OUT) :: ncids(*)

INTEGER FUNCTION nfmpi_inq_path(ncid, pathlen, path)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(OUT) :: pathlen
                 CHARACTER(len=*),              INTENT(OUT) :: path

INTEGER FUNCTION nfmpi_inq_num_rec_vars(ncid, nvars)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(OUT) :: nvars

INTEGER FUNCTION nfmpi_inq_num_fix_vars(ncid, nvars)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(OUT) :: nvars

INTEGER FUNCTION nfmpi_inq_recsize(ncid, recsize)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(OUT) :: recsize

INTEGER FUNCTION nfmpi_inq_file_info(ncid, mpi_info)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(OUT) :: mpi_info

INTEGER FUNCTION nfmpi_get_file_info(ncid, mpi_info)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(OUT) :: mpi_info

INTEGER FUNCTION nfmpi_inq_striping(ncid, striping_size, striping_count)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(OUT) :: striping_size
                 INTEGER,                       INTENT(OUT) :: striping_count

INTEGER FUNCTION nfmpi_inq_put_size(ncid, size)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(OUT) :: size

INTEGER FUNCTION nfmpi_inq_get_size(ncid, size)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(OUT) :: size

INTEGER FUNCTION nfmpi_inq_nreqs(ncid, nreqs)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(OUT) :: nreqs

INTEGER FUNCTION nfmpi_inq_malloc_size(size)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(OUT) :: size

INTEGER FUNCTION nfmpi_inq_malloc_max_size(size)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(OUT) :: size

INTEGER FUNCTION nfmpi_inq_malloc_list()
@end example

@anchor{dim_api}
@heading Dimension APIs
@example
INTEGER FUNCTION nfmpi_def_dim(ncid, name, len, dimid)
                 INTEGER,                       INTENT(IN)  :: ncid
                 CHARACTER(len=*),              INTENT(IN)  :: name
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: len
                 INTEGER,                       INTENT(OUT) :: dimid

INTEGER FUNCTION nfmpi_inq_dimid(ncid, name, dimid)
                 INTEGER,                       INTENT(IN)  :: ncid
                 CHARACTER(len=*),              INTENT(IN)  :: name
                 INTEGER,                       INTENT(OUT) :: dimid

INTEGER FUNCTION nfmpi_inq_dim(ncid, dimid, name, len)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: dimid
                 CHARACTER(len=*),              INTENT(OUT) :: name
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(OUT) :: len

INTEGER FUNCTION nfmpi_inq_dimname(ncid, dimid, name)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: dimid
                 CHARACTER(len=*),              INTENT(OUT) :: name

INTEGER FUNCTION nfmpi_inq_dimlen(ncid, dimid, len)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: dimid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(OUT) :: len

INTEGER FUNCTION nfmpi_rename_dim(ncid, dimid, name)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: dimid
                 CHARACTER(len=*),              INTENT(IN)  :: name
@end example

@anchor{attr_inq_api}
@heading Attribute inquiry APIs
@example
INTEGER FUNCTION nfmpi_inq_att(ncid, varid, name, xtype, len)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 CHARACTER(len=*),              INTENT(IN)  :: name
                 INTEGER,                       INTENT(OUT) :: xtype
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(OUT) :: len

INTEGER FUNCTION nfmpi_inq_attid(ncid, varid, name, attid)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 CHARACTER(len=*),              INTENT(IN)  :: name
                 INTEGER,                       INTENT(OUT) :: attid

INTEGER FUNCTION nfmpi_inq_atttype(ncid, varid, name, xtype)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 CHARACTER(len=*),              INTENT(IN)  :: name
                 INTEGER,                       INTENT(OUT) :: xtype

INTEGER FUNCTION nfmpi_inq_attlen(ncid, varid, name, len)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 CHARACTER(len=*),              INTENT(IN)  :: name
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(OUT) :: len

INTEGER FUNCTION nfmpi_inq_attname(ncid, varid, attid, name)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER,                       INTENT(IN)  :: attid
                 CHARACTER(len=*),              INTENT(OUT) :: name

INTEGER FUNCTION nfmpi_copy_att(ncid_in, varid_in, name, ncid_out, varid_out)
                 INTEGER,                       INTENT(IN)  :: ncid_in
                 INTEGER,                       INTENT(IN)  :: varid_in
                 CHARACTER(len=*),              INTENT(IN)  :: name
                 INTEGER,                       INTENT(IN)  :: ncid_out
                 INTEGER,                       INTENT(IN)  :: varid_out

INTEGER FUNCTION nfmpi_rename_att(ncid, varid, curname, newname)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 CHARACTER(len=*),              INTENT(IN)  :: curname
                 CHARACTER(len=*),              INTENT(IN)  :: newname

INTEGER FUNCTION nfmpi_del_att(ncid, varid, name)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 CHARACTER(len=*),              INTENT(IN)  :: name
@end example

@anchor{attr_api}
@heading Attribute put/get APIs
@example
INTEGER FUNCTION nfmpi_put_att_text(ncid, varid, name, len, text)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 CHARACTER(len=*),              INTENT(IN)  :: name
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: len
                 CHARACTER(len=*),              INTENT(IN)  :: text

INTEGER FUNCTION nfmpi_get_att_text(ncid, varid, name, text)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 CHARACTER(len=*),              INTENT(IN)  :: name
                 CHARACTER(len=*),              INTENT(OUT) :: text

INTEGER FUNCTION nfmpi_put_att_int1(ncid, varid, name, xtype, len, i1vals)
                 integer, parameter :: OneByteInt = selected_int_kind(2)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 CHARACTER(len=*),              INTENT(IN)  :: name
                 INTEGER,                       INTENT(IN)  :: xtype
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: len
                 INTEGER(KIND=OneByteInt),      INTENT(IN)  :: i1vals(*)

INTEGER FUNCTION nfmpi_get_att_int1(ncid, varid, name, i1vals)
                 integer, parameter :: OneByteInt = selected_int_kind(2)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 CHARACTER(len=*),              INTENT(IN)  :: name
                 INTEGER(KIND=OneByteInt),      INTENT(OUT) :: i1vals(*)

INTEGER FUNCTION nfmpi_put_att_int2(ncid, varid, name, xtype, len, i2vals)
                 integer, parameter :: TwoByteInt = selected_int_kind(4)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 CHARACTER(len=*),              INTENT(IN)  :: name
                 INTEGER,                       INTENT(IN)  :: xtype
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: len
                 INTEGER(KIND=TwoByteInt),      INTENT(IN)  :: i2vals(*)

INTEGER FUNCTION nfmpi_get_att_int2(ncid, varid, name, i2vals)
                 integer, parameter :: TwoByteInt = selected_int_kind(4)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 CHARACTER(len=*),              INTENT(IN)  :: name
                 INTEGER(KIND=TwoByteInt),      INTENT(OUT) :: i2vals(*)

INTEGER FUNCTION nfmpi_put_att_int(ncid, varid, name, xtype, len, IVALS)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 CHARACTER(len=*),              INTENT(IN)  :: name
                 INTEGER,                       INTENT(IN)  :: xtype
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: len
                 INTEGER,                       INTENT(IN)  :: ivals(*)

INTEGER FUNCTION nfmpi_get_att_int(ncid, varid, name, IVALS)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 CHARACTER(len=*),              INTENT(IN)  :: name
                 INTEGER,                       INTENT(OUT) :: ivals(*)

INTEGER FUNCTION nfmpi_put_att_real(ncid, varid, name, xtype, len, RVALS)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 CHARACTER(len=*),              INTENT(IN)  :: name
                 INTEGER,                       INTENT(IN)  :: xtype
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: len
                 REAL,                          INTENT(IN)  :: rvals(*)

INTEGER FUNCTION nfmpi_get_att_real(ncid, varid, name, rvals)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 CHARACTER(len=*),              INTENT(IN)  :: name
                 REAL,                          INTENT(OUT) :: rvals(*)

INTEGER FUNCTION nfmpi_put_att_double(ncid, varid, name, xtype, len, dvals)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 CHARACTER(len=*),              INTENT(IN)  :: name
                 INTEGER,                       INTENT(IN)  :: xtype
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: len
                 DOUBLE PRECISION,              INTENT(IN)  :: dvals(*)

INTEGER FUNCTION nfmpi_get_att_double(ncid, varid, name, dvals)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 CHARACTER(len=*),              INTENT(IN)  :: name
                 DOUBLE PRECISION,              INTENT(OUT) :: dvals(*)

INTEGER FUNCTION nfmpi_put_att_int8(ncid, varid, name, xtype, len, i8vals)
                 integer, parameter :: EightByteInt = selected_int_kind(18)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 CHARACTER(len=*),              INTENT(IN)  :: name
                 INTEGER,                       INTENT(IN)  :: xtype
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: len
                 INTEGER(KIND=EightByteInt),    INTENT(IN)  :: i8vals(*)

INTEGER FUNCTION nfmpi_get_att_int8(ncid, varid, name, i8vals)
                 integer, parameter :: EightByteInt = selected_int_kind(18)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 CHARACTER(len=*),              INTENT(IN)  :: name
                 INTEGER(KIND=EightByteInt),    INTENT(OUT) :: i8vals(*)
@end example

@anchor{def_var_api}
@heading General variable APIs
@example
INTEGER FUNCTION nfmpi_def_var(ncid, name, datatype, ndims, dimids, varid)
                 INTEGER,                       INTENT(IN)  :: ncid
                 CHARACTER(len=*),              INTENT(IN)  :: name
                 INTEGER,                       INTENT(IN)  :: datatype
                 INTEGER,                       INTENT(IN)  :: ndims
                 INTEGER,                       INTENT(IN)  :: dimids(ndims)
                 INTEGER,                       INTENT(OUT) :: varid

INTEGER FUNCTION nfmpi_inq_var(ncid, varid, name, datatype, ndims, dimids, natts)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 CHARACTER(len=*),              INTENT(OUT) :: name
                 INTEGER,                       INTENT(OUT) :: datatype
                 INTEGER,                       INTENT(OUT) :: ndims
                 INTEGER,                       INTENT(OUT) :: dimids(*)
                 INTEGER,                       INTENT(OUT) :: natts

INTEGER FUNCTION nfmpi_inq_varid(ncid, name, varid)
                 INTEGER,                       INTENT(IN)  :: ncid
                 CHARACTER(len=*),              INTENT(IN)  :: name
                 INTEGER,                       INTENT(OUT) :: varid

INTEGER FUNCTION nfmpi_inq_varname(ncid, varid, name)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 CHARACTER(len=*),              INTENT(OUT) :: name

INTEGER FUNCTION nfmpi_inq_vartype(ncid, varid, xtype)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER,                       INTENT(OUT) :: xtype

INTEGER FUNCTION nfmpi_inq_varndims(ncid, varid, ndims)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER,                       INTENT(OUT) :: ndims

INTEGER FUNCTION nfmpi_inq_vardimid(ncid, varid, dimids)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER,                       INTENT(OUT) :: dimids(*)

INTEGER FUNCTION nfmpi_inq_varnatts(ncid, varid, natts)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER,                       INTENT(OUT) :: natts

INTEGER FUNCTION nfmpi_inq_varoffset(ncid, varid, offset)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(OUT) :: offset

INTEGER FUNCTION nfmpi_rename_var(ncid, varid, name)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 CHARACTER(len=*),              INTENT(IN)  :: name

INTEGER FUNCTION nfmpi_def_var_fill(ncid, varid, no_fill, fill_value)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER,                       INTENT(IN)  :: no_fill
                 <any valid type>,              INTENT(IN)  :: fill_value

INTEGER FUNCTION nfmpi_inq_var_fill(ncid, varid, no_fill, fill_value)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER,                       INTENT(OUT) :: no_fill
                 <any valid type>,              INTENT(OUT) :: fill_value

INTEGER FUNCTION nfmpi_fill_var_rec(ncid, varid, recno)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: recno
@end example

@anchor{var_api}
@heading Blocking put/get entire variable APIs
@example
INTEGER FUNCTION nfmpi_put_var(ncid, varid, buf, bufcount, datatype)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 <any valid type>,              INTENT(IN)  :: buf(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: bufcount
                 INTEGER,                       INTENT(IN)  :: datatype

INTEGER FUNCTION nfmpi_get_var(ncid, varid, buf, bufcount, datatype)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 <any valid type>,              INTENT(OUT) :: buf(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: bufcount
                 INTEGER,                       INTENT(IN)  :: datatype

INTEGER FUNCTION nfmpi_get_var_all (ncid, varid, buf, bufcount, datatype)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 <any valid type>,              INTENT(OUT) :: buf(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: bufcount
                 INTEGER,                       INTENT(IN)  :: datatype

INTEGER FUNCTION nfmpi_put_var_text(ncid, varid, text)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 CHARACTER(len=*),              INTENT(IN)  :: text

INTEGER FUNCTION nfmpi_get_var_text(ncid, varid, text)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 CHARACTER(len=*),              INTENT(OUT) :: text

INTEGER FUNCTION nfmpi_get_var_text_all(ncid, varid, text)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 CHARACTER(len=*),              INTENT(OUT) :: text

INTEGER FUNCTION nfmpi_put_var_int1(ncid, varid, i1vals)
                 integer, parameter :: OneByteInt = selected_int_kind(2)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=OneByteInt),      INTENT(IN)  :: i1vals(*)

INTEGER FUNCTION nfmpi_get_var_int1(ncid, varid, i1vals)
                 integer, parameter :: OneByteInt = selected_int_kind(2)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=OneByteInt),      INTENT(OUT) :: i1vals(*)

INTEGER FUNCTION nfmpi_get_var_int1_all(ncid, varid, i1vals)
                 integer, parameter :: OneByteInt = selected_int_kind(2)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=OneByteInt),      INTENT(OUT) :: i1vals(*)

INTEGER FUNCTION nfmpi_put_var_int2(ncid, varid, i2vals)
                 integer, parameter :: TwoByteInt = selected_int_kind(4)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=TwoByteInt),      INTENT(INOUT) :: i2vals(*)

INTEGER FUNCTION nfmpi_get_var_int2(ncid, varid, i2vals)
                 integer, parameter :: TwoByteInt = selected_int_kind(4)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=TwoByteInt),      INTENT(OUT) :: i2vals(*)

INTEGER FUNCTION nfmpi_get_var_int2_all(ncid, varid, i2vals)
                 integer, parameter :: TwoByteInt = selected_int_kind(4)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=TwoByteInt),      INTENT(OUT) :: i2vals(*)

INTEGER FUNCTION nfmpi_put_var_int(ncid, varid, ivals)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER,                       INTENT(INOUT) :: ivals(*)

INTEGER FUNCTION nfmpi_get_var_int(ncid, varid, ivals)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER,                       INTENT(OUT) :: ivals(*)

INTEGER FUNCTION nfmpi_get_var_int_all(ncid, varid, ivals)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER,                       INTENT(OUT) :: ivals(*)

INTEGER FUNCTION nfmpi_put_var_real(ncid, varid, rvals)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 REAL,                          INTENT(INOUT) :: rvals(*)

INTEGER FUNCTION nfmpi_get_var_real(ncid, varid, rvals)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 REAL,                          INTENT(OUT) :: rvals(*)

INTEGER FUNCTION nfmpi_get_var_real_all(ncid, varid, rvals)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 REAL,                          INTENT(OUT) :: rvals(*)

INTEGER FUNCTION nfmpi_put_var_double(ncid, varid, dvals)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 DOUBLE PRECISION,              INTENT(INOUT) :: dvals(*)

INTEGER FUNCTION nfmpi_get_var_double(ncid, varid, dvals)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 DOUBLE PRECISION,              INTENT(OUT) :: dvals(*)

INTEGER FUNCTION nfmpi_get_var_double_all(ncid, varid, dvals)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 DOUBLE PRECISION,              INTENT(OUT) :: dvals(*)

INTEGER FUNCTION nfmpi_put_var_int8(ncid, varid, i8vals)
                 integer, parameter :: EightByteInt = selected_int_kind(18)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=EightByteInt),    INTENT(INOUT) :: i8vals(*)

INTEGER FUNCTION nfmpi_get_var_int8(ncid, varid, i8vals)
                 integer, parameter :: EightByteInt = selected_int_kind(18)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=EightByteInt),    INTENT(OUT) :: i8vals(*)

INTEGER FUNCTION nfmpi_get_var_int8_all(ncid, varid, i8vals)
                 integer, parameter :: EightByteInt = selected_int_kind(18)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=EightByteInt),    INTENT(OUT) :: i8vals(*)
@end example

@anchor{var1_api}
@heading Blocking put/get a single variable element APIs
@example
INTEGER FUNCTION nfmpi_put_var1(ncid, varid, index, buf, bufcount, datatype)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: index(*)
                 <any valid type>,              INTENT(IN)  :: buf(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: bufcount
                 INTEGER,                       INTENT(IN)  :: datatype

INTEGER FUNCTION nfmpi_put_var1_all(ncid, varid, index, buf, bufcount, datatype)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: index(*)
                 <any valid type>,              INTENT(IN)  :: buf(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: bufcount
                 INTEGER,                       INTENT(IN)  :: datatype

INTEGER FUNCTION nfmpi_get_var1(ncid, varid, index, buf, bufcount, datatype)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: index(*)
                 <any valid type>,              INTENT(OUT) :: buf(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: bufcount
                 INTEGER,                       INTENT(IN)  :: datatype

INTEGER FUNCTION nfmpi_get_var1_all(ncid, varid, index, buf, bufcount, datatype)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: index(*)
                 <any valid type>,              INTENT(OUT) :: buf(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: bufcount
                 INTEGER,                       INTENT(IN)  :: datatype

INTEGER FUNCTION nfmpi_put_var1_text(ncid, varid, index, text)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: index(*)
                 CHARACTER,                     INTENT(IN)  :: text

INTEGER FUNCTION nfmpi_put_var1_text_all(ncid, varid, index, text)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: index(*)
                 CHARACTER,                     INTENT(IN)  :: text

INTEGER FUNCTION nfmpi_get_var1_text(ncid, varid, index, text)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: index(*)
                 CHARACTER,                     INTENT(OUT) :: text

INTEGER FUNCTION nfmpi_get_var1_text_all(ncid, varid, index, text)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: index(*)
                 CHARACTER,                     INTENT(OUT) :: text

INTEGER FUNCTION nfmpi_put_var1_int1(ncid, varid, index, i1val)
                 integer, parameter :: OneByteInt = selected_int_kind(2)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: index(*)
                 INTEGER(KIND=OneByteInt),      INTENT(IN)  :: i1val

INTEGER FUNCTION nfmpi_put_var1_int1_all(ncid, varid, index, i1val)
                 integer, parameter :: OneByteInt = selected_int_kind(2)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: index(*)
                 INTEGER(KIND=OneByteInt),      INTENT(IN)  :: i1val

INTEGER FUNCTION nfmpi_get_var1_int1(ncid, varid, index, i1val)
                 integer, parameter :: OneByteInt = selected_int_kind(2)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: index(*)
                 INTEGER(KIND=OneByteInt),      INTENT(OUT) :: i1val

INTEGER FUNCTION nfmpi_get_var1_int1_all(ncid, varid, index, i1val)
                 integer, parameter :: OneByteInt = selected_int_kind(2)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: index(*)
                 INTEGER(KIND=OneByteInt),      INTENT(OUT) :: i1val

INTEGER FUNCTION nfmpi_put_var1_int2(ncid, varid, index, i2val)
                 integer, parameter :: TwoByteInt = selected_int_kind(4)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: index(*)
                 INTEGER(KIND=TwoByteInt),      INTENT(INOUT) :: i2val

INTEGER FUNCTION nfmpi_put_var1_int2_all(ncid, varid, index, i2val)
                 integer, parameter :: TwoByteInt = selected_int_kind(4)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: index(*)
                 INTEGER(KIND=TwoByteInt),      INTENT(INOUT) :: i2val

INTEGER FUNCTION nfmpi_get_var1_int2(ncid, varid, index, i2val)
                 integer, parameter :: TwoByteInt = selected_int_kind(4)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: index(*)
                 INTEGER(KIND=TwoByteInt),      INTENT(OUT) :: i2val

INTEGER FUNCTION nfmpi_get_var1_int2_all(ncid, varid, index, i2val)
                 integer, parameter :: TwoByteInt = selected_int_kind(4)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: index(*)
                 INTEGER(KIND=TwoByteInt),      INTENT(OUT) :: i2val

INTEGER FUNCTION nfmpi_put_var1_int(ncid, varid, index, ival)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: index(*)
                 INTEGER,                       INTENT(INOUT) :: ival

INTEGER FUNCTION nfmpi_put_var1_int_all(ncid, varid, index, ival)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: index(*)
                 INTEGER,                       INTENT(INOUT) :: ival

INTEGER FUNCTION nfmpi_get_var1_int(ncid, varid, index, ival)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: index(*)
                 INTEGER,                       INTENT(OUT) :: ival

INTEGER FUNCTION nfmpi_get_var1_int_all(ncid, varid, index, ival)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: index(*)
                 INTEGER,                       INTENT(OUT) :: ival

INTEGER FUNCTION nfmpi_put_var1_real(ncid, varid, index, rval)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: index(*)
                 REAL,                          INTENT(INOUT) :: rval

INTEGER FUNCTION nfmpi_put_var1_real_all(ncid, varid, index, rval)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: index(*)
                 REAL,                          INTENT(INOUT) :: rval

INTEGER FUNCTION nfmpi_get_var1_real(ncid, varid, index, rval)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: index(*)
                 REAL,                          INTENT(OUT) :: rval

INTEGER FUNCTION nfmpi_get_var1_real_all(ncid, varid, index, rval)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: index(*)
                 REAL,                          INTENT(OUT) :: rval

INTEGER FUNCTION nfmpi_put_var1_double(ncid, varid, index, dval)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: index(*)
                 DOUBLE PRECISION,              INTENT(INOUT) :: dval

INTEGER FUNCTION nfmpi_put_var1_double_all(ncid, varid, index, dval)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: index(*)
                 DOUBLE PRECISION,              INTENT(INOUT) :: dval

INTEGER FUNCTION nfmpi_get_var1_double(ncid, varid, index, dval)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: index(*)
                 DOUBLE PRECISION,              INTENT(OUT) :: dval

INTEGER FUNCTION nfmpi_get_var1_double_all(ncid, varid, index, dval)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: index(*)
                 DOUBLE PRECISION,              INTENT(OUT) :: dval

INTEGER FUNCTION nfmpi_put_var1_int8(ncid, varid, index, i8val)
                 integer, parameter :: EightByteInt = selected_int_kind(18)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: index(*)
                 INTEGER(KIND=EightByteInt),    INTENT(INOUT) :: i8val

INTEGER FUNCTION nfmpi_put_var1_int8_all(ncid, varid, index, i8val)
                 integer, parameter :: EightByteInt = selected_int_kind(18)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: index(*)
                 INTEGER(KIND=EightByteInt),    INTENT(INOUT) :: i8val

INTEGER FUNCTION nfmpi_get_var1_int8(ncid, varid, index, i8val)
                 integer, parameter :: EightByteInt = selected_int_kind(18)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: index(*)
                 INTEGER(KIND=EightByteInt),    INTENT(OUT) :: i8val

INTEGER FUNCTION nfmpi_get_var1_int8_all(ncid, varid, index, i8val)
                 integer, parameter :: EightByteInt = selected_int_kind(18)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: index(*)
                 INTEGER(KIND=EightByteInt),    INTENT(OUT) :: i8val
@end example

@anchor{vara_api}
@heading Blocking put/get variable subarray APIs
@example
INTEGER FUNCTION nfmpi_put_vara(ncid, varid, start, count, buf, bufcount, datatype)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 <any valid type>,              INTENT(IN)  :: buf(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: bufcount
                 INTEGER,                       INTENT(IN)  :: datatype

INTEGER FUNCTION nfmpi_put_vara_all(ncid, varid, start, count, buf, bufcount, datatype)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 <any valid type>,              INTENT(IN)  :: buf(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: bufcount
                 INTEGER,                       INTENT(IN)  :: datatype

INTEGER FUNCTION nfmpi_get_vara(ncid, varid, start, count, buf, bufcount, datatype)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 <any valid type>,              INTENT(OUT) :: buf(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: bufcount
                 INTEGER,                       INTENT(IN)  :: datatype

INTEGER FUNCTION nfmpi_get_vara_all (ncid, varid, start, count, buf, bufcount, datatype)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 <any valid type>,              INTENT(OUT) :: buf(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: bufcount
                 INTEGER,                       INTENT(IN)  :: datatype

INTEGER FUNCTION nfmpi_put_vara_text(ncid, varid, start, count, text)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 CHARACTER(len=*),              INTENT(IN)  :: text

INTEGER FUNCTION nfmpi_put_vara_text_all(ncid, varid, start, count, text)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 CHARACTER(len=*),              INTENT(IN)  :: text

INTEGER FUNCTION nfmpi_get_vara_text(ncid, varid, start, count, text)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 CHARACTER(len=*),              INTENT(OUT) :: text

INTEGER FUNCTION nfmpi_get_vara_text_all(ncid, varid, start, count, text)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 CHARACTER(len=*),              INTENT(OUT) :: text

INTEGER FUNCTION nfmpi_put_vara_int1(ncid, varid, start, count, i1vals)
                 integer, parameter :: OneByteInt = selected_int_kind(2)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=OneByteInt),      INTENT(IN)  :: i1vals(*)

INTEGER FUNCTION nfmpi_put_vara_int1_all(ncid, varid, start, count, i1vals)
                 integer, parameter :: OneByteInt = selected_int_kind(2)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=OneByteInt),      INTENT(IN)  :: i1vals(*)

INTEGER FUNCTION nfmpi_get_vara_int1(ncid, varid, start, count, i1vals)
                 integer, parameter :: OneByteInt = selected_int_kind(2)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=OneByteInt),      INTENT(OUT) :: i1vals(*)

INTEGER FUNCTION nfmpi_get_vara_int1_all(ncid, varid, start, count, i1vals)
                 integer, parameter :: OneByteInt = selected_int_kind(2)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=OneByteInt),      INTENT(OUT) :: i1vals(*)

INTEGER FUNCTION nfmpi_put_vara_int2(ncid, varid, start, count, i2vals)
                 integer, parameter :: TwoByteInt = selected_int_kind(4)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=TwoByteInt),      INTENT(INOUT) :: i2vals(*)

INTEGER FUNCTION nfmpi_put_vara_int2_all(ncid, varid, start, count, i2vals)
                 integer, parameter :: TwoByteInt = selected_int_kind(4)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=TwoByteInt),      INTENT(INOUT) :: i2vals(*)

INTEGER FUNCTION nfmpi_get_vara_int2(ncid, varid, start, count, i2vals)
                 integer, parameter :: TwoByteInt = selected_int_kind(4)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=TwoByteInt),      INTENT(OUT) :: i2vals(*)

INTEGER FUNCTION nfmpi_get_vara_int2_all(ncid, varid, start, count, i2vals)
                 integer, parameter :: TwoByteInt = selected_int_kind(4)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=TwoByteInt),      INTENT(OUT) :: i2vals(*)

INTEGER FUNCTION nfmpi_put_vara_int(ncid, varid, start, count, ivals)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER,                       INTENT(INOUT) :: ivals(*)

INTEGER FUNCTION nfmpi_put_vara_int_all(ncid, varid, start, count, ivals)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER,                       INTENT(INOUT) :: ivals(*)

INTEGER FUNCTION nfmpi_get_vara_int(ncid, varid, start, count, ivals)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER,                       INTENT(OUT) :: ivals(*)

INTEGER FUNCTION nfmpi_get_vara_int_all(ncid, varid, start, count, ivals)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER,                       INTENT(OUT) :: ivals(*)

INTEGER FUNCTION nfmpi_put_vara_real(ncid, varid, start, count, rvals)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 REAL,                          INTENT(INOUT) :: rvals(*)

INTEGER FUNCTION nfmpi_put_vara_real_all(ncid, varid, start, count, rvals)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 REAL,                          INTENT(INOUT) :: rvals(*)

INTEGER FUNCTION nfmpi_get_vara_real(ncid, varid, start, count, rvals)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 REAL,                          INTENT(OUT) :: rvals(*)

INTEGER FUNCTION nfmpi_get_vara_real_all(ncid, varid, start, count, rvals)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 REAL,                          INTENT(OUT) :: rvals(*)

INTEGER FUNCTION nfmpi_put_vara_double(ncid, varid, start, count, dvals)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 DOUBLE PRECISION,              INTENT(INOUT) :: dvals(*)

INTEGER FUNCTION nfmpi_put_vara_double_all(ncid, varid, start, count, dvals)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 DOUBLE PRECISION,              INTENT(INOUT) :: dvals(*)

INTEGER FUNCTION nfmpi_get_vara_double(ncid, varid, start, count, dvals)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 DOUBLE PRECISION,              INTENT(OUT) :: dvals(*)

INTEGER FUNCTION nfmpi_get_vara_double_all(ncid, varid, start, count, dvals)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 DOUBLE PRECISION,              INTENT(OUT) :: dvals(*)

INTEGER FUNCTION nfmpi_put_vara_int8(ncid, varid, start, count, i8vals)
                 integer, parameter :: EightByteInt = selected_int_kind(18)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=EightByteInt),    INTENT(INOUT) :: i8vals(*)

INTEGER FUNCTION nfmpi_put_vara_int8_all(ncid, varid, start, count, i8vals)
                 integer, parameter :: EightByteInt = selected_int_kind(18)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=EightByteInt),    INTENT(INOUT) :: i8vals(*)

INTEGER FUNCTION nfmpi_get_vara_int8(ncid, varid, start, count, i8vals)
                 integer, parameter :: EightByteInt = selected_int_kind(18)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=EightByteInt),    INTENT(OUT) :: i8vals(*)

INTEGER FUNCTION nfmpi_get_vara_int8_all(ncid, varid, start, count, i8vals)
                 integer, parameter :: EightByteInt = selected_int_kind(18)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=EightByteInt),    INTENT(OUT) :: i8vals(*)
@end example

@anchor{vars_api}
@heading Blocking put/get variable strided subarray APIs
@example
INTEGER FUNCTION nfmpi_put_vars(ncid, varid, start, count, stride, buf, bufcount, datatype)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 <any valid type>,              INTENT(IN)  :: buf(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: bufcount
                 INTEGER,                       INTENT(IN)  :: datatype

INTEGER FUNCTION nfmpi_put_vars_all(ncid, varid, start, count, stride, buf, bufcount, datatype)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 <any valid type>,              INTENT(IN)  :: buf(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: bufcount
                 INTEGER,                       INTENT(IN)  :: datatype

INTEGER FUNCTION nfmpi_get_vars(ncid, varid, start, count, stride, buf, bufcount, datatype)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 <any valid type>,              INTENT(OUT) :: buf(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: bufcount
                 INTEGER,                       INTENT(IN)  :: datatype

INTEGER FUNCTION nfmpi_get_vars_all(ncid, varid, start, count, stride, buf, bufcount, datatype)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 <any valid type>,              INTENT(OUT) :: buf(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: bufcount
                 INTEGER,                       INTENT(IN)  :: datatype

INTEGER FUNCTION nfmpi_put_vars_text(ncid, varid, start, count, stride, text)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 CHARACTER(len=*),              INTENT(IN)  :: text

INTEGER FUNCTION nfmpi_put_vars_text_all(ncid, varid, start, count, stride, text)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 CHARACTER(len=*),              INTENT(IN)  :: text

INTEGER FUNCTION nfmpi_get_vars_text(ncid, varid, start, count, stride, text)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 CHARACTER(len=*),              INTENT(OUT) :: text

INTEGER FUNCTION nfmpi_get_vars_text_all(ncid, varid, start, count, stride, text)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 CHARACTER(len=*),              INTENT(OUT) :: text

INTEGER FUNCTION nfmpi_put_vars_int1(ncid, varid, start, count, stride, i1vals)
                 integer, parameter :: OneByteInt = selected_int_kind(2)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER(KIND=OneByteInt),      INTENT(IN)  :: i1vals(*)

INTEGER FUNCTION nfmpi_put_vars_int1_all(ncid, varid, start, count, stride, i1vals)
                 integer, parameter :: OneByteInt = selected_int_kind(2)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER(KIND=OneByteInt),      INTENT(IN)  :: i1vals(*)

INTEGER FUNCTION nfmpi_get_vars_int1(ncid, varid, start, count, stride, i1vals)
                 integer, parameter :: OneByteInt = selected_int_kind(2)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER(KIND=OneByteInt),      INTENT(OUT) :: i1vals(*)

INTEGER FUNCTION nfmpi_get_vars_int1_all(ncid, varid, start, count, stride, i1vals)
                 integer, parameter :: OneByteInt = selected_int_kind(2)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER(KIND=OneByteInt),      INTENT(OUT) :: i1vals(*)

INTEGER FUNCTION nfmpi_put_vars_int2(ncid, varid, start, count, stride, i2vals)
                 integer, parameter :: TwoByteInt = selected_int_kind(4)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER(KIND=TwoByteInt),      INTENT(INOUT) :: i2vals(*)

INTEGER FUNCTION nfmpi_put_vars_int2_all(ncid, varid, start, count, stride, i2vals)
                 integer, parameter :: TwoByteInt = selected_int_kind(4)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER(KIND=TwoByteInt),      INTENT(INOUT) :: i2vals(*)

INTEGER FUNCTION nfmpi_get_vars_int2(ncid, varid, start, count, stride, i2vals)
                 integer, parameter :: TwoByteInt = selected_int_kind(4)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER(KIND=TwoByteInt),      INTENT(OUT) :: i2vals(*)

INTEGER FUNCTION nfmpi_get_vars_int2_all(ncid, varid, start, count, stride, i2vals)
                 integer, parameter :: TwoByteInt = selected_int_kind(4)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER(KIND=TwoByteInt),      INTENT(OUT) :: i2vals(*)

INTEGER FUNCTION nfmpi_put_vars_int(ncid, varid, start, count, stride, ivals)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER,                       INTENT(INOUT) :: ivals(*)

INTEGER FUNCTION nfmpi_put_vars_int_all(ncid, varid, start, count, stride, ivals)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER,                       INTENT(INOUT) :: ivals(*)

INTEGER FUNCTION nfmpi_get_vars_int(ncid, varid, start, count, stride, ivals)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER,                       INTENT(OUT) :: ivals(*)

INTEGER FUNCTION nfmpi_get_vars_int_all(ncid, varid, start, count, stride, ivals)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER,                       INTENT(OUT) :: ivals(*)

INTEGER FUNCTION nfmpi_put_vars_real(ncid, varid, start, count, stride, rvals)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 REAL,                          INTENT(INOUT) :: rvals(*)

INTEGER FUNCTION nfmpi_put_vars_real_all(ncid, varid, start, count, stride, rvals)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 REAL,                          INTENT(INOUT) :: rvals(*)

INTEGER FUNCTION nfmpi_get_vars_real(ncid, varid, start, count, stride, rvals)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 REAL,                          INTENT(OUT) :: rvals(*)

INTEGER FUNCTION nfmpi_get_vars_real_all(ncid, varid, start, count, stride, rvals)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 REAL,                          INTENT(OUT) :: rvals(*)

INTEGER FUNCTION nfmpi_put_vars_double(ncid, varid, start, count, stride, dvals)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 DOUBLE PRECISION,              INTENT(INOUT) :: dvals(*)

INTEGER FUNCTION nfmpi_put_vars_double_all(ncid, varid, start, count, stride, dvals)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 DOUBLE PRECISION,              INTENT(INOUT) :: dvals(*)

INTEGER FUNCTION nfmpi_get_vars_double(ncid, varid, start, count, stride, dvals)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 DOUBLE PRECISION,              INTENT(OUT) :: dvals(*)

INTEGER FUNCTION nfmpi_get_vars_double_all(ncid, varid, start, count, stride, dvals)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 DOUBLE PRECISION,              INTENT(OUT) :: dvals(*)

INTEGER FUNCTION nfmpi_put_vars_int8(ncid, varid, start, count, stride, i8vals)
                 integer, parameter :: EightByteInt = selected_int_kind(18)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER(KIND=EightByteInt),    INTENT(INOUT) :: i8vals(*)

INTEGER FUNCTION nfmpi_put_vars_int8_all(ncid, varid, start, count, stride, i8vals)
                 integer, parameter :: EightByteInt = selected_int_kind(18)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER(KIND=EightByteInt),    INTENT(INOUT) :: i8vals(*)

INTEGER FUNCTION nfmpi_get_vars_int8(ncid, varid, start, count, stride, i8vals)
                 integer, parameter :: EightByteInt = selected_int_kind(18)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER(KIND=EightByteInt),    INTENT(OUT) :: i8vals(*)

INTEGER FUNCTION nfmpi_get_vars_int8_all(ncid, varid, start, count, stride, i8vals)
                 integer, parameter :: EightByteInt = selected_int_kind(18)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER(KIND=EightByteInt),    INTENT(OUT) :: i8vals(*)
@end example

@anchor{varm_api}
@heading Blocking put/get variable mapped and strided APIs
@example
INTEGER FUNCTION nfmpi_put_varm(ncid, varid, start, count, stride, imap, buf, bufcount, datatype)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: imap(*)
                 <any valid type>,              INTENT(IN)  :: buf(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: bufcount
                 INTEGER,                       INTENT(IN)  :: datatype

INTEGER FUNCTION nfmpi_put_varm_all(ncid, varid, start, count, stride, imap, buf, bufcount, datatype)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: imap(*)
                 <any valid type>,              INTENT(IN)  :: buf(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: bufcount
                 INTEGER,                       INTENT(IN)  :: datatype

INTEGER FUNCTION nfmpi_get_varm(ncid, varid, start, count, stride, imap, buf, bufcount, datatype)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: imap(*)
                 <any valid type>,              INTENT(OUT) :: buf(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: bufcount
                 INTEGER,                       INTENT(IN)  :: datatype

INTEGER FUNCTION nfmpi_get_varm_all(ncid, varid, start, count, stride, imap, buf, bufcount, datatype)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: imap(*)
                 <any valid type>,              INTENT(OUT) :: buf(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: bufcount
                 INTEGER,                       INTENT(IN)  :: datatype

INTEGER FUNCTION nfmpi_put_varm_text(ncid, varid, start, count, stride, imap, text)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: imap(*)
                 CHARACTER(len=*),              INTENT(IN)  :: text

INTEGER FUNCTION nfmpi_put_varm_text_all(ncid, varid, start, count, stride, imap, text)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: imap(*)
                 CHARACTER(len=*),              INTENT(IN)  :: text

INTEGER FUNCTION nfmpi_get_varm_text(ncid, varid, start, count, stride, imap, text)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: imap(*)
                 CHARACTER(len=*),              INTENT(OUT) :: text

INTEGER FUNCTION nfmpi_get_varm_text_all(ncid, varid, start, count, stride, imap, text)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: imap(*)
                 CHARACTER(len=*),              INTENT(OUT) :: text

INTEGER FUNCTION nfmpi_put_varm_int1(ncid, varid, start, count, stride, imap, i1vals)
                 integer, parameter :: OneByteInt = selected_int_kind(2)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: imap(*)
                 INTEGER(KIND=OneByteInt),      INTENT(IN)  :: i1vals(*)

INTEGER FUNCTION nfmpi_put_varm_int1_all(ncid, varid, start, count, stride, imap, i1vals)
                 integer, parameter :: OneByteInt = selected_int_kind(2)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: imap(*)
                 INTEGER(KIND=OneByteInt),      INTENT(IN)  :: i1vals(*)

INTEGER FUNCTION nfmpi_get_varm_int1(ncid, varid, start, count, stride, imap, i1vals)
                 integer, parameter :: OneByteInt = selected_int_kind(2)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: imap(*)
                 INTEGER(KIND=OneByteInt),      INTENT(OUT) :: i1vals(*)

INTEGER FUNCTION nfmpi_get_varm_int1_all(ncid, varid, start, count, stride, imap, i1vals)
                 integer, parameter :: OneByteInt = selected_int_kind(2)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: imap(*)
                 INTEGER(KIND=OneByteInt),      INTENT(OUT) :: i1vals(*)

INTEGER FUNCTION nfmpi_put_varm_int2(ncid, varid, start, count, stride, imap, i2vals)
                 integer, parameter :: TwoByteInt = selected_int_kind(4)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: imap(*)
                 INTEGER(KIND=TwoByteInt),      INTENT(INOUT) :: i2vals(*)

INTEGER FUNCTION nfmpi_put_varm_int2_all(ncid, varid, start, count, stride, imap, i2vals)
                 integer, parameter :: TwoByteInt = selected_int_kind(4)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: imap(*)
                 INTEGER(KIND=TwoByteInt),      INTENT(INOUT) :: i2vals(*)

INTEGER FUNCTION nfmpi_get_varm_int2(ncid, varid, start, count, stride, imap, i2vals)
                 integer, parameter :: TwoByteInt = selected_int_kind(4)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: imap(*)
                 INTEGER(KIND=TwoByteInt),      INTENT(OUT) :: i2vals(*)

INTEGER FUNCTION nfmpi_get_varm_int2_all(ncid, varid, start, count, stride, imap, i2vals)
                 integer, parameter :: TwoByteInt = selected_int_kind(4)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: imap(*)
                 INTEGER(KIND=TwoByteInt),      INTENT(OUT) :: i2vals(*)

INTEGER FUNCTION nfmpi_put_varm_int (ncid, varid, start, count, stride, imap, ivals)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: imap(*)
                 INTEGER,                       INTENT(INOUT) :: ivals(*)

INTEGER FUNCTION nfmpi_put_varm_int_all(ncid, varid, start, count, stride, imap, ivals)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: imap(*)
                 INTEGER,                       INTENT(INOUT) :: ivals(*)

INTEGER FUNCTION nfmpi_get_varm_int (ncid, varid, start, count, stride, imap, ivals)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: imap(*)
                 INTEGER,                       INTENT(OUT) :: ivals(*)

INTEGER FUNCTION nfmpi_get_varm_int_all(ncid, varid, start, count, stride, imap, ivals)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: imap(*)
                 INTEGER,                       INTENT(OUT) :: ivals(*)

INTEGER FUNCTION nfmpi_put_varm_real(ncid, varid, start, count, stride, imap, rvals)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: imap(*)
                 REAL,                          INTENT(INOUT) :: rvals(*)

INTEGER FUNCTION nfmpi_put_varm_real_all(ncid, varid, start, count, stride, imap, rvals)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: imap(*)
                 REAL,                          INTENT(INOUT) :: rvals(*)

INTEGER FUNCTION nfmpi_get_varm_real(ncid, varid, start, count, stride, imap, rvals)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: imap(*)
                 REAL,                          INTENT(OUT) :: rvals(*)

INTEGER FUNCTION nfmpi_get_varm_real_all(ncid, varid, start, count, stride, imap, rvals)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: imap(*)
                 REAL,                          INTENT(OUT) :: rvals(*)

INTEGER FUNCTION nfmpi_put_varm_double(ncid, varid, start, count, stride, imap, dvals)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: imap(*)
                 DOUBLE PRECISION,              INTENT(INOUT) :: dvals(*)

INTEGER FUNCTION nfmpi_put_varm_double_all(ncid, varid, start, count, stride, imap, dvals)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: imap(*)
                 DOUBLE PRECISION,              INTENT(INOUT) :: dvals(*)

INTEGER FUNCTION nfmpi_get_varm_double(ncid, varid, start, count, stride, imap, dvals)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: imap(*)
                 DOUBLE PRECISION,              INTENT(OUT) :: dvals(*)

INTEGER FUNCTION nfmpi_get_varm_double_all(ncid, varid, start, count, stride, imap, dvals)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: imap(*)
                 DOUBLE PRECISION,              INTENT(OUT) :: dvals(*)

INTEGER FUNCTION nfmpi_put_varm_int8(ncid, varid, start, count, stride, imap, i8vals)
                 integer, parameter :: EightByteInt = selected_int_kind(18)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: imap(*)
                 INTEGER(KIND=EightByteInt),    INTENT(INOUT) :: i8vals(*)

INTEGER FUNCTION nfmpi_put_varm_int8_all(ncid, varid, start, count, stride, imap, i8vals)
                 integer, parameter :: EightByteInt = selected_int_kind(18)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: imap(*)
                 INTEGER(KIND=EightByteInt),    INTENT(INOUT) :: i8vals(*)

INTEGER FUNCTION nfmpi_get_varm_int8(ncid, varid, start, count, stride, imap, i8vals)
                 integer, parameter :: EightByteInt = selected_int_kind(18)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: imap(*)
                 INTEGER(KIND=EightByteInt),    INTENT(OUT) :: i8vals(*)

INTEGER FUNCTION nfmpi_get_varm_int8_all(ncid, varid, start, count, stride, imap, i8vals)
                 integer, parameter :: EightByteInt = selected_int_kind(18)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: imap(*)
                 INTEGER(KIND=EightByteInt),    INTENT(OUT) :: i8vals(*)
@end example

@anchor{i_var_api}
@heading Nonblocking iput/iget the entire variable APIs
@example
INTEGER FUNCTION nfmpi_iput_var(ncid, varid, buf, bufcount, datatype, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 <any valid type>,              INTENT(IN)  :: buf(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: bufcount
                 INTEGER,                       INTENT(IN)  :: datatype
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iget_var(ncid, varid, buf, bufcount, datatype, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 <any valid type>,              INTENT(OUT) :: buf(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: bufcount
                 INTEGER,                       INTENT(IN)  :: datatype
                 INTEGER,                       INTENT(OUT) :: req


INTEGER FUNCTION nfmpi_iput_var_text(ncid, varid, text, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 CHARACTER(len=*),              INTENT(IN)  :: text
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iget_var_text(ncid, varid, text, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 CHARACTER(len=*),              INTENT(OUT) :: text
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iput_var_int1(ncid, varid, i1vals, req)
                 integer, parameter :: OneByteInt = selected_int_kind(2)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=OneByteInt),      INTENT(IN)  :: i1vals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iget_var_int1(ncid, varid, i1vals, req)
                 integer, parameter :: OneByteInt = selected_int_kind(2)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=OneByteInt),      INTENT(OUT) :: i1vals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iput_var_int2(ncid, varid, i2vals, req)
                 integer, parameter :: TwoByteInt = selected_int_kind(4)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=TwoByteInt),      INTENT(INOUT) :: i2vals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iget_var_int2(ncid, varid, i2vals, req)
                 integer, parameter :: TwoByteInt = selected_int_kind(4)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=TwoByteInt),      INTENT(OUT) :: i2vals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iput_var_int(ncid, varid, ivals, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER,                       INTENT(INOUT) :: ivals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iget_var_int(ncid, varid, ivals, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER,                       INTENT(OUT) :: ivals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iput_var_real(ncid, varid, rvals, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 REAL,                          INTENT(INOUT) :: rvals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iget_var_real(ncid, varid, rvals, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 REAL,                          INTENT(OUT) :: rvals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iput_var_double(ncid, varid, dvals, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 DOUBLE PRECISION,              INTENT(INOUT) :: dvals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iget_var_double(ncid, varid, dvals, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 DOUBLE PRECISION,              INTENT(OUT) :: dvals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iput_var_int8(ncid, varid, i8vals, req)
                 integer, parameter :: EightByteInt = selected_int_kind(18)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=EightByteInt),    INTENT(INOUT) :: i8vals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iget_var_int8(ncid, varid, i8vals, req)
                 integer, parameter :: EightByteInt = selected_int_kind(18)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=EightByteInt),    INTENT(OUT) :: i8vals(*)
                 INTEGER,                       INTENT(OUT) :: req
@end example

@anchor{i_var1_api}
@heading Nonblocking iput/iget a single variable element APIs
@example
INTEGER FUNCTION nfmpi_iput_var1(ncid, varid, index, buf, bufcount, datatype, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: index(*)
                 <any valid type>,              INTENT(IN)  :: buf(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: bufcount
                 INTEGER,                       INTENT(IN)  :: datatype
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iget_var1(ncid, varid, index, buf, bufcount, datatype, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: index(*)
                 <any valid type>,              INTENT(OUT) :: buf(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: bufcount
                 INTEGER,                       INTENT(IN)  :: datatype
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iput_var1_text(ncid, varid, index, text, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: index(*)
                 CHARACTER,                     INTENT(IN)  :: text
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iget_var1_text(ncid, varid, index, text, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: index(*)
                 CHARACTER,                     INTENT(OUT) :: text
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iput_var1_int1(ncid, varid, index, i1val, req)
                 integer, parameter :: OneByteInt = selected_int_kind(2)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: index(*)
                 INTEGER(KIND=OneByteInt),      INTENT(IN)  :: i1val
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iget_var1_int1(ncid, varid, index, i1val, req)
                 integer, parameter :: OneByteInt = selected_int_kind(2)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: index(*)
                 INTEGER(KIND=OneByteInt),      INTENT(OUT) :: i1val
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iput_var1_int2(ncid, varid, index, i2val, req)
                 integer, parameter :: TwoByteInt = selected_int_kind(4)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: index(*)
                 INTEGER(KIND=TwoByteInt),      INTENT(INOUT) :: i2val
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iget_var1_int2(ncid, varid, index, i2val, req)
                 integer, parameter :: TwoByteInt = selected_int_kind(4)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: index(*)
                 INTEGER(KIND=TwoByteInt),      INTENT(OUT) :: i2val
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iput_var1_int(ncid, varid, index, ival, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: index(*)
                 INTEGER,                       INTENT(INOUT) :: ival
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iget_var1_int(ncid, varid, index, ival, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: index(*)
                 INTEGER,                       INTENT(OUT) :: ival
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iput_var1_real(ncid, varid, index, rval, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: index(*)
                 REAL,                          INTENT(INOUT) :: rval
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iget_var1_real(ncid, varid, index, rval, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: index(*)
                 REAL,                          INTENT(OUT) :: rval
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iput_var1_double(ncid, varid, index, dval, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: index(*)
                 DOUBLE PRECISION,              INTENT(INOUT) :: dval
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iget_var1_double(ncid, varid, index, dval, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: index(*)
                 DOUBLE PRECISION,              INTENT(OUT) :: dval
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iput_var1_int8(ncid, varid, index, i8val, req)
                 integer, parameter :: EightByteInt = selected_int_kind(18)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: index(*)
                 INTEGER(KIND=EightByteInt),    INTENT(INOUT) :: i8val
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iget_var1_int8(ncid, varid, index, i8val, req)
                 integer, parameter :: EightByteInt = selected_int_kind(18)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: index(*)
                 INTEGER(KIND=EightByteInt),    INTENT(OUT) :: i8val
                 INTEGER,                       INTENT(OUT) :: req
@end example

@anchor{i_vara_api}
@heading Nonblocking iput/iget a variable subarray APIs
@example
INTEGER FUNCTION nfmpi_iput_vara(ncid, varid, start, count, buf, bufcount, datatype, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 <any valid type>,              INTENT(IN)  :: buf(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: bufcount
                 INTEGER,                       INTENT(IN)  :: datatype
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iget_vara(ncid, varid, start, count, buf, bufcount, datatype, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 <any valid type>,              INTENT(OUT) :: buf(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: bufcount
                 INTEGER,                       INTENT(IN)  :: datatype
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iput_vara_text(ncid, varid, start, count, text, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 CHARACTER(len=*),              INTENT(IN)  :: text
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iget_vara_text(ncid, varid, start, count, text, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 CHARACTER(len=*),              INTENT(OUT) :: text
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iput_vara_int1(ncid, varid, start, count, i1vals, req)
                 integer, parameter :: OneByteInt = selected_int_kind(2)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=OneByteInt),      INTENT(IN)  :: i1vals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iget_vara_int1(ncid, varid, start, count, i1vals, req)
                 integer, parameter :: OneByteInt = selected_int_kind(2)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=OneByteInt),      INTENT(OUT) :: i1vals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iput_vara_int2(ncid, varid, start, count, i2vals, req)
                 integer, parameter :: TwoByteInt = selected_int_kind(4)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=TwoByteInt),      INTENT(INOUT) :: i2vals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iget_vara_int2(ncid, varid, start, count, i2vals, req)
                 integer, parameter :: TwoByteInt = selected_int_kind(4)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=TwoByteInt),      INTENT(OUT) :: i2vals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iput_vara_int(ncid, varid, start, count, ivals, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER,                       INTENT(INOUT) :: ivals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iget_vara_int(ncid, varid, start, count, ivals, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER,                       INTENT(OUT) :: ivals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iput_vara_real(ncid, varid, start, count, rvals, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 REAL,                          INTENT(INOUT) :: rvals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iget_vara_real(ncid, varid, start, count, rvals, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 REAL,                          INTENT(OUT) :: rvals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iput_vara_double(ncid, varid, start, count, dvals, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 DOUBLE PRECISION,              INTENT(INOUT) :: dvals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iget_vara_double(ncid, varid, start, count, dvals, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 DOUBLE PRECISION,              INTENT(OUT) :: dvals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iput_vara_int8(ncid, varid, start, count, i8vals, req)
                 integer, parameter :: EightByteInt = selected_int_kind(18)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=EightByteInt),    INTENT(INOUT) :: i8vals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iget_vara_int8(ncid, varid, start, count, i8vals, req)
                 integer, parameter :: EightByteInt = selected_int_kind(18)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=EightByteInt),    INTENT(OUT) :: i8vals(*)
                 INTEGER,                       INTENT(OUT) :: req
@end example

@anchor{i_vars_api}
@heading Nonblocking iput/iget a variable strided subarray APIs
@example
INTEGER FUNCTION nfmpi_iput_vars(ncid, varid, start, count, stride, buf, bufcount, datatype, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 <any valid type>,              INTENT(IN)  :: buf(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: bufcount
                 INTEGER,                       INTENT(IN)  :: datatype
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iget_vars(ncid, varid, start, count, stride, buf, bufcount, datatype, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 <any valid type>,              INTENT(OUT) :: buf(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: bufcount
                 INTEGER,                       INTENT(IN)  :: datatype
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iput_vars_text(ncid, varid, start, count, stride, text, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 CHARACTER(len=*),              INTENT(IN)  :: text
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iget_vars_text(ncid, varid, start, count, stride, text, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 CHARACTER(len=*),              INTENT(OUT) :: text
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iput_vars_int1(ncid, varid, start, count, stride, i1vals, req)
                 integer, parameter :: OneByteInt = selected_int_kind(2)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER(KIND=OneByteInt),      INTENT(IN)  :: i1vals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iget_vars_int1(ncid, varid, start, count, stride, i1vals, req)
                 integer, parameter :: OneByteInt = selected_int_kind(2)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER(KIND=OneByteInt),      INTENT(OUT) :: i1vals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iput_vars_int2(ncid, varid, start, count, stride, i2vals, req)
                 integer, parameter :: TwoByteInt = selected_int_kind(4)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER(KIND=TwoByteInt),      INTENT(INOUT) :: i2vals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iget_vars_int2(ncid, varid, start, count, stride, i2vals, req)
                 integer, parameter :: TwoByteInt = selected_int_kind(4)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER(KIND=TwoByteInt),      INTENT(OUT) :: i2vals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iput_vars_int(ncid, varid, start, count, stride, ivals, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER,                       INTENT(INOUT) :: ivals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iget_vars_int(ncid, varid, start, count, stride, ivals, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER,                       INTENT(OUT) :: ivals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iput_vars_real(ncid, varid, start, count, stride, rvals, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 REAL,                          INTENT(INOUT) :: rvals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iget_vars_real(ncid, varid, start, count, stride, rvals, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 REAL,                          INTENT(OUT) :: rvals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iput_vars_double(ncid, varid, start, count, stride, dvals, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 DOUBLE PRECISION,              INTENT(INOUT) :: dvals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iget_vars_double(ncid, varid, start, count, stride, dvals, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 DOUBLE PRECISION,              INTENT(OUT) :: dvals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iput_vars_int8(ncid, varid, start, count, stride, i8vals, req)
                 integer, parameter :: EightByteInt = selected_int_kind(18)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER(KIND=EightByteInt),    INTENT(INOUT) :: i8vals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iget_vars_int8(ncid, varid, start, count, stride, i8vals, req)
                 integer, parameter :: EightByteInt = selected_int_kind(18)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER(KIND=EightByteInt),    INTENT(OUT) :: i8vals(*)
                 INTEGER,                       INTENT(OUT) :: req
@end example

@anchor{i_varm_api}
@heading Nonblocking iput/iget a variable mapped and stride APIs
@example
INTEGER FUNCTION nfmpi_iput_varm(ncid, varid, start, count, stride, imap, buf, bufcount, datatype, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: imap(*)
                 <any valid type>,              INTENT(IN)  :: buf(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: bufcount
                 INTEGER,                       INTENT(IN)  :: datatype
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iget_varm(ncid, varid, start, count, stride, imap, buf, bufcount, datatype, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: imap(*)
                 <any valid type>,              INTENT(OUT) :: buf(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: bufcount
                 INTEGER,                       INTENT(IN)  :: datatype
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iput_varm_text(ncid, varid, start, count, stride, imap, text, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: imap(*)
                 CHARACTER(len=*),              INTENT(IN)  :: text
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iget_varm_text(ncid, varid, start, count, stride, imap, text, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: imap(*)
                 CHARACTER(len=*),              INTENT(OUT) :: text
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iput_varm_int1(ncid, varid, start, count, stride, imap, i1vals, req)
                 integer, parameter :: OneByteInt = selected_int_kind(2)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: imap(*)
                 INTEGER(KIND=OneByteInt),      INTENT(IN)  :: i1vals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iget_varm_int1(ncid, varid, start, count, stride, imap, i1vals, req)
                 integer, parameter :: OneByteInt = selected_int_kind(2)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: imap(*)
                 INTEGER(KIND=OneByteInt),      INTENT(OUT) :: i1vals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iput_varm_int2(ncid, varid, start, count, stride, imap, i2vals, req)
                 integer, parameter :: TwoByteInt = selected_int_kind(4)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: imap(*)
                 INTEGER(KIND=TwoByteInt),      INTENT(INOUT) :: i2vals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iget_varm_int2(ncid, varid, start, count, stride, imap, i2vals, req)
                 integer, parameter :: TwoByteInt = selected_int_kind(4)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: imap(*)
                 INTEGER(KIND=TwoByteInt),      INTENT(OUT) :: i2vals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iput_varm_int (ncid, varid, start, count, stride, imap, ivals, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: imap(*)
                 INTEGER,                       INTENT(INOUT) :: ivals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iget_varm_int (ncid, varid, start, count, stride, imap, ivals, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: imap(*)
                 INTEGER,                       INTENT(OUT) :: ivals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iput_varm_real(ncid, varid, start, count, stride, imap, rvals, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: imap(*)
                 REAL,                          INTENT(INOUT) :: rvals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iget_varm_real(ncid, varid, start, count, stride, imap, rvals, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: imap(*)
                 REAL,                          INTENT(OUT) :: rvals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iput_varm_double(ncid, varid, start, count, stride, imap, dvals, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: imap(*)
                 DOUBLE PRECISION,              INTENT(INOUT) :: dvals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iget_varm_double(ncid, varid, start, count, stride, imap, dvals, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: imap(*)
                 DOUBLE PRECISION,              INTENT(OUT) :: dvals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iput_varm_int8(ncid, varid, start, count, stride, imap, i8vals, req)
                 integer, parameter :: EightByteInt = selected_int_kind(18)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: imap(*)
                 INTEGER(KIND=EightByteInt),    INTENT(INOUT) :: i8vals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iget_varm_int8(ncid, varid, start, count, stride, imap, i8vals, req)
                 integer, parameter :: EightByteInt = selected_int_kind(18)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: imap(*)
                 INTEGER(KIND=EightByteInt),    INTENT(OUT) :: i8vals(*)
                 INTEGER,                       INTENT(OUT) :: req
@end example

@anchor{b_var_api}
@heading Nonblocking buffered put APIs
@example
INTEGER FUNCTION nfmpi_bput_var(ncid, varid, buf, bufcount, datatype, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 <any valid type>,              INTENT(IN)  :: buf(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: bufcount
                 INTEGER,                       INTENT(IN)  :: datatype
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_bget_var(ncid, varid, buf, bufcount, datatype, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 <any valid type>,              INTENT(OUT) :: buf(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: bufcount
                 INTEGER,                       INTENT(IN)  :: datatype
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_bput_var_text(ncid, varid, text, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 CHARACTER(len=*),              INTENT(IN)  :: text(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_bput_var_int1(ncid, varid, i1vals, req)
                 integer, parameter :: OneByteInt = selected_int_kind(2)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=OneByteInt),      INTENT(IN)  :: i1vals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_bput_var_int2(ncid, varid, i2vals, req)
                 integer, parameter :: TwoByteInt = selected_int_kind(4)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=TwoByteInt),      INTENT(IN)  :: i2vals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_bput_var_int(ncid, varid, ivals, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER,                       INTENT(IN)  :: ivals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_bput_var_real(ncid, varid, rvals, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 REAL,                          INTENT(IN)  :: rvals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_bput_var_double(ncid, varid, dvals, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 DOUBLE PRECISION,              INTENT(IN)  :: dvals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_bput_var_int8(ncid, varid, i8vals, req)
                 integer, parameter :: EightByteInt = selected_int_kind(18)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=EightByteInt),    INTENT(IN)  :: i8vals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_bput_var1(ncid, varid, start, buf, bufcount, datatype, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 <any valid type>,              INTENT(IN)  :: buf(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: bufcount
                 INTEGER,                       INTENT(IN)  :: datatype
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_bget_var1(ncid, varid, start, buf, bufcount, datatype, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 <any valid type>,              INTENT(OUT) :: buf(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: bufcount
                 INTEGER,                       INTENT(IN)  :: datatype
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_bput_var1_text(ncid, varid, index, text, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: index(*)
                 CHARACTER,                     INTENT(IN)  :: text
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_bput_var1_int1(ncid, varid, index, i1val, req)
                 integer, parameter :: OneByteInt = selected_int_kind(2)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: index(*)
                 INTEGER(KIND=OneByteInt),      INTENT(IN)  :: i1val
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_bput_var1_int2(ncid, varid, index, i2val, req)
                 integer, parameter :: TwoByteInt = selected_int_kind(4)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: index(*)
                 INTEGER(KIND=TwoByteInt),      INTENT(IN)  :: i2val
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_bput_var1_int(ncid, varid, index, ival, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: index(*)
                 INTEGER,                       INTENT(IN)  :: ival
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_bput_var1_real(ncid, varid, index, rval, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: index(*)
                 REAL,                          INTENT(IN)  :: rval
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_bput_var1_double(ncid, varid, index, dval, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: index(*)
                 DOUBLE PRECISION,              INTENT(IN)  :: dval
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_bput_var1_int8(ncid, varid, index, i8val, req)
                 integer, parameter :: EightByteInt = selected_int_kind(18)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: index(*)
                 INTEGER(KIND=EightByteInt),    INTENT(IN)  :: i8val
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_bput_vara(ncid, varid, start, count, buf, bufcount, datatype, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 <any valid type>,              INTENT(IN)  :: buf(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: bufcount
                 INTEGER,                       INTENT(IN)  :: datatype
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_bget_vara(ncid, varid, start, count, buf, bufcount, datatype, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 <any valid type>,              INTENT(OUT) :: buf(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: bufcount
                 INTEGER,                       INTENT(IN)  :: datatype
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_bput_vara_text(ncid, varid, start, count, text, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 CHARACTER(len=*),              INTENT(IN)  :: text(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_bput_vara_int1(ncid, varid, start, count, i1vals, req)
                 integer, parameter :: OneByteInt = selected_int_kind(2)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=OneByteInt),      INTENT(IN)  :: i1vals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_bput_vara_int2(ncid, varid, start, count, i2vals, req)
                 integer, parameter :: TwoByteInt = selected_int_kind(4)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=TwoByteInt),      INTENT(IN)  :: i2vals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_bput_vara_int(ncid, varid, start, count, ivals, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER,                       INTENT(IN)  :: ivals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_bput_vara_real(ncid, varid, start, count, rvals, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 REAL,                          INTENT(IN)  :: rvals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_bput_vara_double(ncid, varid, start, count, dvals, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 DOUBLE PRECISION,              INTENT(IN)  :: dvals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_bput_vara_int8(ncid, varid, start, count, i8vals, req)
                 integer, parameter :: EightByteInt = selected_int_kind(18)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=EightByteInt),    INTENT(IN)  :: i8vals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_bput_vars(ncid, varid, start, count, stride, imap, buf, bufcount, datatype, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 <any valid type>,              INTENT(IN)  :: buf(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: bufcount
                 INTEGER,                       INTENT(IN)  :: datatype
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_bget_vars(ncid, varid, start, count, stride, imap, buf, bufcount, datatype, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 <any valid type>,              INTENT(OUT) :: buf(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: bufcount
                 INTEGER,                       INTENT(IN)  :: datatype
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_bput_vars_text(ncid, varid, start, count, stride, text, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 CHARACTER(len=*),              INTENT(IN)  :: text
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_bput_vars_int1(ncid, varid, start, count, stride, i1vals, req)
                 integer, parameter :: OneByteInt = selected_int_kind(2)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER(KIND=OneByteInt),      INTENT(IN)  :: i1vals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_bput_vars_int2(ncid, varid, start, count, stride, i2vals, req)
                 integer, parameter :: TwoByteInt = selected_int_kind(4)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER(KIND=TwoByteInt),      INTENT(IN)  :: i2vals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_bput_vars_int(ncid, varid, start, count, stride, ivals, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER,                       INTENT(IN)  :: ivals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_bput_vars_real(ncid, varid, start, count, stride, rvals, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 REAL,                          INTENT(IN)  :: rvals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_bput_vars_double(ncid, varid, start, count, stride, dvals, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 DOUBLE PRECISION,              INTENT(IN)  :: dvals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_bput_vars_int8(ncid, varid, start, count, stride, i8vals, req)
                 integer, parameter :: EightByteInt = selected_int_kind(18)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER(KIND=EightByteInt),    INTENT(IN)  :: i8vals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_bput_varm(ncid, varid, start, count, stride, imap, buf, bufcount, datatype, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: imap(*)
                 <any valid type>,              INTENT(IN)  :: buf(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: bufcount
                 INTEGER,                       INTENT(IN)  :: datatype
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_bget_varm(ncid, varid, start, count, stride, imap, buf, bufcount, datatype, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: imap(*)
                 <any valid type>,              INTENT(OUT) :: buf(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: bufcount
                 INTEGER,                       INTENT(IN)  :: datatype
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_bput_varm_text(ncid, varid, start, count, stride, imap, text, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: imap(*)
                 CHARACTER(len=*),              INTENT(IN)  :: text
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_bput_varm_int1(ncid, varid, start, count, stride, imap, i1vals, req)
                 integer, parameter :: OneByteInt = selected_int_kind(2)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: imap(*)
                 INTEGER(KIND=OneByteInt),      INTENT(IN)  :: i1vals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_bput_varm_int2(ncid, varid, start, count, stride, imap, i2vals, req)
                 integer, parameter :: TwoByteInt = selected_int_kind(4)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: imap(*)
                 INTEGER(KIND=TwoByteInt),      INTENT(IN)  :: i2vals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_bput_varm_int (ncid, varid, start, count, stride, imap, ivals, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: imap(*)
                 INTEGER,                       INTENT(IN)  :: ivals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_bput_varm_real(ncid, varid, start, count, stride, imap, rvals, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: imap(*)
                 REAL,                          INTENT(IN)  :: rvals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_bput_varm_double(ncid, varid, start, count, stride, imap, dvals, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: imap(*)
                 DOUBLE PRECISION,              INTENT(IN)  :: dvals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_bput_varm_int8(ncid, varid, start, count, stride, imap, i8vals, req)
                 integer, parameter :: EightByteInt = selected_int_kind(18)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: start(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: count(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: stride(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: imap(*)
                 INTEGER(KIND=EightByteInt),    INTENT(IN)  :: i8vals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_buffer_attach(ncid, bufsize)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: bufsize

INTEGER FUNCTION nfmpi_buffer_detach(ncid)
                 INTEGER,                       INTENT(IN)  :: ncid

INTEGER FUNCTION nfmpi_inq_buffer_usage(ncid, usage)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(OUT) :: usage

INTEGER FUNCTION nfmpi_inq_buffer_size(ncid, buf_size)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(OUT) :: buf_size
@end example

@anchor{vard_api}
@heading Blocking put/get an array of values using filetype
@example
INTEGER FUNCTION nfmpi_put_vard(ncid, varid, filetype, buf, bufcount, buftype)
                 INTEGER,                       INTENT(IN) :: ncid
                 INTEGER,                       INTENT(IN) :: varid
                 INTEGER,                       INTENT(IN) :: filetype
                 <any valid type>,              INTENT(IN) :: buf
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN) :: bufcount
                 INTEGER,                       INTENT(IN) :: buftype
                 INTEGER                                   :: nfmpi_put_vard

INTEGER FUNCTION nfmpi_put_vard_all(ncid, varid, filetype, buf, bufcount, buftype)
                 INTEGER,                       INTENT(IN) :: ncid
                 INTEGER,                       INTENT(IN) :: varid
                 INTEGER,                       INTENT(IN) :: filetype
                 <any valid type>,              INTENT(IN) :: buf
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN) :: bufcount
                 INTEGER,                       INTENT(IN) :: buftype
                 INTEGER                                   :: nfmpi_put_vard_all

INTEGER FUNCTION nfmpi_get_vard(ncid, varid, filetype, buf, bufcount, buftype)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER,                       INTENT(IN)  :: filetype
                 <any valid type>,              INTENT(OUT) :: buf
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: bufcount
                 INTEGER,                       INTENT(IN)  :: buftype
                 INTEGER                                    :: nfmpi_get_vard

INTEGER FUNCTION nfmpi_get_vard_all(ncid, varid, filetype, buf, bufcount, buftype)
                 INTEGER,                       INTENT(in)  :: ncid
                 INTEGER,                       INTENT(in)  :: varid
                 INTEGER,                       INTENT(in)  :: filetype
                 <any valid type>,              INTENT(OUT) :: buf
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: bufcount
                 INTEGER,                       INTENT(in)  :: buftype
                 INTEGER                                    :: nfmpi_get_vard_all
@end example

@anchor{varn_api}
@heading Blocking and nonblocking put/get a list of subarrays
@example
INTEGER FUNCTION nfmpi_get_varn(ncid, varid, num, starts, counts, buf, bufcount, buftype)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER,                       INTENT(IN)  :: num
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: starts(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: counts(*)
                 <any valid type>,              INTENT(OUT) :: buf(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: bufcount
                 INTEGER,                       INTENT(IN)  :: buftype

INTEGER FUNCTION nfmpi_get_varn_all(ncid, varid, num, starts, counts, buf, bufcount, buftype)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER,                       INTENT(IN)  :: num
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: starts(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: counts(*)
                 <any valid type>,              INTENT(OUT) :: buf(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: bufcount
                 INTEGER,                       INTENT(IN)  :: buftype

INTEGER FUNCTION nfmpi_put_varn(ncid, varid, num, starts, counts, buf, bufcount, buftype)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER,                       INTENT(IN)  :: num
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: starts(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: counts(*)
                 <any valid type>,              INTENT(IN)  :: buf(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: bufcount
                 INTEGER,                       INTENT(IN)  :: buftype

INTEGER FUNCTION nfmpi_put_varn_all(ncid, varid, num, starts, counts, buf, bufcount, buftype)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER,                       INTENT(IN)  :: num
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: starts(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: counts(*)
                 <any valid type>,              INTENT(IN)  :: buf(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: bufcount
                 INTEGER,                       INTENT(IN)  :: buftype


INTEGER FUNCTION nfmpi_get_varn_text(ncid, varid, num, starts, counts, text)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER,                       INTENT(IN)  :: num
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: starts(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: counts(*)
                 CHARACTER(len=*),              INTENT(OUT) :: text

INTEGER FUNCTION nfmpi_get_varn_int1(ncid, varid, num, starts, counts, i1vals)
                 integer, parameter :: OneByteInt = selected_int_kind(2)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER,                       INTENT(IN)  :: num
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: starts(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: counts(*)
                 INTEGER(KIND=OneByteInt),      INTENT(OUT) :: i1vals(*)

INTEGER FUNCTION nfmpi_get_varn_int2(ncid, varid, num, starts, counts, i2vals)
                 integer, parameter :: TwoByteInt = selected_int_kind(4)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER,                       INTENT(IN)  :: num
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: starts(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: counts(*)
                 INTEGER(KIND=TwoByteInt),      INTENT(OUT) :: i2vals(*)

INTEGER FUNCTION nfmpi_get_varn_int(ncid, varid, num, starts, counts, ivals)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER,                       INTENT(IN)  :: num
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: starts(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: counts(*)
                 INTEGER,                       INTENT(OUT) :: ivals(*)

INTEGER FUNCTION nfmpi_get_varn_real(ncid, varid, num, starts, counts, rvals)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER,                       INTENT(IN)  :: num
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: starts(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: counts(*)
                 REAL,                          INTENT(OUT) :: rvals(*)

INTEGER FUNCTION nfmpi_get_varn_double(ncid, varid, num, starts, counts, dvals)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER,                       INTENT(IN)  :: num
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: starts(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: counts(*)
                 DOUBLE PRECISION,              INTENT(OUT) :: dvals(*)

INTEGER FUNCTION nfmpi_get_varn_int8(ncid, varid, num, starts, counts, i8vals)
                 integer, parameter :: EightByteInt = selected_int_kind(18)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER,                       INTENT(IN)  :: num
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: starts(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: counts(*)
                 INTEGER(KIND=EightByteInt),    INTENT(OUT) :: i8vals(*)

INTEGER FUNCTION nfmpi_get_varn_text_all(ncid, varid, num, starts, counts, text)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER,                       INTENT(IN)  :: num
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: starts(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: counts(*)
                 CHARACTER(len=*),              INTENT(OUT) :: text

INTEGER FUNCTION nfmpi_get_varn_int1_all(ncid, varid, num, starts, counts, i1vals)
                 integer, parameter :: OneByteInt = selected_int_kind(2)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER,                       INTENT(IN)  :: num
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: starts(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: counts(*)
                 INTEGER(KIND=OneByteInt),      INTENT(OUT) :: i1vals(*)

INTEGER FUNCTION nfmpi_get_varn_int2_all(ncid, varid, num, starts, counts, i2vals)
                 integer, parameter :: TwoByteInt = selected_int_kind(4)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER,                       INTENT(IN)  :: num
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: starts(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: counts(*)
                 INTEGER(KIND=TwoByteInt),      INTENT(OUT) :: i2vals(*)

INTEGER FUNCTION nfmpi_get_varn_int_all(ncid, varid, num, starts, counts, ivals)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER,                       INTENT(IN)  :: num
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: starts(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: counts(*)
                 INTEGER,                       INTENT(OUT) :: ivals(*)

INTEGER FUNCTION nfmpi_get_varn_real_all(ncid, varid, num, starts, counts, rvals)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER,                       INTENT(IN)  :: num
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: starts(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: counts(*)
                 REAL,                          INTENT(OUT) :: rvals(*)

INTEGER FUNCTION nfmpi_get_varn_double_all(ncid, varid, num, starts, counts, dvals)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER,                       INTENT(IN)  :: num
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: starts(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: counts(*)
                 DOUBLE PRECISION,              INTENT(OUT) :: dvals(*)

INTEGER FUNCTION nfmpi_get_varn_int8_all(ncid, varid, num, starts, counts, i8vals)
                 integer, parameter :: EightByteInt = selected_int_kind(18)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER,                       INTENT(IN)  :: num
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: starts(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: counts(*)
                 INTEGER(KIND=EightByteInt),    INTENT(OUT) :: i8vals(*)


INTEGER FUNCTION nfmpi_put_varn_text(ncid, varid, num, starts, counts, text)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER,                       INTENT(IN)  :: num
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: starts(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: counts(*)
                 CHARACTER(len=*),              INTENT(IN)  :: text

INTEGER FUNCTION nfmpi_put_varn_int1(ncid, varid, num, starts, counts, i1vals)
                 integer, parameter :: OneByteInt = selected_int_kind(2)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER,                       INTENT(IN)  :: num
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: starts(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: counts(*)
                 INTEGER(KIND=OneByteInt),      INTENT(IN)  :: i1vals(*)

INTEGER FUNCTION nfmpi_put_varn_int2(ncid, varid, num, starts, counts, i2vals)
                 integer, parameter :: TwoByteInt = selected_int_kind(4)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER,                       INTENT(IN)  :: num
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: starts(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: counts(*)
                 INTEGER(KIND=TwoByteInt),      INTENT(INOUT) :: i2vals(*)

INTEGER FUNCTION nfmpi_put_varn_int(ncid, varid, num, starts, counts, ivals)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER,                       INTENT(IN)  :: num
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: starts(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: counts(*)
                 INTEGER,                       INTENT(INOUT) :: ivals(*)

INTEGER FUNCTION nfmpi_put_varn_real(ncid, varid, num, starts, counts, rvals)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER,                       INTENT(IN)  :: num
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: starts(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: counts(*)
                 REAL,                          INTENT(INOUT) :: rvals(*)

INTEGER FUNCTION nfmpi_put_varn_double(ncid, varid, num, starts, counts, dvals)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER,                       INTENT(IN)  :: num
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: starts(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: counts(*)
                 DOUBLE PRECISION,              INTENT(INOUT) :: dvals(*)

INTEGER FUNCTION nfmpi_put_varn_int8(ncid, varid, num, starts, counts, i8vals)
                 integer, parameter :: EightByteInt = selected_int_kind(18)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER,                       INTENT(IN)  :: num
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: starts(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: counts(*)
                 INTEGER(KIND=EightByteInt),    INTENT(INOUT) :: i8vals(*)

INTEGER FUNCTION nfmpi_put_varn_text_all(ncid, varid, num, starts, counts, text)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER,                       INTENT(IN)  :: num
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: starts(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: counts(*)
                 CHARACTER(len=*),              INTENT(IN)  :: text

INTEGER FUNCTION nfmpi_put_varn_int1_all(ncid, varid, num, starts, counts, i1vals)
                 integer, parameter :: OneByteInt = selected_int_kind(2)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER,                       INTENT(IN)  :: num
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: starts(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: counts(*)
                 INTEGER(KIND=OneByteInt),      INTENT(IN)  :: i1vals(*)

INTEGER FUNCTION nfmpi_put_varn_int2_all(ncid, varid, num, starts, counts, i2vals)
                 integer, parameter :: TwoByteInt = selected_int_kind(4)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER,                       INTENT(IN)  :: num
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: starts(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: counts(*)
                 INTEGER(KIND=TwoByteInt),      INTENT(INOUT) :: i2vals(*)

INTEGER FUNCTION nfmpi_put_varn_int_all(ncid, varid, num, starts, counts, ivals)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER,                       INTENT(IN)  :: num
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: starts(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: counts(*)
                 INTEGER,                       INTENT(INOUT) :: ivals(*)

INTEGER FUNCTION nfmpi_put_varn_real_all(ncid, varid, num, starts, counts, rvals)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER,                       INTENT(IN)  :: num
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: starts(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: counts(*)
                 REAL,                          INTENT(INOUT) :: rvals(*)

INTEGER FUNCTION nfmpi_put_varn_double_all(ncid, varid, num, starts, counts, dvals)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER,                       INTENT(IN)  :: num
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: starts(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: counts(*)
                 DOUBLE PRECISION,              INTENT(INOUT) :: dvals(*)

INTEGER FUNCTION nfmpi_put_varn_int8_all(ncid, varid, num, starts, counts, i8vals)
                 integer, parameter :: EightByteInt = selected_int_kind(18)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER,                       INTENT(IN)  :: num
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: starts(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: counts(*)
                 INTEGER(KIND=EightByteInt),    INTENT(INOUT) :: i8vals(*)

INTEGER FUNCTION nfmpi_iget_varn(ncid, varid, num, starts, counts, buf, bufcount, buftype, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER,                       INTENT(IN)  :: num
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: starts(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: counts(*)
                 <any valid type>,              INTENT(OUT) :: buf(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: bufcount
                 INTEGER,                       INTENT(IN)  :: buftype
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iput_varn(ncid, varid, num, starts, counts, buf, bufcount, buftype, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER,                       INTENT(IN)  :: num
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: starts(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: counts(*)
                 <any valid type>,              INTENT(IN)  :: buf(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: bufcount
                 INTEGER,                       INTENT(IN)  :: buftype
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iget_varn_text(ncid, varid, num, starts, counts, text, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER,                       INTENT(IN)  :: num
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: starts(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: counts(*)
                 CHARACTER(len=*),              INTENT(OUT) :: text
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iget_varn_int1(ncid, varid, num, starts, counts, i1vals, req)
                 integer, parameter :: OneByteInt = selected_int_kind(2)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER,                       INTENT(IN)  :: num
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: starts(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: counts(*)
                 INTEGER(KIND=OneByteInt),      INTENT(OUT) :: i1vals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iget_varn_int2(ncid, varid, num, starts, counts, i2vals, req)
                 integer, parameter :: TwoByteInt = selected_int_kind(4)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER,                       INTENT(IN)  :: num
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: starts(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: counts(*)
                 INTEGER(KIND=TwoByteInt),      INTENT(OUT) :: i2vals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iget_varn_int(ncid, varid, num, starts, counts, ivals, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER,                       INTENT(IN)  :: num
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: starts(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: counts(*)
                 INTEGER,                       INTENT(OUT) :: ivals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iget_varn_real(ncid, varid, num, starts, counts, rvals, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER,                       INTENT(IN)  :: num
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: starts(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: counts(*)
                 REAL,                          INTENT(OUT) :: rvals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iget_varn_double(ncid, varid, num, starts, counts, dvals, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER,                       INTENT(IN)  :: num
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: starts(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: counts(*)
                 DOUBLE PRECISION,              INTENT(OUT) :: dvals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iget_varn_int8(ncid, varid, num, starts, counts, i8vals, req)
                 integer, parameter :: EightByteInt = selected_int_kind(18)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER,                       INTENT(IN)  :: num
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: starts(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: counts(*)
                 INTEGER(KIND=EightByteInt),    INTENT(OUT) :: i8vals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iput_varn_text(ncid, varid, num, starts, counts, text, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER,                       INTENT(IN)  :: num
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: starts(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: counts(*)
                 CHARACTER(len=*),              INTENT(IN)  :: text
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iput_varn_int1(ncid, varid, num, starts, counts, i1vals, req)
                 integer, parameter :: OneByteInt = selected_int_kind(2)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER,                       INTENT(IN)  :: num
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: starts(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: counts(*)
                 INTEGER(KIND=OneByteInt),      INTENT(IN)  :: i1vals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iput_varn_int2(ncid, varid, num, starts, counts, i2vals, req)
                 integer, parameter :: TwoByteInt = selected_int_kind(4)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER,                       INTENT(IN)  :: num
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: starts(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: counts(*)
                 INTEGER(KIND=TwoByteInt),      INTENT(INOUT) :: i2vals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iput_varn_int(ncid, varid, num, starts, counts, ivals, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER,                       INTENT(IN)  :: num
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: starts(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: counts(*)
                 INTEGER,                       INTENT(INOUT) :: ivals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iput_varn_real(ncid, varid, num, starts, counts, rvals, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER,                       INTENT(IN)  :: num
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: starts(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: counts(*)
                 REAL,                          INTENT(INOUT) :: rvals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iput_varn_double(ncid, varid, num, starts, counts, dvals, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER,                       INTENT(IN)  :: num
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: starts(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: counts(*)
                 DOUBLE PRECISION,              INTENT(INOUT) :: dvals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_iput_varn_int8(ncid, varid, num, starts, counts, i8vals, req)
                 integer, parameter :: EightByteInt = selected_int_kind(18)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER,                       INTENT(IN)  :: num
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: starts(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: counts(*)
                 INTEGER(KIND=EightByteInt),    INTENT(INOUT) :: i8vals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_bput_varn(ncid, varid, num, starts, counts, buf, bufcount, buftype, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER,                       INTENT(IN)  :: num
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: starts(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: counts(*)
                 <any valid type>,              INTENT(IN)  :: buf(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: bufcount
                 INTEGER,                       INTENT(IN)  :: buftype
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_bput_varn_text(ncid, varid, num, starts, counts, text, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER,                       INTENT(IN)  :: num
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: starts(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: counts(*)
                 CHARACTER(len=*),              INTENT(IN)  :: text
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_bput_varn_int1(ncid, varid, num, starts, counts, i1vals, req)
                 integer, parameter :: OneByteInt = selected_int_kind(2)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER,                       INTENT(IN)  :: num
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: starts(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: counts(*)
                 INTEGER(KIND=OneByteInt),      INTENT(IN)  :: i1vals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_bput_varn_int2(ncid, varid, num, starts, counts, i2vals, req)
                 integer, parameter :: TwoByteInt = selected_int_kind(4)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER,                       INTENT(IN)  :: num
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: starts(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: counts(*)
                 INTEGER(KIND=TwoByteInt),      INTENT(INOUT) :: i2vals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_bput_varn_int(ncid, varid, num, starts, counts, ivals, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER,                       INTENT(IN)  :: num
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: starts(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: counts(*)
                 INTEGER,                       INTENT(INOUT) :: ivals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_bput_varn_real(ncid, varid, num, starts, counts, rvals, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER,                       INTENT(IN)  :: num
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: starts(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: counts(*)
                 REAL,                          INTENT(INOUT) :: rvals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_bput_varn_double(ncid, varid, num, starts, counts, dvals, req)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER,                       INTENT(IN)  :: num
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: starts(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: counts(*)
                 DOUBLE PRECISION,              INTENT(INOUT) :: dvals(*)
                 INTEGER,                       INTENT(OUT) :: req

INTEGER FUNCTION nfmpi_bput_varn_int8(ncid, varid, num, starts, counts, i8vals, req)
                 integer, parameter :: EightByteInt = selected_int_kind(18)
                 INTEGER,                       INTENT(IN)  :: ncid
                 INTEGER,                       INTENT(IN)  :: varid
                 INTEGER,                       INTENT(IN)  :: num
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: starts(*)
                 INTEGER(KIND=MPI_OFFSET_KIND), INTENT(IN)  :: counts(*)
                 INTEGER(KIND=EightByteInt),    INTENT(INOUT) :: i8vals(*)
                 INTEGER,                       INTENT(OUT) :: req
@end example

@node Summary of Fortran 90 Interface, Error Codes, Summary of Fortran 77 Interface, Top
@appendix Summary of Fortran 90 Interface
@cindex API, Fortran 90 summary
@cindex Fortran 90 API summary

@enumerate
@item @ref{lib_api90, Library APIs}
@item @ref{err_api90, Error report APIs}
@item @ref{file_api90, File APIs}
@item @ref{indep_api90, Entering/exiting independent data mode APIs}
@item @ref{wait_api90, Nonblocking I/O control APIs}
@item @ref{file_inq_api90, File inquiry APIs}
@item @ref{dim_api90, Dimension APIs}
@item @ref{attr_inq_api90, Attribute inquiry APIs}
@item @ref{attr_api90, Attribute put/get APIs}
@item @ref{def_var_api90, General variable APIs}
@item @ref{var_api90, Blocking put/get variable APIs}
@item @ref{i_var_api90, Nonblocking iput/iget variable APIs}
@item @ref{b_var_api90, Nonblocking buffered put APIs}
@item @ref{vard_api90, Blocking put/get an array of values using filetype}
@item @ref{varn_api90, Blocking and nonblocking put/get a list of subarrays}
@end enumerate

@anchor{lib_api90}
@heading Library APIs
@example
character(len=80) function nf90mpi_inq_libvers()
@end example

@anchor{err_api90}
@heading Error report APIs
@example
character(len=80) function nf90mpi_strerror(ncerr)
                  integer, intent(in) :: ncerr

logical           function nf90mpi_issyserr(ncerr)
                  integer, intent(in) :: ncerr

character(len=80) function nf90mpi_strerrno(ncerr)
                  integer, intent(in) :: ncerr
@end example

@anchor{file_api90}
@heading File APIs
@example
integer function nf90mpi_create(mpi_comm, path, cmode, mpi_info, ncid)
    character(len=*), intent( in) :: path
    integer,          intent( in) :: mpi_comm
    integer,          intent( in) :: cmode
    integer,          intent( in) :: mpi_info
    integer,          intent(out) :: ncid

integer function nf90mpi_open(mpi_comm, path, omode, mpi_info, ncid)
    character(len=*), intent( in) :: path
    integer,          intent( in) :: mpi_comm
    integer,          intent( in) :: omode
    integer,          intent( in) :: mpi_info
    integer,          intent(out) :: ncid

integer function nf90mpi_enddef(ncid, h_minfree, v_align, v_minfree, r_align)
    integer,                                 intent(in)  :: ncid
    integer(kind=MPI_OFFSET_KIND), optional, intent(in)  :: h_minfree
    integer(kind=MPI_OFFSET_KIND), optional, intent(in)  :: v_align
    integer(kind=MPI_OFFSET_KIND), optional, intent(in)  :: v_minfree
    integer(kind=MPI_OFFSET_KIND), optional, intent(in)  :: r_align

integer function nf90mpi_redef(ncid)
    integer, intent(in)  :: ncid

integer function nf90mpi_flush(ncid)
    integer, intent(in)  :: ncid

integer function nf90mpi_sync(ncid)
    integer, intent(in)  :: ncid

integer function nf90mpi_sync_numrecs(ncid)
    integer, intent(in)  :: ncid

integer function nf90mpi_close(ncid)
    integer, intent(in)  :: ncid

integer function nf90mpi_set_fill(ncid, fillmode, old_mode)
    integer, intent( in) :: ncid
    integer, intent( in) :: fillmode
    integer, intent(out) :: old_mode

integer function nf90mpi_set_default_format(new_format, old_format)
    integer, intent( in) :: new_format
    integer, intent(out) :: old_format

integer function nf90mpi_abort(ncid)
    integer, intent(in)  :: ncid

integer function nf90mpi_delete(name, mpi_info)
    character(len=*), intent(in) :: name
    integer,          intent(in) :: mpi_info
@end example

@anchor{indep_api90}
@heading Entering/exiting independent data mode APIs
@example
integer function nf90mpi_begin_indep_data(ncid)
    integer, intent(in) :: ncid

integer function nf90mpi_end_indep_data(ncid)
    integer, intent(in) :: ncid
@end example

@anchor{wait_api90}
@heading Nonblocking I/O control APIs
@example
integer function nf90mpi_wait(ncid, num, req, st)
    integer,               intent(in)    :: ncid
    integer,               intent(in)    :: num
    integer, dimension(:), intent(inout) :: req
    integer, dimension(:), intent(out)   :: st

integer function nf90mpi_wait_all(ncid, num, req, st)
    integer,               intent(in)    :: ncid
    integer,               intent(in)    :: num
    integer, dimension(:), intent(inout) :: req
    integer, dimension(:), intent(out)   :: st

integer function nf90mpi_cancel(ncid, num, req, st)
    integer,               intent(in)    :: ncid
    integer,               intent(in)    :: num
    integer, dimension(:), intent(inout) :: req
    integer, dimension(:), intent(out)   :: st
@end example

@anchor{file_inq_api90}
@heading File inquiry APIs
@example
integer function nf90mpi_inquire(ncid, nDimensions, nVariables, nAttributes, unlimitedDimId, format)
    integer,           intent( in) :: ncid
    integer, optional, intent(out) :: nDimensions
    integer, optional, intent(out) :: nVariables
    integer, optional, intent(out) :: nAttributes
    integer, optional, intent(out) :: unlimitedDimId
    integer, optional, intent(out) :: format

integer function nf90mpi_inq_file_format(path, format)
    character(len=*), intent( in) :: path
    integer,          intent(out) :: format

integer function nf90mpi_inq_default_format(default_format)
    integer, intent(out) :: default_format

integer function nf90mpi_inq_header_size(ncid, h_size)
    integer,                       intent( in) :: ncid
    integer(kind=MPI_OFFSET_KIND), intent(out) :: h_size

integer function nf90mpi_inq_header_extent(ncid, h_extent)
    integer,                       intent( in) :: ncid
    integer(kind=MPI_OFFSET_KIND), intent(out) :: h_extent

integer function nf90mpi_inq_files_opened(nfiles, ncids)
    integer,               intent(out) :: nfiles
    integer, dimension(:), intent(out) :: ncids

integer function nf90mpi_inq_path(ncid, pathlen, path)
    integer,          intent( in) :: ncid
    integer,          intent(out) :: pathlen
    character(len=*), intent(out) :: path

integer function nf90mpi_inq_num_rec_vars(ncid, nvars)
    integer, intent( in) :: ncid
    integer, intent(out) :: nvars

integer function nf90mpi_inq_num_fix_vars(ncid, nvars)
    integer, intent( in) :: ncid
    integer, intent(out) :: nvars

integer function nf90mpi_inq_recsize(ncid, recsize)
    integer,                       intent( in) :: ncid
    integer(kind=MPI_OFFSET_KIND), intent(out) :: recsize

integer function nf90mpi_inq_file_info(ncid, mpi_info)
    integer, intent( in) :: ncid
    integer, intent(out) :: mpi_info

integer function nf90mpi_get_file_info(ncid, mpi_info)
    integer, intent( in) :: ncid
    integer, intent(out) :: mpi_info

integer function nf90mpi_inq_striping(ncid, striping_size, striping_count)
    integer, intent( in) :: ncid
    integer, intent(out) :: striping_size
    integer, intent(out) :: striping_count

integer function nf90mpi_inq_put_size(ncid, put_size)
    integer,                       intent( in) :: ncid
    integer(kind=MPI_OFFSET_KIND), intent(out) :: put_size

integer function nf90mpi_inq_get_size(ncid, get_size)
    integer,                       intent( in) :: ncid
    integer(kind=MPI_OFFSET_KIND), intent(out) :: get_size

integer function nf90mpi_inq_nreqs(ncid, nreqs)
    integer, intent( in) :: ncid
    integer, intent(out) :: nreqs

integer function nf90mpi_inq_malloc_size(size)
    integer(kind=MPI_OFFSET_KIND), intent(out) :: size

integer function nf90mpi_inq_malloc_max_size(size)
    integer(kind=MPI_OFFSET_KIND), intent(out) :: size

integer function nf90mpi_inq_malloc_list()
    integer :: nf90mpi_inq_malloc_list
@end example

@anchor{dim_api90}
@heading Dimension APIs
@example
integer function nf90mpi_def_dim(ncid, name, len, dimid)
    integer,                       intent( in) :: ncid
    character(len=*),              intent( in) :: name
    integer(kind=MPI_OFFSET_KIND), intent( in) :: len
    integer,                       intent(out) :: dimid

integer function nf90mpi_inq_dimid(ncid, name, dimid)
    integer,          intent( in) :: ncid
    character(len=*), intent( in) :: name
    integer,          intent(out) :: dimid

integer function nf90mpi_inquire_dimension(ncid, dimid, name, len)
    integer,                                 intent( in) :: ncid
    integer,                                 intent( in) :: dimid
    character(len=*),              optional, intent(out) :: name
    integer(kind=MPI_OFFSET_KIND), optional, intent(out) :: len

integer function nf90mpi_rename_dim(ncid, dimid, name)
    integer,          intent( in) :: ncid
    character(len=*), intent( in) :: name
    integer,          intent( in) :: dimid
@end example

@anchor{attr_inq_api90}
@heading Attribute inquiry APIs
@example
integer function nf90mpi_inquire_attribute(ncid, varid, name, xtype, len, attnum)
    integer,                                 intent( in) :: ncid
    integer,                                 intent( in) :: varid
    character(len = *),                      intent( in) :: name
    integer,                       optional, intent(out) :: xtype
    integer,                       optional, intent(out) :: attnum
    integer(kind=MPI_OFFSET_KIND), optional, intent(out) :: len

integer function nf90mpi_inq_attname(ncid, varid, attnum, name)
    integer,          intent( in) :: ncid
    integer,          intent( in) :: varid
    integer,          intent( in) :: attnum
    character(len=*), intent(out) :: name

integer function nf90mpi_copy_att(ncid_in, varid_in, name, ncid_out, varid_out)
    integer,          intent(in) :: ncid_in
    integer,          intent(in) :: varid_in
    character(len=*), intent(in) :: name
    integer,          intent(in) :: ncid_out
    integer,          intent(in) :: varid_out

integer function nf90mpi_rename_att(ncid, varid, curname, newname)
    integer,          intent(in) :: ncid
    integer,          intent(in) :: varid
    character(len=*), intent(in) :: curname
    character(len=*), intent(in) :: newname

integer function nf90mpi_del_att(ncid, varid, name)
    integer,          intent(in) :: ncid
    integer,          intent(in) :: varid
    character(len=*), intent(in) :: name
@end example

@anchor{attr_api90}
@heading Attribute put/get APIs
@example
integer function nf90mpi_put_att(ncid, varid, name, values)
    integer,                                     intent(in) :: ncid
    integer,                                     intent(in) :: varid
    character(len=*),                            intent(in) :: name
    <any valid type, scalar or array of rank 1>, intent(in) :: values

integer function nf90mpi_get_att(ncid, varid, name, values)
    integer,                                     intent( in) :: ncid
    integer,                                     intent( in) :: varid
    character(len=*),                            intent( in) :: name
    <any valid type, scalar or array of rank 1>, intent(out) :: values
@end example

@anchor{def_var_api90}
@heading General variable APIs
@example
integer function nf90mpi_def_var(ncid, name, xtype, dimids, varid)
    integer,               intent( in) :: ncid
    character(len = *),    intent( in) :: name
    integer,               intent( in) :: xtype
    integer, dimension(:), intent( in) :: dimids ! omitted for scalar

integer function nf90mpi_inq_varid(ncid, name, varid)
    integer,          intent( in) :: ncid
    character(len=*), intent( in) :: name
    integer,          intent(out) :: varid

integer function nf90mpi_inquire_variable(ncid, varid, name, xtype, ndims, dimids, nAtts)
    integer,                         intent( in) :: ncid
    integer,                         intent( in) :: varid
    character(len=*),      optional, intent(out) :: name
    integer,               optional, intent(out) :: xtype
    integer,               optional, intent(out) :: ndims
    integer, dimension(*), optional, intent(out) :: dimids
    integer,               optional, intent(out) :: nAtts

integer function nf90mpi_inq_varoffset(ncid, varid, offset)
    integer,                       intent( in) :: ncid, varid
    integer(kind=MPI_OFFSET_KIND), intent(out) :: offset

integer function nf90mpi_rename_var(ncid, varid, newname)
    integer,          intent( in) :: ncid
    integer,          intent( in) :: varid
    character(len=*), intent( in) :: newname

integer function nf90mpi_def_var_fill(ncid, varid, no_fill, fill_value)
    integer,          intent( in) :: ncid
    integer,          intent( in) :: varid
    integer,          intent( in) :: no_fill
    <any valid type>, intent( in) :: fill_value

integer function nf90mpi_inq_var_fill(ncid, varid, no_fill, fill_value)
    integer,          intent( in) :: ncid
    integer,          intent( in) :: varid
    integer,          intent(out) :: no_fill
    <any valid type>, intent(out) :: fill_value

integer function nf90mpi_fill_var_rec(ncid, varid, recno)
    integer,                       intent( in) :: ncid
    integer,                       intent( in) :: varid
    integer(kind=MPI_OFFSET_KIND), intent( in) :: recno
@end example

@anchor{var_api90}
@heading Blocking put/get variable APIs
@example
integer function nf90mpi_put_var(ncid, varid, values, start, stride, map, bufcount, buftype)
    integer,                                                intent(in   ) :: ncid
    integer,                                                intent(in   ) :: varid
    <any valid type, scalar or array of any rank>,          intent(inout) :: values
    integer (kind=MPI_OFFSET_KIND), dimension(:), optional, intent(in   ) :: start
    integer (kind=MPI_OFFSET_KIND), dimension(:), optional, intent(in   ) :: count
    integer (kind=MPI_OFFSET_KIND), dimension(:), optional, intent(in   ) :: stride
    integer (kind=MPI_OFFSET_KIND), dimension(:), optional, intent(in   ) :: map
    integer (kind=MPI_OFFSET_KIND),               optional, intent(in   ) :: bufcount
    integer,                                      optional, intent(in   ) :: buftype

integer function nf90mpi_put_var_all(ncid, varid, values, start, stride, map, bufcount, buftype)
    integer,                                                intent(in   ) :: ncid
    integer,                                                intent(in   ) :: varid
    <any valid type, scalar or array of any rank>,          intent(inout) :: values
    integer (kind=MPI_OFFSET_KIND), dimension(:), optional, intent(in   ) :: start
    integer (kind=MPI_OFFSET_KIND), dimension(:), optional, intent(in   ) :: count
    integer (kind=MPI_OFFSET_KIND), dimension(:), optional, intent(in   ) :: stride
    integer (kind=MPI_OFFSET_KIND), dimension(:), optional, intent(in   ) :: map
    integer (kind=MPI_OFFSET_KIND),               optional, intent(in   ) :: bufcount
    integer,                                      optional, intent(in   ) :: buftype

integer function nf90mpi_get_var(ncid, varid, values, start, stride, map, bufcount, buftype)
    integer,                                                intent( in) :: ncid
    integer,                                                intent( in) :: varid
    <any valid type, scalar or array of any rank>,          intent(out) :: values
    integer (kind=MPI_OFFSET_KIND), dimension(:), optional, intent( in) :: start
    integer (kind=MPI_OFFSET_KIND), dimension(:), optional, intent( in) :: count
    integer (kind=MPI_OFFSET_KIND), dimension(:), optional, intent( in) :: stride
    integer (kind=MPI_OFFSET_KIND), dimension(:), optional, intent( in) :: map
    integer (kind=MPI_OFFSET_KIND),               optional, intent( in) :: bufcount
    integer,                                      optional, intent( in) :: buftype

integer function nf90mpi_get_var_all(ncid, varid, values, start, stride, map, bufcount, buftype)
    integer,                                                intent( in) :: ncid
    integer,                                                intent( in) :: varid
    <any valid type, scalar or array of any rank>,          intent(out) :: values
    integer (kind=MPI_OFFSET_KIND), dimension(:), optional, intent( in) :: start
    integer (kind=MPI_OFFSET_KIND), dimension(:), optional, intent( in) :: count
    integer (kind=MPI_OFFSET_KIND), dimension(:), optional, intent( in) :: stride
    integer (kind=MPI_OFFSET_KIND), dimension(:), optional, intent( in) :: map
    integer (kind=MPI_OFFSET_KIND),               optional, intent( in) :: bufcount
    integer,                                      optional, intent( in) :: buftype
@end example

@anchor{i_var_api90}
@heading Nonblocking put/get variable APIs
@example
integer function nf90mpi_iput_var(ncid, varid, values, req, start, stride, map, bufcount, buftype)
    integer,                                                intent(in   ) :: ncid
    integer,                                                intent(in   ) :: varid
    <any valid type, scalar or array of any rank>,          intent(inout) :: values
    integer,                                                intent(  out) :: req
    integer (kind=MPI_OFFSET_KIND), dimension(:), optional, intent(in   ) :: start
    integer (kind=MPI_OFFSET_KIND), dimension(:), optional, intent(in   ) :: count
    integer (kind=MPI_OFFSET_KIND), dimension(:), optional, intent(in   ) :: stride
    integer (kind=MPI_OFFSET_KIND), dimension(:), optional, intent(in   ) :: map
    integer (kind=MPI_OFFSET_KIND),               optional, intent(in   ) :: bufcount
    integer,                                      optional, intent(in   ) :: buftype

integer function nf90mpi_iget_var(ncid, varid, values, req, start, stride, map, bufcount, buftype)
    integer,                                                intent( in) :: ncid
    integer,                                                intent( in) :: varid
    <any valid type, scalar or array of any rank>,          intent(out) :: values
    integer,                                                intent(out) :: req
    integer (kind=MPI_OFFSET_KIND), dimension(:), optional, intent( in) :: start
    integer (kind=MPI_OFFSET_KIND), dimension(:), optional, intent( in) :: count
    integer (kind=MPI_OFFSET_KIND), dimension(:), optional, intent( in) :: stride
    integer (kind=MPI_OFFSET_KIND), dimension(:), optional, intent( in) :: map
    integer (kind=MPI_OFFSET_KIND),               optional, intent( in) :: bufcount
    integer,                                      optional, intent( in) :: buftype
@end example

@anchor{b_var_api90}
@heading Nonblocking buffered put variable APIs
@example
integer function nf90mpi_bput_var(ncid, varid, values, req, start, stride, map, bufcount, buftype)
    integer,                                                intent(in   ) :: ncid
    integer,                                                intent(in   ) :: varid
    <any valid type, scalar or array of any rank>,          intent(inout) :: values
    integer,                                                intent(  out) :: req
    integer (kind=MPI_OFFSET_KIND), dimension(:), optional, intent(in   ) :: start
    integer (kind=MPI_OFFSET_KIND), dimension(:), optional, intent(in   ) :: count
    integer (kind=MPI_OFFSET_KIND), dimension(:), optional, intent(in   ) :: stride
    integer (kind=MPI_OFFSET_KIND), dimension(:), optional, intent(in   ) :: map
    integer (kind=MPI_OFFSET_KIND),               optional, intent(in   ) :: bufcount
    integer,                                      optional, intent(in   ) :: buftype

integer function nf90mpi_buffer_attach(ncid, bufsize)
    integer,                        intent( in) :: ncid
    integer (kind=MPI_OFFSET_KIND), intent( in) :: bufsize

integer function nf90mpi_buffer_detach(ncid)
    integer,                       intent( in) :: ncid

integer function nf90mpi_inq_buffer_size(ncid, buf_size)
    integer,                        intent( in) :: ncid
    integer (kind=MPI_OFFSET_KIND), intent(out) :: buf_size

integer function nf90mpi_inq_buffer_usage(ncid, usage)
    integer,                        intent( in) :: ncid
    integer (kind=MPI_OFFSET_KIND), intent(out) :: usage
@end example

@anchor{vard_api90}
@heading Blocking put/get an array of values using filetype
@example
integer function nf90mpi_put_vard(ncid, varid, filetype, buf, bufcount, buftype)
    integer,                                       intent(in   ) :: ncid
    integer,                                       intent(in   ) :: varid
    integer,                                       intent(in   ) :: filetype
    <any valid type, scalar or array of any rank>, intent(inout) :: buf
    integer (kind=MPI_OFFSET_KIND),                intent(in   ) :: bufcount
    integer,                                       intent(in   ) :: buftype

integer function nf90mpi_put_vard_all(ncid, varid, filetype, buf, bufcount, buftype)
    integer,                                       intent(in   ) :: ncid
    integer,                                       intent(in   ) :: varid
    integer,                                       intent(in   ) :: filetype
    <any valid type, scalar or array of any rank>, intent(inout) :: buf
    integer (kind=MPI_OFFSET_KIND),                intent(in   ) :: bufcount
    integer,                                       intent(in   ) :: buftype

integer function nf90mpi_get_vard(ncid, varid, filetype, buf, bufcount, buftype)
    integer,                                       intent( in) :: ncid
    integer,                                       intent( in) :: varid
    integer,                                       intent( in) :: filetype
    <any valid type, scalar or array of any rank>, intent(out) :: buf
    integer (kind=MPI_OFFSET_KIND),                intent( in) :: bufcount
    integer,                                       intent( in) :: buftype

integer function nf90mpi_get_vard_all(ncid, varid, filetype, buf, bufcount, buftype)
    integer,                                       intent( in) :: ncid
    integer,                                       intent( in) :: varid
    integer,                                       intent( in) :: filetype
    <any valid type, scalar or array of any rank>, intent(out) :: buf
    integer (kind=MPI_OFFSET_KIND),                intent( in) :: bufcount
    integer,                                       intent( in) :: buftype
@end example

@anchor{varn_api90}
@heading Blocking and nonblocking put/get a list of subarrays
@example
integer function nf90mpi_put_varn(ncid, varid, values, num, start, count)
    integer,                                                  intent(in   ) :: ncid
    integer,                                                  intent(in   ) :: varid
    <any valid type, scalar or array of any rank>,            intent(inout) :: values
    integer,                                                  intent(in   ) :: num
    integer (kind=MPI_OFFSET_KIND), dimension(:,:),           intent(in   ) :: start
    integer (kind=MPI_OFFSET_KIND), dimension(:,:), optional, intent(in   ) :: count

integer function nf90mpi_put_varn_all(ncid, varid, values, num, start, count)
    integer,                                                  intent(in   ) :: ncid
    integer,                                                  intent(in   ) :: varid
    <any valid type, scalar or array of any rank>,            intent(inout) :: values
    integer,                                                  intent(in   ) :: num
    integer (kind=MPI_OFFSET_KIND), dimension(:,:),           intent(in   ) :: start
    integer (kind=MPI_OFFSET_KIND), dimension(:,:), optional, intent(in   ) :: count

integer function nf90mpi_get_varn(ncid, varid, values, num, start, count)
    integer,                                                  intent( in) :: ncid
    integer,                                                  intent( in) :: varid
    <any valid type, scalar or array of any rank>,            intent(out) :: values
    integer,                                                  intent( in) :: num
    integer (kind=MPI_OFFSET_KIND), dimension(:,:),           intent( in) :: start
    integer (kind=MPI_OFFSET_KIND), dimension(:,:), optional, intent( in) :: count

integer function nf90mpi_get_varn_all(ncid, varid, values, num, start, count)
    integer,                                                  intent( in) :: ncid
    integer,                                                  intent( in) :: varid
    <any valid type, scalar or array of any rank>,            intent(out) :: values
    integer,                                                  intent( in) :: num
    integer (kind=MPI_OFFSET_KIND), dimension(:,:),           intent( in) :: start
    integer (kind=MPI_OFFSET_KIND), dimension(:,:), optional, intent( in) :: count

integer function nf90mpi_iput_varn(ncid, varid, values, req, num, start, count)
    integer,                                                  intent(in   ) :: ncid
    integer,                                                  intent(in   ) :: varid
    <any valid type, scalar or array of any rank>,            intent(inout) :: values
    integer,                                                  intent(out  ) :: req
    integer,                                                  intent(in   ) :: num
    integer (kind=MPI_OFFSET_KIND), dimension(:,:),           intent(in   ) :: start
    integer (kind=MPI_OFFSET_KIND), dimension(:,:), optional, intent(in   ) :: count

integer function nf90mpi_iget_varn(ncid, varid, values, req, num, start, count)
    integer,                                                  intent( in) :: ncid
    integer,                                                  intent( in) :: varid
    <any valid type, scalar or array of any rank>,            intent(out) :: values
    integer,                                                  intent(out) :: req
    integer,                                                  intent( in) :: num
    integer (kind=MPI_OFFSET_KIND), dimension(:,:),           intent( in) :: start
    integer (kind=MPI_OFFSET_KIND), dimension(:,:), optional, intent( in) :: count

integer function nf90mpi_bput_varn(ncid, varid, values, req, num, start, count)
    integer,                                                  intent(in   ) :: ncid
    integer,                                                  intent(in   ) :: varid
    <any valid type, scalar or array of any rank>,            intent(inout) :: values
    integer,                                                  intent(  out) :: req
    integer,                                                  intent(in   ) :: num
    integer (kind=MPI_OFFSET_KIND), dimension(:,:),           intent(in   ) :: start
    integer (kind=MPI_OFFSET_KIND), dimension(:,:), optional, intent(in   ) :: count
@end example

@node Error Codes, Combined Index, Summary of Fortran 90 Interface, Top
@appendix Error Codes
@cindex error codes, list
@cindex list of error codes

All PnetCDF APIs return an integer value, an error code indicating the error status. NC_NOERR, NF_NOERR, and NF90_NOERR mean the API ran successfully. All error codes are non-positive integral values, constants defined in header file pnetcdf.h. One can call APIs ncmpi_strerror/nfmpi_strerror/nf90mpi_strerror to turn an error code into a human readable string. For example, NC_EBADID becomes "NetCDF: Not a valid ID". The code fragment below shows a way to check for error and prints the error message.

@example
err = ncmpi_create(comm, path, cmode, info, &ncid);
if (err != NC_NOERR) @{
    int rank;
    MPI_Comm_rank(comm, &rank);
    printf("Error at rank %d: %s\n", rank, ncmpi_strerror(err));
@}
@end example

PnetCDF reports the error codes that are recognizable by netCDF. NetCDF-3, netCDF-4 and PnetCDF each defines a disjoined range of negative values corresponding to their error codes.
@itemize
@item
NetCDF-3 error codes are integral values in a range between 0 and -99.
@item
NetCDF-4 specific error codes are integral values in a range between -100 and -199. These error codes are not used or reported by PnetCDF.
@item
PnetCDF specific error codes are integral values in a range between -200 and -299.
@end itemize

@heading NetCDF-3 error codes
@example
#define NC_NOERR        0       /* No Error */

#define NC_EBADID       (-33)   /* Not a netcdf id */
#define NC_ENFILE       (-34)   /* Too many netcdfs open */
#define NC_EEXIST       (-35)   /* netcdf file exists && NC_NOCLOBBER */
#define NC_EINVAL       (-36)   /* Invalid Argument or file format violates CDF specification */
#define NC_EPERM        (-37)   /* Write to read only */
#define NC_ENOTINDEFINE (-38)   /* Operation not allowed in data mode */
#define NC_EINDEFINE    (-39)   /* Operation not allowed in define mode */
#define NC_EINVALCOORDS (-40)   /* Index exceeds dimension bound */
#define NC_EMAXDIMS     (-41)   /* NC_MAX_DIMS exceeded */
#define NC_ENAMEINUSE   (-42)   /* String match to name in use */
#define NC_ENOTATT      (-43)   /* Attribute not found */
#define NC_EMAXATTS     (-44)   /* NC_MAX_ATTRS exceeded */
#define NC_EBADTYPE     (-45)   /* Not a netcdf data type */
#define NC_EBADDIM      (-46)   /* Invalid dimension id or name */
#define NC_EUNLIMPOS    (-47)   /* NC_UNLIMITED in the wrong index */
#define NC_EMAXVARS     (-48)   /* NC_MAX_VARS exceeded */
#define NC_ENOTVAR      (-49)   /* Variable not found */
#define NC_EGLOBAL      (-50)   /* Action prohibited on NC_GLOBAL varid */
#define NC_ENOTNC       (-51)   /* Not a netcdf file */
#define NC_ESTS         (-52)   /* In Fortran, string too short */
#define NC_EMAXNAME     (-53)   /* NC_MAX_NAME exceeded */
#define NC_EUNLIMIT     (-54)   /* NC_UNLIMITED size already in use */
#define NC_ENORECVARS   (-55)   /* nc_rec op when there are no record vars */
#define NC_ECHAR        (-56)   /* Attempt to convert between text & numbers */
#define NC_EEDGE        (-57)   /* Edge+start exceeds dimension bound */
#define NC_ESTRIDE      (-58)   /* Illegal stride */
#define NC_EBADNAME     (-59)   /* Attribute or variable name contains illegal characters */
#define NC_ERANGE       (-60)   /* Math result not representable */
#define NC_ENOMEM       (-61)   /* Memory allocation (malloc) failure */
#define NC_EVARSIZE     (-62)   /* One or more variable sizes violate format constraints */
#define NC_EDIMSIZE     (-63)   /* Invalid dimension size */
#define NC_ETRUNC       (-64)   /* File likely truncated or possibly corrupted */
#define NC_EAXISTYPE    (-65)   /* Unknown axis type. */

#define NC_EDAP         (-66)   /* Generic DAP error */
#define NC_ECURL        (-67)   /* Generic libcurl error */
#define NC_EIO          (-68)   /* Generic IO error */
#define NC_ENODATA      (-69)   /* Attempt to access variable with no data */
#define NC_EDAPSVC      (-70)   /* DAP server error */
#define NC_EDAS         (-71)   /* Malformed or inaccessible DAS */
#define NC_EDDS         (-72)   /* Malformed or inaccessible DDS */
#define NC_EDATADDS     (-73)   /* Malformed or inaccessible DATADDS */
#define NC_EDAPURL      (-74)   /* Malformed DAP URL */
#define NC_EDAPCONSTRAINT (-75) /* Malformed DAP Constraint*/
#define NC_ETRANSLATION (-76)   /* Untranslatable construct */
#define NC_EACCESS      (-77)   /* Access Failure */
#define NC_EAUTH        (-78)   /* Authorization Failure */

#define NC_ENOTFOUND    (-90)   /* No such file */
#define NC_ECANTREMOVE  (-91)   /* Can't remove file */
#define NC_EINTERNAL    (-92)   /* NetCDF Library Internal Error */
@end example

@heading NetCDF-4 error codes
@example
#define NC4_FIRST_ERROR (-100)
#define NC_EHDFERR      (-101) /* Error at HDF5 layer. */
#define NC_ECANTREAD    (-102) /* Cannot read. */
#define NC_ECANTWRITE   (-103) /* Cannot write. */
#define NC_ECANTCREATE  (-104) /* Cannot create. */
#define NC_EFILEMETA    (-105) /* Problem with file metadata. */
#define NC_EDIMMETA     (-106) /* Problem with dimension metadata. */
#define NC_EATTMETA     (-107) /* Problem with attribute metadata. */
#define NC_EVARMETA     (-108) /* Problem with variable metadata. */
#define NC_ENOCOMPOUND  (-109) /* Not a compound type. */
#define NC_EATTEXISTS   (-110) /* Attribute already exists. */
#define NC_ENOTNC4      (-111) /* Attempting netcdf-4 operation on netcdf-3 file. */
#define NC_ESTRICTNC3   (-112) /* Attempting netcdf-4 operation on strict nc3 netcdf-4 file. */
#define NC_ENOTNC3      (-113) /* Attempting netcdf-3 operation on netcdf-4 file. */
#define NC_ENOPAR       (-114) /* Parallel operation on file opened for non-parallel access. */
#define NC_EPARINIT     (-115) /* Error initializing for parallel access. */
#define NC_EBADGRPID    (-116) /* Bad group ID. */
#define NC_EBADTYPID    (-117) /* Bad type ID. */
#define NC_ETYPDEFINED  (-118) /* Type has already been defined and may not be edited. */
#define NC_EBADFIELD    (-119) /* Bad field ID. */
#define NC_EBADCLASS    (-120) /* Bad class. */
#define NC_EMAPTYPE     (-121) /* Mapped access for atomic types only. */
#define NC_ELATEFILL    (-122) /* Attempt to define fill value when data already exists. */
#define NC_ELATEDEF     (-123) /* Attempt to define var properties, like deflate, after enddef. */
#define NC_EDIMSCALE    (-124) /* Problem with HDF5 dimscales. */
#define NC_ENOGRP       (-125) /* No group found. */
#define NC_ESTORAGE     (-126) /* Cannot specify both contiguous and chunking. */
#define NC_EBADCHUNK    (-127) /* Bad chunksize. */
#define NC_ENOTBUILT    (-128) /* Attempt to use feature that was not turned on when netCDF was built. */
#define NC_EDISKLESS    (-129) /* Error in using diskless  access. */
#define NC_ECANTEXTEND  (-130) /* Attempt to extend file during ind. I/O operation. */
#define NC_EMPI         (-131) /* MPI operation failed. */
#define NC_EFILTER      (-132) /* Filter operation failed. */
#define NC_ERCFILE      (-133) /* RC file failure */
#define NC_ENULLPAD     (-134) /* Header Bytes not Null-Byte padded */
#define NC_EINMEMORY    (-135) /* In-memory file error */
#define NC4_LAST_ERROR  (-136) /* internal All netCDF errors > this. */
@end example

@heading PnetCDF error codes
@example
#define NC_ESMALL                       (-201) /* size of MPI_Offset too small for format */
#define NC_ENOTINDEP                    (-202) /* Operation not allowed in collective data mode */
#define NC_EINDEP                       (-203) /* Operation not allowed in independent data mode */
#define NC_EFILE                        (-204) /* Unknown error in file operation */
#define NC_EREAD                        (-205) /* Unknown error in reading file */
#define NC_EWRITE                       (-206) /* Unknown error in writing to file */
#define NC_EOFILE                       (-207) /* file open/creation failed */
#define NC_EMULTITYPES                  (-208) /* Multiple types used in memory data */
#define NC_EIOMISMATCH                  (-209) /* Input/Output data amount mismatch */
#define NC_ENEGATIVECNT                 (-210) /* Negative count is specified */
#define NC_EUNSPTETYPE                  (-211) /* Unsupported etype in memory MPI datatype */
#define NC_EINVAL_REQUEST               (-212) /* invalid nonblocking request ID */
#define NC_EAINT_TOO_SMALL              (-213) /* MPI_Aint not large enough to hold requested value */
#define NC_ENOTSUPPORT                  (-214) /* feature is not yet supported */
#define NC_ENULLBUF                     (-215) /* trying to attach a NULL buffer */
#define NC_EPREVATTACHBUF               (-216) /* previous attached buffer is found */
#define NC_ENULLABUF                    (-217) /* no attached buffer is found */
#define NC_EPENDINGBPUT                 (-218) /* pending bput is found, cannot detach buffer */
#define NC_EINSUFFBUF                   (-219) /* attached buffer is too small */
#define NC_ENOENT                       (-220) /* File does not exist when calling ncmpi_open() */
#define NC_EINTOVERFLOW                 (-221) /* Overflow when type cast to 4-byte integer */
#define NC_ENOTENABLED                  (-222) /* feature is not enabled */
#define NC_EBAD_FILE                    (-223) /* Invalid file name (e.g., path name too long) */
#define NC_ENO_SPACE                    (-224) /* Not enough space */
#define NC_EQUOTA                       (-225) /* Quota exceeded */
#define NC_ENULLSTART                   (-226) /* argument start is a NULL pointer */
#define NC_ENULLCOUNT                   (-227) /* argument count is a NULL pointer */
#define NC_EINVAL_CMODE                 (-228) /* Invalid file create mode */
#define NC_ETYPESIZE                    (-229) /* MPI derived data type size error (bigger than the variable size) */
#define NC_ETYPE_MISMATCH               (-230) /* element type of the MPI derived data type mismatches the variable type */
#define NC_ETYPESIZE_MISMATCH           (-231) /* file type size mismatches buffer type size */
#define NC_ESTRICTCDF2                  (-232) /* Attempting CDF-5 operation on CDF-2 file */
#define NC_ENOTRECVAR                   (-233) /* Attempting operation only for record variables */
#define NC_ENOTFILL                     (-234) /* Attempting to fill a variable when its fill mode is off */
#define NC_EINVAL_OMODE                 (-235) /* Invalid file open mode */
#define NC_EPENDING                     (-236) /* Pending nonblocking request is found at file close */
#define NC_EMAX_REQ                     (-237) /* Size of I/O request exceeds INT_MAX */
#define NC_EBADLOG                      (-238) /* Unrecognized log file format */
#define NC_EFLUSHED                     (-239) /* Nonblocking request has already been flushed to the PFS. It is too late to cancel */

/* header inconsistency errors start from -250 */
#define NC_EMULTIDEFINE                 (-250) /* NC definitions on multiprocesses conflict */
#define NC_EMULTIDEFINE_OMODE           (-251) /* inconsistent file open mode */
#define NC_EMULTIDEFINE_DIM_NUM         (-252) /* inconsistent number of dimensions */
#define NC_EMULTIDEFINE_DIM_SIZE        (-253) /* inconsistent size of dimension */
#define NC_EMULTIDEFINE_DIM_NAME        (-254) /* inconsistent dimension names */
#define NC_EMULTIDEFINE_VAR_NUM         (-255) /* inconsistent number of variables */
#define NC_EMULTIDEFINE_VAR_NAME        (-256) /* inconsistent variable name */
#define NC_EMULTIDEFINE_VAR_NDIMS       (-257) /* inconsistent variable's number of dimensions */
#define NC_EMULTIDEFINE_VAR_DIMIDS      (-258) /* inconsistent variable's dimid */
#define NC_EMULTIDEFINE_VAR_TYPE        (-259) /* inconsistent variable's data type */
#define NC_EMULTIDEFINE_VAR_LEN         (-260) /* inconsistent variable's size */
#define NC_EMULTIDEFINE_NUMRECS         (-261) /* inconsistent number of records */
#define NC_EMULTIDEFINE_VAR_BEGIN       (-262) /* inconsistent variable file begin offset (internal use) */
#define NC_EMULTIDEFINE_ATTR_NUM        (-263) /* inconsistent number of attributes */
#define NC_EMULTIDEFINE_ATTR_SIZE       (-264) /* inconsistent memory space used by attribute (internal use) */
#define NC_EMULTIDEFINE_ATTR_NAME       (-265) /* inconsistent attribute name */
#define NC_EMULTIDEFINE_ATTR_TYPE       (-266) /* inconsistent attribute type */
#define NC_EMULTIDEFINE_ATTR_LEN        (-267) /* inconsistent attribute length */
#define NC_EMULTIDEFINE_ATTR_VAL        (-268) /* inconsistent attribute value */
#define NC_EMULTIDEFINE_FNC_ARGS        (-269) /* inconsistent function arguments used in collective API */
#define NC_EMULTIDEFINE_FILL_MODE       (-270) /* inconsistent file fill mode */
#define NC_EMULTIDEFINE_VAR_FILL_MODE   (-271) /* inconsistent variable fill mode */
#define NC_EMULTIDEFINE_VAR_FILL_VALUE  (-272) /* inconsistent variable fill value */
#define NC_EMULTIDEFINE_CMODE           (-273) /* inconsistent file create modes */

@end example

@node Combined Index, CDF-1 file format specification, Error Codes, Top
@unnumbered Index

@printindex cp


@node CDF-1 file format specification, CDF-2 file format specification, Combined Index, Top
@appendix CDF-1 file format specification
@cindex Format, CDF-1
@cindex CDF-1 format specification

We refer "CDF-1" as the identification string, "magic", occupying the first 4
bytes of a netCDF file. The string can be "CDF1", "CDF2", or "CDF5".

CDF-1 and CDF-2 are also referred by the ESDS Community Standard as NetCDF Classic and 64-bit Offset File Formats, respectively.
See @url{https://cdn.earthdata.nasa.gov/conduit/upload/496/ESDS-RFC-011v2.00.pdf, [ESDS-RFC-011v2.0]}

The difference between CDF-1 and CDF-2 is only in the VERSION byte (\x01 vs. \x02) and the OFFSET entity, a 64-bit instead of a 32-bit offset from the beginning of the file. @xref{CDF-2 file format specification} for the detailed specifications of both CDF-1 and CDF-2.


Below is an older version of CDF file format specification used by NetCDF
library through version 3.5.1. It is no longer referred as CDF-1.
Readers are referred to @url{http://www.unidata.ucar.edu/software/netcdf/old_docs/really_old/guide_15.html, [this URL]} for the original specification (copied below).

@heading The Old Format (used by NetCDF library through version 3.5.1)

@example
netcdf_file  := header  data
header       := magic  numrecs  dim_array  gatt_array  var_array
magic        := 'C'  'D'  'F'  VERSION_BYTE
VERSION_BYTE := '\001'    // the file format version number
numrecs      := NON_NEG
dim_array    := ABSENT | NC_DIMENSION  nelems  [dim ...]
gatt_array   := att_array         // global attributes
att_array    := ABSENT | NC_ATTRIBUTE  nelems  [attr ...]
var_array    := ABSENT | NC_VARIABLE   nelems  [var ...]
ABSENT       := ZERO  ZERO        // Means array not present (equivalent to
                                  // nelems == 0).
nelems       := NON_NEG           // number of elements in following sequence
dim          := name  dim_size
name         := string
dim_size     := NON_NEG      // If zero, this is the record dimension.
                             // There can be at most one record dimension.
attr         := name  nc_type  nelems  [values]
nc_type      := NC_BYTE | NC_CHAR | NC_SHORT | NC_LONG | NC_FLOAT | NC_DOUBLE
var          := name  nelems  [dimid ...]  vatt_array  nc_type  vsize  begin
                             // nelems is the rank (dimensionality) of the
                             // variable; 0 for scalar, 1 for vector, 2 for
                             // matrix, ...
vatt_array   := att_array    // variable-specific attributes
dimid        := NON_NEG      // Dimension ID (index into dim_array) for
                             // variable shape.  We say this is a "record
                             // variable" if and only if the first
                             // dimension is the record dimension.
vsize        := NON_NEG      // Variable size.  If not a record variable,
                          // the amount of space, in bytes, allocated to
                          // that variable's data.  This number is the
                          // product of the dimension sizes times the
                          // size of the type, padded to a four byte
                          // boundary.  If a record variable, it is the
                          // amount of space per record.  The netCDF
                          // "record size" is calculated as the sum of
                          // the vsize's of the record variables.
begin    := NON_NEG       // Variable start location.  The offset in
                          // bytes (seek index) in the file of the
                          // beginning of data for this variable.
data     := non_recs  recs
non_recs := [values ...]  // Data for first non-record var, second
                          // non-record var, ...
recs     := [rec ...]     // First record, second record, ...
rec      := [values ...]  // Data for first record variable for record
                          // n, second record variable for record n, ...
                          // See the note below for a special case.
values   := [bytes] | [chars] | [shorts] | [ints] | [floats] | [doubles]
string   := nelems  [chars]
bytes    := [BYTE ...]  padding
chars    := [CHAR ...]  padding
shorts   := [SHORT ...]  padding
ints     := [INT ...]
floats   := [FLOAT ...]
doubles  := [DOUBLE ...]
padding  := <0, 1, 2, or 3 bytes to next 4-byte boundary>
                          // In header, padding is with 0 bytes.  In
                          // data, padding is with variable's fill-value.
NON_NEG  := <INT with non-negative value>
ZERO     := <INT with zero value>
BYTE     := <8-bit byte>
CHAR     := <8-bit ACSII/ISO encoded character>
SHORT    := <16-bit signed integer, Bigendian, two's complement>
INT      := <32-bit signed integer, Bigendian, two's complement>
FLOAT    := <32-bit IEEE single-precision float, Bigendian>
DOUBLE   := <64-bit IEEE double-precision float, Bigendian>
// tags are 32-bit INTs
NC_BYTE      := 1         // data is array of 8 bit signed integer
NC_CHAR      := 2         // data is array of characters, i.e., text
NC_SHORT     := 3         // data is array of 16 bit signed integer
NC_LONG      := 4         // data is array of 32 bit signed integer
NC_FLOAT     := 5         // data is array of IEEE single precision float
NC_DOUBLE    := 6         // data is array of IEEE double precision float
NC_DIMENSION := 10
NC_VARIABLE  := 11
NC_ATTRIBUTE := 12
@end example

@heading Notes on Computing File Offsets

To calculate the offset (position within the file) of a specified data value, let @code{external_sizeof} be the external size in bytes of one data value of the appropriate type for the specified variable, @code{nc_type}:
@example
NC_BYTE         1
NC_CHAR         1
NC_SHORT        2
NC_INT          4
NC_FLOAT        4
NC_DOUBLE       8
@end example
On open() (or endef()), scan through the array of variables, denoted
@code{var_array} above, and sum the @code{vsize} fields of "record"
variables to compute  @code{recsize}.

Form the products of the dimension sizes for the variable from right to
left, skipping the leftmost (record) dimension for record variables, and
storing the results in a  @code{product} array for each variable. For example:
@example
Non-record variable:

        dimension lengths:      [  5  3  2 7]
        product vector:         [210 42 14 7]

Record variable:

        dimension lengths:      [0  2  9 4]
        product vector:         [0 72 36 4]
@end example

At this point, the leftmost product, when rounded up to the next
multiple of 4, is the variable size, @code{vsize}, in the grammar above. For
example, in the non-record variable above, the value of the @code{vsize}
field is 212 (210 rounded up to a multiple of 4). For the record
variable, the value of @code{vsize} is just 72, since this is already a
multiple of 4.

Let coord be the array of coordinates (dimension indices, zero-based)
of the desired data value.  Then the offset of the value from the
beginning of the file is just the file offset of the first data value
of the desired variable (its @code{begin} field) added to the inner product
of the coord and product vectors times the size, in bytes, of each
datum for the variable. Finally, if the variable is a record variable,
the product of the record number, 'coord[0]', and the record size,
@code{recsize}, is added to yield the final offset value.

In pseudo-C code, here's the calculation of @code{offset}:
@example
for (innerProduct = i = 0; i < var.rank; i++)
    innerProduct += product[i] * coord[i]
offset  = var.begin;
offset += external_sizeof * innerProduct
if (IS_RECVAR(var))
    offset += coord[0] * recsize;
@end example
So, to get the data value (in external representation):
@example
lseek(fd, offset, SEEK_SET);
read(fd, buf, external_sizeof);
@end example

@strong{A special case}: Where there is exactly one record variable, we drop
the requirement that each record be four-byte aligned, so in this case
there is no record padding.

@heading Examples

By using the grammar above, we can derive the smallest valid netCDF
file, having no dimensions, no variables, no attributes, and hence, no
data. A CDL representation of the empty netCDF file is

@example
netcdf empty @{ @}
@end example

This empty netCDF file has 32 bytes. It begins with the four-byte
``magic number'' that identifies it as a netCDF version 1 file:
@samp{C}, @samp{D}, @samp{F}, @samp{\x01}. Following are seven 32-bit
integer zeros representing the number of records, an empty list of
dimensions, an empty list of global attributes, and an empty list of
variables.

Below is an (edited) dump of the file produced using the Unix command

@example
od -xcs empty.nc
@end example

Each 16-byte portion of the file is displayed with 4 lines. The first
line displays the bytes in hexadecimal. The second line displays the
bytes as characters. The third line displays each group of two
bytes interpreted as a signed 16-bit integer. The fourth line (added
by human) presents the interpretation of the bytes in terms of netCDF
components and values.

@example
   4344    4601    0000    0000    0000    0000    0000    0000
  C   D   F 001  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0
  17220   17921   00000   00000   00000   00000   00000   00000
[magic number ] [  0 records  ] [  0 dimensions   (ABSENT)    ]

   0000    0000    0000    0000    0000    0000    0000    0000
 \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0
  00000   00000   00000   00000   00000   00000   00000   00000
[  0 global atts  (ABSENT)    ] [  0 variables    (ABSENT)    ]
@end example

As a less trivial example, consider the CDL

@example
netcdf tiny @{
dimensions:
        dim = 5;
variables:
        short vx(dim);
data:
        vx = 3, 1, 4, 1, 5 ;
@}
@end example

which corresponds to a 92-byte netCDF file. The following is an edited
dump of this file:

@example
   4344    4601    0000    0000    0000    000a    0000    0001
  C   D   F 001  \0  \0  \0  \0  \0  \0  \0  \n  \0  \0  \0 001
  17220   17921   00000   00000   00000   00010   00000   00001
[magic number ] [  0 records  ] [NC_DIMENSION ] [ 1 dimension ]

   0000    0003    6469    6d00    0000    0005    0000    0000
 \0  \0  \0 003   d   i   m  \0  \0  \0  \0 005  \0  \0  \0  \0
  00000   00003   25705   27904   00000   00005   00000   00000
[  3 char name = "dim"        ] [ size = 5    ] [ 0 global atts

   0000    0000    0000    000b    0000    0001    0000    0002
 \0  \0  \0  \0  \0  \0  \0 013  \0  \0  \0 001  \0  \0  \0 002
  00000   00000   00000   00011   00000   00001   00000   00002
 (ABSENT)     ] [NC_VARIABLE  ] [ 1 variable  ] [ 2 char name =

   7678    0000    0000    0001    0000    0000    0000    0000
  v   x  \0  \0  \0  \0  \0 001  \0  \0  \0  \0  \0  \0  \0  \0
  30328   00000   00000   00001   00000   00000   00000   00000
 "vx"         ] [1 dimension  ] [ with ID 0   ] [ 0 attributes

   0000    0000    0000    0003    0000    000c    0000    0050
 \0  \0  \0  \0  \0  \0  \0 003  \0  \0  \0  \f  \0  \0  \0   P
  00000   00000   00000   00003   00000   00012   00000   00080
 (ABSENT)     ] [type NC_SHORT] [size 12 bytes] [offset:    80]

   0003    0001    0004    0001    0005    8001
 \0 003  \0 001  \0 004  \0 001  \0 005 200 001
  00003   00001   00004   00001   00005  -32767
[    3] [    1] [    4] [    1] [    5] [fill ]
@end example

@node CDF-2 file format specification, CDF-5 file format specification, CDF-1 file format specification, Top
@appendix CDF-2 file format specification
@cindex Format, CDF-2
@cindex CDF-2 format specification

The netCDF 64-bit offset format differs from the classic format
only in
@itemize
@item the VERSION byte, @samp{\x02} instead of @samp{\x01}, and
@item the OFFSET entity, a 64-bit instead of a 32-bit offset from the beginning of the file.
@end itemize
 This small format change permits much larger files, but there
are still some practical size restrictions.  Each fixed-size variable
and the data for one record's worth of each record variable are still
limited in size to a little less that 4 GiB.  The rationale for this
limitation is to permit aggregate access to all the data in a netCDF
variable (or a record's worth of data) on 32-bit platforms.


@html
The specification of CDF classic file format (referred as CDF-1) is shown in  black font.<br/>
The new features added in <span style="color:red">CDF-2</span> specification are colored in <span style="color:red">red.</span> CDF-2 backward supports all specification of CDF-1.<br/>

(Note that "\x" used in this specification indicates the next two characters represent hexadecimal digits. Two hexadecimal digits, each of them 4 bits, make a byte.)
<hr>

<tt>
<table>
<tr><td>netcdf_file</td><td>=</td><td>header data</td><td></td></tr>
<tr><td>header</td><td>=</td><td>magic numrecs dim_list gatt_list var_list</td><td></td></tr>
<tr><td>magic</td><td>=</td><td>'C' 'D' 'F' VERSION</td><td></td></tr>
<tr><td>VERSION</td><td>=</td><td>\x01 |</td><td>//classic format (CDF-1)</td></tr>
<tr style="color:red"><td></td><td></td><td>\x02</td><td>//64-bit offset format (CDF-2)</td></tr>
<tr><td>numrecs</td><td>=</td><td>NON_NEG | STREAMING</td><td>//length of record dimension</td></tr>
<tr><td>dim_list</td><td>=</td><td>ABSENT | NC_DIMENSION nelems [dim ...]</td><td></td></tr>
<tr><td>gatt_list</td><td>=</td><td>att_list</td><td>//global attributes</td><td></td></tr>
<tr><td>att_list</td><td>=</td><td>ABSENT | NC_ATTRIBUTE nelems [attr ...]</td><td></td></tr>
<tr><td>var_list</td><td>=</td><td>ABSENT | NC_VARIABLE nelems [var ...]</td><td></td></tr>
<tr><td>ABSENT</td><td>=</td><td>ZERO ZERO</td><td>//list is not present (CDF-1 and <span style="color:red">CDF-2</span>)</td></tr>
<tr><td>ZERO</td><td>=</td><td>\x00 \x00 \x00 \x00</td><td>//32-bit zero</td></tr>
<tr><td>NC_DIMENSION</td><td>=</td><td>\x00 \x00 \x00 \x0A</td><td>//tag for list of dimensions</td></tr>
<tr><td>NC_VARIABLE</td><td>=</td><td>\x00 \x00 \x00 \x0B</td><td>//tag for list of variables</td></tr>
<tr><td>NC_ATTRIBUTE</td><td>=</td><td>\x00 \x00 \x00 \x0C</td><td>//tag for list of attributes</td></tr>
<tr><td>nelems</td><td>=</td><td>NON_NEG</td><td>//number of elements in following sequence</td></tr>
<tr><td>dim</td><td>=</td><td>name dim_length</td><td></td></tr>
<tr><td>name</td><td>=</td><td>nelems namestring</td><td></td></tr>
<tr><td></td><td></td><td></td><td>//Names a dimension, variable, or attribute.</td></tr>
<tr><td></td><td></td><td></td><td>//Names should match the regular expression</td></tr>
<tr><td></td><td></td><td></td><td style="white-space:nowrap;">//([a-zA-Z0-9_]|@{MUTF8@})([^\x00-\x1F/\x7F-\xFF]|@{MUTF8@})*</td></tr>
<tr><td></td><td></td><td></td><td>//For other constraints, see <a href=#NOTENAMES>"Note on names"</a> below.</td></tr>
<tr><td>namestring</td><td>=</td><td>ID1 [IDN ...] padding</td><td></td></tr>
<tr><td>ID1</td><td>=</td><td>alphanumeric | '_'</td><td></td></tr>
<tr ><td>IDN</td><td>=</td><td>alphanumeric | special1 | special2</td><td></td></tr>
<tr><td>alphanumeric</td><td>=</td><td>lowercase | uppercase | numeric | MUTF8</td><td></td></tr>
<tr><td>lowercase</td><td>=</td><td style="white-space:nowrap;">'a'|'b'|'c'|'d'|'e'|'f'|'g'|'h'|'i'|'j'|'k'|'l'|'m'|</td><td></td></tr>
<tr><td></td><td></td><td>'n'|'o'|'p'|'q'|'r'|'s'|'t'|'u'|'v'|'w'|'x'|'y'|'z'</td><td></td></tr>
<tr><td>uppercase</td><td>=</td><td>'A'|'B'|'C'|'D'|'E'|'F'|'G'|'H'|'I'|'J'|'K'|'L'|'M'|</td><td></td></tr>
<tr><td></td><td></td><td>'N'|'O'|'P'|'Q'|'R'|'S'|'T'|'U'|'V'|'W'|'X'|'Y'|'Z'</td><td></td></tr>
<tr><td>numeric</td><td>=</td><td>'0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'</td><td></td></tr>
<tr><td>special1</td><td>=</td><td>'_'|'.'|'@'|'+'|'-'</td><td>//special1 chars have traditionally been</td></tr>
<tr><td></td><td></td><td></td><td>//permitted in CDF-1.</td></tr>
<tr><td>special2</td><td>=</td><td>' ' | '!' | '"' | '#'&nbsp; | '$' | '%' | '&#38;' | '\'' |</td><td>//special2 chars are recently permitted in</td></tr>
<tr><td></td><td></td><td>'(' | ')' | '*' | ','&nbsp; | ':' | ';' | '&#60;' | '=' &nbsp;|</td><td>//names (and require escaping in CDL).</td></tr>
<tr><td></td><td></td><td>'&#62;' | '?' | '[' | '\\' | ']' | '^' | '`' | '@{' &nbsp;|</td><td>//Note: '/' is not permitted.</td></tr>
<tr><td></td><td></td><td>'|' | '@}' | '~'</td><td></td></tr>
<tr><td>MUTF8</td><td>=</td><td style="white-space:nowrap;">&#60;multibyte UTF-8 encoded&#62;</td><td>//NFC-normalized Unicode character</td></tr>
<tr><td>dim_length</td><td>=</td><td>NON_NEG</td><td>//If zero, this is the record dimension.</td></tr>
<tr><td></td><td></td><td></td><td>//There can be at most one record dimension.</td></tr>
<tr><td>attr</td><td>=</td><td>name nc_type nelems [values ...]</td><td></td></tr>
<tr><td>nc_type</td><td>=</td><td>NC_BYTE &nbsp;&nbsp;|</td><td></td></tr>
<tr><td></td><td></td><td>NC_CHAR &nbsp;&nbsp;|</td><td></td></tr>
<tr><td></td><td></td><td>NC_SHORT &nbsp;|</td><td></td></tr>
<tr><td></td><td></td><td>NC_INT &nbsp;&nbsp;&nbsp;|</td><td></td></tr>
<tr><td></td><td></td><td>NC_FLOAT &nbsp;|</td><td></td></tr>
<tr><td></td><td></td><td>NC_DOUBLE</td><td></td></tr>
<tr><td>var</td><td>=</td><td style="white-space:nowrap;">name nelems [dimid ...] vatt_list nc_type vsize begin</td><td></td></tr>
<tr><td></td><td></td><td></td><td>//nelems is the dimensionality (rank) of the variable</td></tr>
<tr><td></td><td></td><td></td><td>//0 for scalar, 1 for vector, 2 for matrix, ...</td></tr>
<tr><td>dimid</td><td>=</td><td>NON_NEG</td><td>//Dimension ID (index into dim_list) for variable</td></tr>
<tr><td></td><td></td><td></td><td>//shape. We say this is a "record variable" if and only</td></tr>
<tr><td></td><td></td><td></td><td>//if the first dimension is the record dimension.</td></tr>
<tr><td>vatt_list</td><td>=</td><td>att_list</td><td>//Variable-specific attributes</td></tr>
<tr><td>vsize</td><td>=</td><td>NON_NEG</td><td>//Variable size. If not a record variable, the amount</td></tr>
<tr><td></td><td></td><td></td><td>//of space in bytes allocated to the variable's data.</td></tr>
<tr><td></td><td></td><td></td><td>//For record variables, it is the amount of space per</td></tr>
<tr><td></td><td></td><td></td><td>//record. See <a href=#NOTEVSIZE>"Note on vsize"</a>, below.</td></tr>
<tr><td>begin</td><td>=</td><td>OFFSET</td><td>//Variable start location. The offset in bytes (seek</td></tr>
<tr><td></td><td></td><td></td><td>//index) in the file of the beginning of data for this.</td></tr>
<tr><td></td><td></td><td></td><td>//variable.</td></tr>
<tr><td>data</td><td>=</td><td>non_recs recs</td><td></td></tr>
<tr><td>non_recs</td><td>=</td><td>[vardata ...]</td><td>//The data for all non-record variables, stored</td></tr>
<tr><td></td><td></td><td></td><td>//contiguously for each variable, in the same order the</td></tr>
<tr><td></td><td></td><td></td><td>//variables occur in the header.</td></tr>
<tr><td>vardata</td><td>=</td><td>[values ...]</td><td>//All data for a non-record variable, as a block of</td></tr>
<tr><td></td><td></td><td></td><td>//values of the same type as the variable, in row-major</td></tr>
<tr><td></td><td></td><td></td><td>//order (last dimension varying fastest).</td></tr>
<tr><td>recs</td><td>=</td><td>[record ...]</td><td>//The data for all record variables are stored</td></tr>
<tr><td></td><td></td><td></td><td>//interleaved at the end of the file.</td></tr>
<tr><td>record</td><td>=</td><td>[varslab ...]</td><td>//Each record consists of the n-th slab from each</td></tr>
<tr><td></td><td></td><td></td><td>//record variable, for example x[n,...], y[n,...],</td></tr>
<tr><td></td><td></td><td></td><td>//z[n,...] where the first index is the record number,</td></tr>
<tr><td></td><td></td><td></td><td>//which is the unlimited dimension index.</td></tr>
<tr><td>varslab</td><td>=</td><td>[values ...]</td><td>//One record of data for a variable, a block of values</td></tr>
<tr><td></td><td></td><td></td><td>//all of the same type as the variable in row-major</td></tr>
<tr><td></td><td></td><td></td><td>//order (last index varying fastest).</td></tr>
<tr><td>values</td><td>=</td><td>bytes | chars | shorts | ints | floats | doubles</td><td></td></tr>
<tr><td>string</td><td>=</td><td>nelems [chars]</td><td></td></tr>
<tr><td>bytes</td><td>=</td><td>[BYTE ...] padding</td><td></td></tr>
<tr><td>chars</td><td>=</td><td>[CHAR ...] padding</td><td></td></tr>
<tr><td>shorts</td><td>=</td><td>[SHORT ...] padding</td><td></td></tr>
<tr><td>ints</td><td>=</td><td>[INT ...]</td><td></td></tr>
<tr><td>floats</td><td>=</td><td>[FLOAT ...]</td><td></td></tr>
<tr><td>doubles</td><td>=</td><td>[DOUBLE ...]</td><td></td></tr>
<tr><td>padding</td><td>=</td><td>&#60;0, 1, 2, or 3 bytes to next 4-byte boundary&#62;</td><td></td></tr>
<tr><td></td><td></td><td></td><td>//Header padding uses null (\x00) bytes. In data, padding</td></tr>
<tr><td></td><td></td><td></td><td>//uses variable's fill value. See <a href=#NOTEPADDING>"Note on padding"</a> below</td></tr>
<tr><td></td><td></td><td></td><td>//for a special case.</td></tr>
<tr><td>NON_NEG</td><td>=</td><td>&#60;non-negative INT&#62;</td><td></td></tr>
<tr><td>STREAMING</td><td>=</td><td>\xFF \xFF \xFF \xFF</td><td>//Indicates indeterminate record count, allows streaming</td></tr>
<tr><td></td><td></td><td></td><td>//data</td></tr>
<tr><td>OFFSET</td><td>=</td><td>&#60;non-negative INT&#62; |</td><td>//for classic format (CDF-1)</td></tr>
<tr style="color:red"><td></td><td></td><td>&#60;non-negative INT64&#62;</td><td>//for CDF-2 format</td></tr>
<tr><td>BYTE</td><td>=</td><td>&#60;8-bit byte&#62;</td><td>//See <a href=#NOTEBYTE>"Note on byte data"</a> below.</td></tr>
<tr><td>CHAR</td><td>=</td><td>&#60;8-bit byte&#62;</td><td>//See <a href=#NOTECHAR>"Note on char data"</a> below.</td></tr>
<tr><td>SHORT</td><td>=</td><td style="white-space:nowrap;">&#60;16-bit signed integer, Bigendian, two's complement&#62;</td><td></td></tr>
<tr><td>INT</td><td>=</td><td style="white-space:nowrap;">&#60;32-bit signed integer, Bigendian, two's complement&#62;</td><td></td></tr>
<tr style="color:red"><td>INT64</td><td>=</td><td style="white-space:nowrap;">&#60;64-bit signed integer, Bigendian, two's complement&#62;</td><td></td></tr>
<tr><td>FLOAT</td><td>=</td><td style="white-space:nowrap;">&#60;32-bit IEEE single-precision float, Bigendian&#62;</td><td></td></tr>
<tr><td>DOUBLE</td><td>=</td><td>&#60;64-bit IEEE double-precision float, Bigendian&#62;</td><td></td></tr>
</td></tr>
<tr><td></td><td></td><td></td><td>//following type tags are 32-bit integers</td></tr>
<tr><td>NC_BYTE</td><td>=</td><td>\x00 \x00 \x00 \x01</td><td>//8-bit signed integers</td></tr>
<tr><td>NC_CHAR</td><td>=</td><td>\x00 \x00 \x00 \x02</td><td>//text characters</td></tr>
<tr><td>NC_SHORT</td><td>=</td><td>\x00 \x00 \x00 \x03</td><td>//16-bit signed integers</td></tr>
<tr><td>NC_INT</td><td>=</td><td>\x00 \x00 \x00 \x04</td><td>//32-bit signed integers</td></tr>
<tr><td>NC_FLOAT</td><td>=</td><td>\x00 \x00 \x00 \x05</td><td>//IEEE single precision floats</td></tr>
<tr><td>NC_DOUBLE</td><td>=</td><td>\x00 \x00 \x00 \x06</td><td>//IEEE double precision floats</td></tr>
</td></tr>
<tr><td></td><td></td><td></td><td>//Default fill values for each type, may be overridden by</td></tr>
<tr><td></td><td></td><td></td><td>//variable attribute named `_FillValue'. See</td></tr>
<tr><td></td><td></td><td></td><td>//<a href=#NOTEFILL>"Note on fill values"</a> below.</td></tr>
<tr><td>FILL_CHAR</td><td>=</td><td>\x00</td><td>//((char)0) null byte</td></tr>
<tr><td>FILL_BYTE</td><td>=</td><td>\x81</td><td>//(signed char) -127</td></tr>
<tr><td>FILL_SHORT</td><td>=</td><td>\x80 \x01</td><td>//(short) -32767</td></tr>
<tr><td>FILL_INT</td><td>=</td><td>\x80 \x00 \x00 \x01</td><td>//(int) -2147483647</td></tr>
<tr><td>FILL_FLOAT</td><td>=</td><td>\x7C \xF0 \x00 \x00</td><td>//(float) 9.9692099683868690e+36</td></tr>
<tr><td>FILL_DOUBLE</td><td>=</td><td>\x47 \x9E \x00 \x00 \x00 \x00 \x00 \x00</td><td>//(double)9.9692099683868690e+36</td></tr>
</table>
</tt>
<hr>
@end html

@strong{Note on} @code{vsize}:@anchor{NOTEVSIZE}
This number is the product of the dimension lengths
(omitting the record dimension) and the number of bytes per value
(determined from the type), increased to the next multiple of 4, for
each variable.  If a record variable, this is the amount of space per
record (except that, for backward compatibility, it always includes
padding to the next multiple of 4 bytes, even in the exceptional case
noted below under ``Note on padding'').  The netCDF ``record size'' is
calculated as the sum of the @code{vsize}'s of all the record variables.

The @code{vsize} field is actually redundant, because its value may be
computed from other information in the header. The 32-bit @code{vsize} field
is not large enough to contain the size of variables that require more
than @math{2^32 - 4} bytes, so @math{2^32 - 1} is used in the @code{vsize} field for such
variables.

@strong{Note on names:}@anchor{NOTENAMES}
Earlier versions of the netCDF C-library reference
implementation enforced a more restricted set of characters in
creating new names, but permitted reading names containing arbitrary
bytes.  This specification extends the permitted characters in names
to include multi-byte UTF-8 encoded Unicode and additional printing
characters from the US-ASCII alphabet. The first character of a name
must be alphanumeric, a multi-byte UTF-8 character, or '_'
(reserved for special names with meaning to implementations,
such as the ``_FillValue'' attribute).  Subsequent characters may also
include printing special characters, except for '/' which is not
allowed in names.  Names that have trailing space characters are also
not permitted.

Implementations of the netCDF classic and 64-bit offset format must
ensure that names are normalized according to Unicode NFC
normalization rules during encoding as UTF-8 for storing in the file
header.  This is necessary to ensure that gratuitous differences in
the representation of Unicode names do not cause anomalies in
comparing files and querying data objects by name.

@strong{Note on streaming data:}@anchor{NOTESTREAMING}
The largest possible record count, @math{2^32 - 1}, is reserved to indicate an indeterminate number of records.
This means that the number of records in the file must be determined
by other means, such as reading them or computing the current number
of records from the file length and other information in the header.
It also means that the numrecs field in the header will not be updated
as records are added to the file.  [This feature is not yet
implemented].

@strong{Note on padding:}@anchor{NOTEPADDING}
 In the special case when there is only one record
variable and it is of type character, byte, or short, no padding is
used between record slabs, so records after the first record do not
necessarily start on four-byte boundaries.  However, as noted above
under ``Note on @code{vsize}'', the @code{vsize} field is computed to
include padding to the next multiple of 4 bytes.  In this case,
readers should ignore @code{vsize} and assume no padding.  Writers
should store @code{vsize} as if padding were included.

@strong{Note on byte data:}@anchor{NOTEBYTE}
It is possible to interpret byte data as either
signed (-128 to 127) or unsigned (0 to 255). When reading byte data
through an interface that converts it into another numeric type, the
default interpretation is signed.  There are various attribute
conventions for specifying whether bytes represent signed or unsigned
data, but no standard convention has been established.  The variable
attribute ``_Unsigned'' is reserved for this purpose in future
implementations.

@strong{Note on char data:}@anchor{NOTECHAR}
Although the characters used in netCDF names must
be encoded as UTF-8, character data may use other encodings. The
variable attribute ``_Encoding'' is reserved for this purpose in future
implementations.

@strong{Note on fill values:}@anchor{NOTEFILL}
Because data variables may be created before
their values are written, and because values need not be written
sequentially in a netCDF file, default ``fill values'' are defined for
each type, for initializing data values before they are explicitly
written.  This makes it possible to detect reading values that were
never written.  The variable attribute ``_FillValue'', if present,
overrides the default fill value for a variable. If _FillValue is
defined then it should be scalar and of the same type as the variable.

Fill values are not required, however, because netCDF libraries have
traditionally supported a ``no fill'' mode when writing, omitting the
initialization of variable values with fill values. This makes the
creation of large files faster, but also eliminates the possibility of
detecting the inadvertent reading of values that haven't been written.

@heading Notes on Computing File Offsets

The offset (position within the file) of a specified data value in a
classic format or 64-bit offset data file is completely determined by
the variable start location (the offset in the @code{begin} field), the
external type of the variable (the @code{nc_type} field), and the
dimension indices (one for each of the variable's dimensions) of the
value desired.

The external size in bytes of one data value for each possible
netCDF type, denoted @code{extsize} below, is:

@multitable @columnfractions .01 .10
@item @code{NC_BYTE}
@tab 1
@item @code{NC_CHAR}
@tab 1
@item @code{NC_SHORT}
@tab 2
@item @code{NC_INT}
@tab 4
@item @code{NC_FLOAT}
@tab 4
@item @code{NC_DOUBLE}
@tab 8
@end multitable

The record size, denoted by @code{recsize} below, is the sum of the @code{vsize}
fields of record variables (variables that use the unlimited
dimension), using the actual value determined by dimension sizes and
variable type in case the @code{vsize} field is too small for the variable
size.

To compute the offset of a value relative to the beginning of a
variable, it is helpful to precompute a ``product vector'' from the
dimension lengths.  Form the products of the dimension lengths for the
variable from right to left, skipping the leftmost (record) dimension
for record variables, and storing the results as the product vector
for each variable.

For example:
@example
Non-record variable:

        dimension lengths:      [  5  3  2 7]
        product vector:         [210 42 14 7]

Record variable:

        dimension lengths:      [0  2  9 4]
        product vector:         [0 72 36 4]
@end example
At this point, the leftmost product, when rounded up to the next
multiple of 4, is the variable size, @code{vsize}, in the grammar above. For
example, in the non-record variable above, the value of the @code{vsize}
field is 212 (210 rounded up to a multiple of 4). For the record
variable, the value of @code{vsize} is just 72, since this is already a
multiple of 4.

Let coord be the array of coordinates (dimension indices, zero-based)
of the desired data value.  Then the offset of the value from the
beginning of the file is just the file offset of the first data value
of the desired variable (its @code{begin} field) added to the inner product
of the coord and product vectors times the size, in bytes, of each
datum for the variable. Finally, if the variable is a record variable,
the product of the record number, 'coord[0]', and the record size,
@code{recsize}, is added to yield the final offset value.

A special case: Where there is exactly one record variable, we drop
the requirement that each record be four-byte aligned, so in this case
there is no record padding.

@heading Examples

By using the grammar above, we can derive the smallest valid netCDF
file, having no dimensions, no variables, no attributes, and hence, no
data. A CDL representation of the empty netCDF file is
@example
netcdf empty @{ @}
@end example
This empty netCDF file has 32 bytes. It begins with the four-byte
``magic number'' that identifies it as a netCDF version 1 file:
@samp{C}, @samp{D}, @samp{F}, @samp{\x01}. Following are seven 32-bit
integer zeros representing the number of records, an empty list of
dimensions, an empty list of global attributes, and an empty list of
variables.

Below is an (edited) dump of the file produced using the Unix command
@example
od -xcs empty.nc
@end example
Each 16-byte portion of the file is displayed with 4 lines. The first
line displays the bytes in hexadecimal. The second line displays the
bytes as characters. The third line displays each group of two
bytes interpreted as a signed 16-bit integer. The fourth line (added
by human) presents the interpretation of the bytes in terms of netCDF
components and values.

@example
   4344    4601    0000    0000    0000    0000    0000    0000
  C   D   F 001  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0
  17220   17921   00000   00000   00000   00000   00000   00000
[magic number ] [  0 records  ] [  0 dimensions   (ABSENT)    ]

   0000    0000    0000    0000    0000    0000    0000    0000
 \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0
  00000   00000   00000   00000   00000   00000   00000   00000
[  0 global atts  (ABSENT)    ] [  0 variables    (ABSENT)    ]
@end example

As a less trivial example, consider the CDL

@example
netcdf tiny @{
dimensions:
        dim = 5;
variables:
        short vx(dim);
data:
        vx = 3, 1, 4, 1, 5 ;
@}
@end example

which corresponds to a 92-byte netCDF file. The following is an edited
dump of this file:

@example
   4344    4601    0000    0000    0000    000a    0000    0001
  C   D   F 001  \0  \0  \0  \0  \0  \0  \0  \n  \0  \0  \0 001
  17220   17921   00000   00000   00000   00010   00000   00001
[magic number ] [  0 records  ] [NC_DIMENSION ] [ 1 dimension ]

   0000    0003    6469    6d00    0000    0005    0000    0000
 \0  \0  \0 003   d   i   m  \0  \0  \0  \0 005  \0  \0  \0  \0
  00000   00003   25705   27904   00000   00005   00000   00000
[  3 char name = "dim"        ] [ size = 5    ] [ 0 global atts

   0000    0000    0000    000b    0000    0001    0000    0002
 \0  \0  \0  \0  \0  \0  \0 013  \0  \0  \0 001  \0  \0  \0 002
  00000   00000   00000   00011   00000   00001   00000   00002
 (ABSENT)     ] [NC_VARIABLE  ] [ 1 variable  ] [ 2 char name =

   7678    0000    0000    0001    0000    0000    0000    0000
  v   x  \0  \0  \0  \0  \0 001  \0  \0  \0  \0  \0  \0  \0  \0
  30328   00000   00000   00001   00000   00000   00000   00000
 "vx"         ] [1 dimension  ] [ with ID 0   ] [ 0 attributes

   0000    0000    0000    0003    0000    000c    0000    0050
 \0  \0  \0  \0  \0  \0  \0 003  \0  \0  \0  \f  \0  \0  \0   P
  00000   00000   00000   00003   00000   00012   00000   00080
 (ABSENT)     ] [type NC_SHORT] [size 12 bytes] [offset:    80]

   0003    0001    0004    0001    0005    8001
 \0 003  \0 001  \0 004  \0 001  \0 005 200 001
  00003   00001   00004   00001   00005  -32767
[    3] [    1] [    4] [    1] [    5] [fill ]
@end example


@node CDF-5 file format specification, , CDF-2 file format specification, Top
@appendix CDF-5 file format specification
@cindex Format, CDF-5
@cindex CDF-5 format specification

@html
The specification of CDF classic file format (referred as CDF-1) is shown in  black font.<br/>
The new features added in <span style="color:red">CDF-2</span> specification are colored in <span style="color:red">red.</span> CDF-2 backward supports all specification of CDF-1.<br/>
The new features added in <span style="color:blue">CDF-5</span> specification are colored in <span style="color:blue">blue.</span> CDF-5 backward supports all specification of CDF-2.<br/>

(Note that "\x" used in this specification indicates the next two characters represent hexadecimal digits. Two hexadecimal digits, each of them 4 bits, make a byte.)
<hr>

<tt>
<table>
<tr><td>netcdf_file</td><td>=</td><td>header data</td><td></td></tr>
<tr><td>header</td><td>=</td><td>magic numrecs dim_list gatt_list var_list</td><td></td></tr>
<tr><td>magic</td><td>=</td><td>'C' 'D' 'F' VERSION</td><td></td></tr>
<tr><td>VERSION</td><td>=</td><td>\x01 |</td><td>//classic format (CDF-1)</td></tr>
<tr style="color:red"><td></td><td></td><td>\x02 |</td><td>//64-bit offset format (CDF-2)</td></tr>
<tr style="color:blue"><td></td><td></td><td>\x05</td><td>//64-bit data format (CDF-5)</td></tr>
<tr><td>numrecs</td><td>=</td><td>NON_NEG | STREAMING</td><td>//length of record dimension</td></tr>
<tr><td>dim_list</td><td>=</td><td>ABSENT | NC_DIMENSION nelems [dim ...]</td><td></td></tr>
<tr><td>gatt_list</td><td>=</td><td>att_list</td><td>//global attributes</td><td></td></tr>
<tr><td>att_list</td><td>=</td><td>ABSENT | NC_ATTRIBUTE nelems [attr ...]</td><td></td></tr>
<tr><td>var_list</td><td>=</td><td>ABSENT | NC_VARIABLE nelems [var ...]</td><td></td></tr>
<tr><td>ABSENT</td><td>=</td><td>ZERO ZERO |</td><td>//list is not present (CDF-1 and <span style="color:red">CDF-2</span>)</td></tr>
<tr><td></td><td></td><td>ZERO <span style="color:blue">ZERO64</span></td><td>//list is not present (<span style="color:blue">CDF-5</span>)</td></tr>
<tr><td>ZERO</td><td>=</td><td>\x00 \x00 \x00 \x00</td><td>//32-bit zero</td></tr>
<tr style="color:blue"><td>ZERO64</td><td>=</td><td>\x00 \x00 \x00 \x00 \x00 \x00 \x00 \x00</td><td>//64-bit zero (CDF-5)</td></tr>
<tr><td>NC_DIMENSION</td><td>=</td><td>\x00 \x00 \x00 \x0A</td><td>//tag for list of dimensions</td></tr>
<tr><td>NC_VARIABLE</td><td>=</td><td>\x00 \x00 \x00 \x0B</td><td>//tag for list of variables</td></tr>
<tr><td>NC_ATTRIBUTE</td><td>=</td><td>\x00 \x00 \x00 \x0C</td><td>//tag for list of attributes</td></tr>
<tr><td>nelems</td><td>=</td><td>NON_NEG</td><td>//number of elements in following sequence</td></tr>
<tr><td>dim</td><td>=</td><td>name dim_length</td><td></td></tr>
<tr><td>name</td><td>=</td><td>nelems namestring</td><td></td></tr>
<tr><td></td><td></td><td></td><td>//Names a dimension, variable, or attribute.</td></tr>
<tr><td></td><td></td><td></td><td>//Names should match the regular expression</td></tr>
<tr><td></td><td></td><td></td><td style="white-space:nowrap;">//([a-zA-Z0-9_]|@{MUTF8@})([^\x00-\x1F/\x7F-\xFF]|@{MUTF8@})*</td></tr>
<tr><td></td><td></td><td></td><td>//For other constraints, see <a href=#NOTENAMES5>"Note on names"</a> below.</td></tr>
<tr><td>namestring</td><td>=</td><td>ID1 [IDN ...] padding</td><td></td></tr>
<tr><td>ID1</td><td>=</td><td>alphanumeric | '_'</td><td></td></tr>
<tr ><td>IDN</td><td>=</td><td>alphanumeric | special1 | special2</td><td></td></tr>
<tr><td>alphanumeric</td><td>=</td><td>lowercase | uppercase | numeric | MUTF8</td><td></td></tr>
<tr><td>lowercase</td><td>=</td><td style="white-space:nowrap;">'a'|'b'|'c'|'d'|'e'|'f'|'g'|'h'|'i'|'j'|'k'|'l'|'m'|</td><td></td></tr>
<tr><td></td><td></td><td>'n'|'o'|'p'|'q'|'r'|'s'|'t'|'u'|'v'|'w'|'x'|'y'|'z'</td><td></td></tr>
<tr><td>uppercase</td><td>=</td><td>'A'|'B'|'C'|'D'|'E'|'F'|'G'|'H'|'I'|'J'|'K'|'L'|'M'|</td><td></td></tr>
<tr><td></td><td></td><td>'N'|'O'|'P'|'Q'|'R'|'S'|'T'|'U'|'V'|'W'|'X'|'Y'|'Z'</td><td></td></tr>
<tr><td>numeric</td><td>=</td><td>'0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'</td><td></td></tr>
<tr><td>special1</td><td>=</td><td>'_'|'.'|'@'|'+'|'-'</td><td>//special1 chars have traditionally been</td></tr>
<tr><td></td><td></td><td></td><td>//permitted in CDF-1.</td></tr>
<tr><td>special2</td><td>=</td><td>' ' | '!' | '"' | '#'&nbsp; | '$' | '%' | '&#38;' | '\'' |</td><td>//special2 chars are recently permitted in</td></tr>
<tr><td></td><td></td><td>'(' | ')' | '*' | ','&nbsp; | ':' | ';' | '&#60;' | '=' &nbsp;|</td><td>//names (and require escaping in CDL).</td></tr>
<tr><td></td><td></td><td>'&#62;' | '?' | '[' | '\\' | ']' | '^' | '`' | '@{' &nbsp;|</td><td>//Note: '/' is not permitted.</td></tr>
<tr><td></td><td></td><td>'|' | '@}' | '~'</td><td></td></tr>
<tr><td>MUTF8</td><td>=</td><td style="white-space:nowrap;">&#60;multibyte UTF-8 encoded&#62;</td><td>//NFC-normalized Unicode character</td></tr>
<tr><td>dim_length</td><td>=</td><td>NON_NEG</td><td>//If zero, this is the record dimension.</td></tr>
<tr><td></td><td></td><td></td><td>//There can be at most one record dimension.</td></tr>
<tr><td>attr</td><td>=</td><td>name nc_type nelems [values ...]</td><td></td></tr>
<tr><td>nc_type</td><td>=</td><td>NC_BYTE &nbsp;&nbsp;|</td><td></td></tr>
<tr><td></td><td></td><td>NC_CHAR &nbsp;&nbsp;|</td><td></td></tr>
<tr><td></td><td></td><td>NC_SHORT &nbsp;|</td><td></td></tr>
<tr><td></td><td></td><td>NC_INT &nbsp;&nbsp;&nbsp;|</td><td></td></tr>
<tr><td></td><td></td><td>NC_FLOAT &nbsp;|</td><td></td></tr>
<tr><td></td><td></td><td>NC_DOUBLE |</td><td></td></tr>
<tr><td></td><td></td><td style="color:blue">NC_UBYTE &nbsp;|</td><td></td></tr>
<tr><td></td><td></td><td style="color:blue">NC_USHORT |</td><td></td></tr>
<tr><td></td><td></td><td style="color:blue">NC_UINT &nbsp;&nbsp;|</td><td></td></tr>
<tr><td></td><td></td><td style="color:blue">NC_INT64 &nbsp;|</td><td></td></tr>
<tr><td></td><td></td><td style="color:blue">NC_UINT64</td><td></td></tr>
<tr><td>var</td><td>=</td><td style="white-space:nowrap;">name nelems [dimid ...] vatt_list nc_type vsize begin</td><td></td></tr>
<tr><td></td><td></td><td></td><td>//nelems is the dimensionality (rank) of the variable</td></tr>
<tr><td></td><td></td><td></td><td>//0 for scalar, 1 for vector, 2 for matrix, ...</td></tr>
<tr><td>dimid</td><td>=</td><td>NON_NEG</td><td>//Dimension ID (index into dim_list) for variable</td></tr>
<tr><td></td><td></td><td></td><td>//shape. We say this is a "record variable" if and only</td></tr>
<tr><td></td><td></td><td></td><td>//if the first dimension is the record dimension.</td></tr>
<tr><td>vatt_list</td><td>=</td><td>att_list</td><td>//Variable-specific attributes</td></tr>
<tr><td>vsize</td><td>=</td><td>NON_NEG</td><td>//Variable size. If not a record variable, the amount</td></tr>
<tr><td></td><td></td><td></td><td>//of space in bytes allocated to the variable's data.</td></tr>
<tr><td></td><td></td><td></td><td>//For record variables, it is the amount of space per</td></tr>
<tr><td></td><td></td><td></td><td>//record. See <a href=#NOTEVSIZE5>"Note on vsize"</a>, below.</td></tr>
<tr><td>begin</td><td>=</td><td>OFFSET</td><td>//Variable start location. The offset in bytes (seek</td></tr>
<tr><td></td><td></td><td></td><td>//index) in the file of the beginning of data for this.</td></tr>
<tr><td></td><td></td><td></td><td>//variable.</td></tr>
<tr><td>data</td><td>=</td><td>non_recs recs</td><td></td></tr>
<tr><td>non_recs</td><td>=</td><td>[vardata ...]</td><td>//The data for all non-record variables, stored</td></tr>
<tr><td></td><td></td><td></td><td>//contiguously for each variable, in the same order the</td></tr>
<tr><td></td><td></td><td></td><td>//variables occur in the header.</td></tr>
<tr><td>vardata</td><td>=</td><td>[values ...]</td><td>//All data for a non-record variable, as a block of</td></tr>
<tr><td></td><td></td><td></td><td>//values of the same type as the variable, in row-major</td></tr>
<tr><td></td><td></td><td></td><td>//order (last dimension varying fastest).</td></tr>
<tr><td>recs</td><td>=</td><td>[record ...]</td><td>//The data for all record variables are stored</td></tr>
<tr><td></td><td></td><td></td><td>//interleaved at the end of the file.</td></tr>
<tr><td>record</td><td>=</td><td>[varslab ...]</td><td>//Each record consists of the n-th slab from each</td></tr>
<tr><td></td><td></td><td></td><td>//record variable, for example x[n,...], y[n,...],</td></tr>
<tr><td></td><td></td><td></td><td>//z[n,...] where the first index is the record number,</td></tr>
<tr><td></td><td></td><td></td><td>//which is the unlimited dimension index.</td></tr>
<tr><td>varslab</td><td>=</td><td>[values ...]</td><td>//One record of data for a variable, a block of values</td></tr>
<tr><td></td><td></td><td></td><td>//all of the same type as the variable in row-major</td></tr>
<tr><td></td><td></td><td></td><td>//order (last index varying fastest).</td></tr>
<tr><td>values</td><td>=</td><td>bytes | chars | shorts | ints | floats | doubles |</td><td></td></tr>
<tr><td></td><td></td><td style="color:blue">ubytes | ushorts | uints | int64s | uint64s</td><td></td></tr>
<tr><td>string</td><td>=</td><td>nelems [chars]</td><td></td></tr>
<tr><td>bytes</td><td>=</td><td>[BYTE ...] padding</td><td></td></tr>
<tr><td>chars</td><td>=</td><td>[CHAR ...] padding</td><td></td></tr>
<tr><td>shorts</td><td>=</td><td>[SHORT ...] padding</td><td></td></tr>
<tr><td>ints</td><td>=</td><td>[INT ...]</td><td></td></tr>
<tr><td>floats</td><td>=</td><td>[FLOAT ...]</td><td></td></tr>
<tr><td>doubles</td><td>=</td><td>[DOUBLE ...]</td><td></td></tr>
<tr style="color:blue"><td>ubytes</td><td>=</td><td>[UBYTE ...] padding</td><td></td></tr>
<tr style="color:blue"><td>ushorts</td><td>=</td><td>[USHORT ...] padding</td><td></td></tr>
<tr style="color:blue"><td>uints</td><td>=</td><td>[UINT ...]</td><td></td></tr>
<tr style="color:blue"><td>int64s</td><td>=</td><td>[INT64 ...]</td><td></td></tr>
<tr style="color:blue"><td>uint64s</td><td>=</td><td>[UINT64 ...]</td><td></td></tr>
<tr><td>padding</td><td>=</td><td>&#60;0, 1, 2, or 3 bytes to next 4-byte boundary&#62;</td><td></td></tr>
<tr><td></td><td></td><td></td><td>//Header padding uses null (\x00) bytes. In data, padding</td></tr>
<tr><td></td><td></td><td></td><td>//uses variable's fill value. See <a href=#NOTEPADDING5>"Note on padding"</a> below</td></tr>
<tr><td></td><td></td><td></td><td>//for a special case.</td></tr>
<tr><td>NON_NEG</td><td>=</td><td>&#60;non-negative INT&#62; |</td><td>//for CDF-1 and CDF-2 formats</td></tr>
<tr style="color:blue"><td></td><td></td><td>&#60;non-negative INT64&#62;</td><td>//for 64-bit data format (CDF-5)</td></tr>
<tr><td>STREAMING</td><td>=</td><td>\xFF \xFF \xFF \xFF |</td><td>//for CDF-1 and CDF-2 formats</td></tr>
<tr style="color:blue"><td></td><td></td><td>\xFF \xFF \xFF \xFF \xFF \xFF \xFF \xFF</td><td>//for CDF-5 format</td></tr>
<tr><td></td><td></td><td></td><td>//Indicates indeterminate record count, allows streaming</td></tr>
<tr><td></td><td></td><td></td><td>//data</td></tr>
<tr><td>OFFSET</td><td>=</td><td>&#60;non-negative INT&#62; |</td><td>//for classic format (CDF-1)</td></tr>
<tr style="color:red"><td></td><td></td><td>&#60;non-negative INT64&#62;</td><td>//for CDF-2 and <span style="color:blue">CDF-5</span> formats</td></tr>
<tr><td>BYTE</td><td>=</td><td>&#60;8-bit byte&#62;</td><td>//See <a href=#NOTEBYTE5>"Note on byte data"</a> below.</td></tr>
<tr><td>CHAR</td><td>=</td><td>&#60;8-bit byte&#62;</td><td>//See <a href=#NOTECHAR5>"Note on char data"</a> below.</td></tr>
<tr><td>SHORT</td><td>=</td><td style="white-space:nowrap;">&#60;16-bit signed integer, Bigendian, two's complement&#62;</td><td></td></tr>
<tr><td>INT</td><td>=</td><td style="white-space:nowrap;">&#60;32-bit signed integer, Bigendian, two's complement&#62;</td><td></td></tr>
<tr><td>FLOAT</td><td>=</td><td style="white-space:nowrap;">&#60;32-bit IEEE single-precision float, Bigendian&#62;</td><td></td></tr>
<tr><td>DOUBLE</td><td>=</td><td>&#60;64-bit IEEE double-precision float, Bigendian&#62;</td><td></td></tr>
<tr style="color:blue"><td>UBYTE</td><td>=</td><td style="white-space:nowrap;">&#60;8-bit unsigned byte&#62;</td><td></td></tr>
<tr style="color:blue"><td>USHORT</td><td>=</td><td style="white-space:nowrap;">&#60;16-bit unsigned integer, Bigendian, two's complement&#62;</td><td></td></tr>
<tr style="color:blue"><td>UINT</td><td>=</td><td style="white-space:nowrap;">&#60;32-bit unsigned integer, Bigendian, two's complement&#62;</td><td></td></tr>
<tr style="color:red"><td>INT64</td><td>=</td><td style="white-space:nowrap;">&#60;64-bit signed integer, Bigendian, two's complement&#62;</td><td></td></tr>
<tr style="color:blue"><td>UINT64</td><td>=</td><td style="white-space:nowrap;">&#60;64-bit unsigned integer, Bigendian, two's complement&#62;</td><td></td></tr>
</td></tr>
<tr><td></td><td></td><td></td><td>//following type tags are 32-bit integers</td></tr>
<tr><td>NC_BYTE</td><td>=</td><td>\x00 \x00 \x00 \x01</td><td>//8-bit signed integers</td></tr>
<tr><td>NC_CHAR</td><td>=</td><td>\x00 \x00 \x00 \x02</td><td>//text characters</td></tr>
<tr><td>NC_SHORT</td><td>=</td><td>\x00 \x00 \x00 \x03</td><td>//16-bit signed integers</td></tr>
<tr><td>NC_INT</td><td>=</td><td>\x00 \x00 \x00 \x04</td><td>//32-bit signed integers</td></tr>
<tr><td>NC_FLOAT</td><td>=</td><td>\x00 \x00 \x00 \x05</td><td>//IEEE single precision floats</td></tr>
<tr><td>NC_DOUBLE</td><td>=</td><td>\x00 \x00 \x00 \x06</td><td>//IEEE double precision floats</td></tr>
<tr style="color:blue"><td>NC_UBYTE</td><td>=</td><td>\x00 \x00 \x00 \x07</td><td>//unsigned 1 byte integer</td></tr>
<tr style="color:blue"><td>NC_USHORT</td><td>=</td><td>\x00 \x00 \x00 \x08</td><td>//unsigned 2-byte integer</td></tr>
<tr style="color:blue"><td>NC_UINT</td><td>=</td><td>\x00 \x00 \x00 \x09</td><td>//unsigned 4-byte integer</td></tr>
<tr style="color:blue"><td>NC_INT64</td><td>=</td><td>\x00 \x00 \x00 \x0A</td><td>//signed 8-byte integer</td></tr>
<tr style="color:blue"><td>NC_UINT64</td><td>=</td><td>\x00 \x00 \x00 \x0B</td><td>//unsigned 8-byte integer</td></tr>
</td></tr>
<tr><td></td><td></td><td></td><td>//Default fill values for each type, may be overridden by</td></tr>
<tr><td></td><td></td><td></td><td>//variable attribute named `_FillValue'. See</td></tr>
<tr><td></td><td></td><td></td><td>//<a href=#NOTEFILL5>"Note on fill values"</a> below.</td></tr>
<tr><td>FILL_CHAR</td><td>=</td><td>\x00</td><td>//((char)0) null byte</td></tr>
<tr><td>FILL_BYTE</td><td>=</td><td>\x81</td><td>//(signed char) -127</td></tr>
<tr><td>FILL_SHORT</td><td>=</td><td>\x80 \x01</td><td>//(short) -32767</td></tr>
<tr><td>FILL_INT</td><td>=</td><td>\x80 \x00 \x00 \x01</td><td>//(int) -2147483647</td></tr>
<tr><td>FILL_FLOAT</td><td>=</td><td>\x7C \xF0 \x00 \x00</td><td>//(float) 9.9692099683868690e+36</td></tr>
<tr><td>FILL_DOUBLE</td><td>=</td><td>\x47 \x9E \x00 \x00 \x00 \x00 \x00 \x00</td><td>//(double)9.9692099683868690e+36</td></tr>
<tr style="color:blue"><td>FILL_UBYTE</td><td>=</td><td>\xFF</td><td>//(255)</td></tr>
<tr style="color:blue"><td>FILL_USHORT</td><td>=</td><td>\xFF \xFF</td><td>//(65535)</td></tr>
<tr style="color:blue"><td>FILL_UINT</td><td>=</td><td>\xFF \xFF \xFF \xFF</td><td>//(4294967295U)</td></tr>
<tr style="color:blue"><td>FILL_INT64</td><td>=</td><td>\x80 \x00 \x00 \x00 \x00 \x00 \x00 \x02</td><td>//((long long)-9223372036854775806LL)</td></tr>
<tr style="color:blue"><td>FILL_UINT64</td><td>=</td><td>\xFF \xFF \xFF \xFF \xFF \xFF \xFF \xFE</td><td>//((unsigned long long)18446744073709551614ULL)</td></tr>
</table>
</tt>
<hr>
@end html

@heading Notes

@strong{Note on vsize}:@anchor{NOTEVSIZE5}
This number is the product of the dimension lengths
(omitting the record dimension) and the number of bytes per value
(determined from the type), increased to the next multiple of 4, for
each variable.  If a record variable, this is the amount of space per
record (except that, for backward compatibility, it always includes
padding to the next multiple of 4 bytes, even in the exceptional case
noted below under "Note on padding").  The netCDF "record size" is
calculated as the sum of the @code{vsize}'s of all the record variables.

The @strong{vsize} field is actually redundant, because its value may be
computed from other information in the header. The 32-bit @strong{vsize} field
is not large enough to contain the size of variables that require more
than 2^32 - 4 bytes, so 2^32 - 1 is used in the @strong{vsize} field for such
variables.

@strong{Note on names}:@anchor{NOTENAMES5}
CDF-1 enforces a more restricted set of characters in
creating new names, but permits reading names containing arbitrary
bytes.  This specification extends the permitted characters in names
to include multi-byte UTF-8 encoded Unicode and additional printing
characters from the US-ASCII alphabet. The first character of a name
must be alphanumeric, a multi-byte UTF-8 character, or '_'
(reserved for special names with meaning to implementations,
such as the "_FillValue" attribute).  Subsequent characters may also
include printing special characters, except for '/' which is not
allowed in names.  Names that have trailing space characters are also
not permitted.

Implementations of all CDF formats must
ensure that names are normalized according to Unicode NFC
normalization rules during encoding as UTF-8 for storing in the file
header.  This is necessary to ensure that gratuitous differences in
the representation of Unicode names do not cause anomalies in
comparing files and querying data objects by name.

@strong{Note on streaming data}:@anchor{NOTESTREAMING5}
The largest possible record count, 2^32
- 1, is reserved to indicate an indeterminate number of records.
This means that the number of records in the file must be determined
by other means, such as reading them or computing the current number
of records from the file length and other information in the header.
It also means that the numrecs field in the header will not be updated
as records are added to the file.  [This feature is not yet
implemented].

@strong{Note on padding}:@anchor{NOTEPADDING5}
In the special case when there is only one record
variable and it is of type character, byte, or short, no padding is
used between record slabs, so records after the first record do not
necessarily start on four-byte boundaries.  However, as noted above
under "Note on @strong{vsize}, the @strong{vsize} field is computed to
include padding to the next multiple of 4 bytes.  In this case,
readers should ignore @strong{vsize} and assume no padding.  Writers
should store @strong{vsize} as if padding were included.

@strong{Note on byte data}:@anchor{NOTEBYTE5}
It is possible to interpret byte data as either
signed (-128 to 127) or unsigned (0 to 255). When reading byte data
through an interface that converts it into another numeric type, the
default interpretation is signed.  There are various attribute
conventions for specifying whether bytes represent signed or unsigned
data, but no standard convention has been established.  The variable
attribute "_Unsigned" is reserved for this purpose in future
implementations.

@strong{Note on char data}:@anchor{NOTECHAR5}
Although the characters used in netCDF names must
be encoded as UTF-8, character data may use other encodings. The variable
attribute "_Encoding" is reserved for this purpose in future implementations.

@strong{Note on fill values}:@anchor{NOTEFILL5}
 Because data variables may be created before
their values are written, and because values need not be written
sequentially in a netCDF file, default "fill values" are defined for
each type, for initializing data values before they are explicitly
written.  This makes it possible to detect reading values that were
never written.  The variable attribute "_FillValue", if present,
overrides the default fill value for a variable. If _FillValue is
defined then it should be scalar and of the same type as the variable.

Fill values are not required, however, because netCDF libraries have
traditionally supported a "no fill" mode when writing, omitting the
initialization of variable values with fill values. This makes the
creation of large files faster, but also eliminates the possibility of
detecting the inadvertent reading of values that haven't been written.

@heading Notes on Computing File Offsets

The offset (position within the file) of a specified data value in a
CDF-1, CDF-2, or CDF-5 file is determined by
the variable start location (the offset in the @code{begin} field), the
external type of the variable (the @code{nc_type} field), and the
dimension indices (one for each of the variable's dimensions) of the
value desired.

The external size in bytes of one data value for each possible
netCDF type, denoted @code{extsize} below, is:

@multitable @columnfractions .01 .10
@item @code{NC_BYTE}
@tab 1
@item @code{NC_CHAR}
@tab 1
@item @code{NC_SHORT}
@tab 2
@item @code{NC_INT}
@tab 4
@item @code{NC_FLOAT}
@tab 4
@item @code{NC_DOUBLE}
@tab 8

@item @code{NC_UBYTE}
@tab 1
@item @code{NC_USHORT}
@tab 2
@item @code{NC_UINT}
@tab 4
@item @code{NC_INT64}
@tab 8
@item @code{NC_UINT64}
@tab 8
@end multitable

The record size, denoted by @code{recsize} below, is the sum of the @code{vsize}
fields of record variables (variables that use the unlimited
dimension), using the actual value determined by dimension sizes and
variable type in case the @code{vsize} field is too small for the variable
size.

To compute the offset of a value relative to the beginning of a
variable, it is helpful to precompute a ``product vector'' from the
dimension lengths.  Form the products of the dimension lengths for the
variable from right to left, skipping the leftmost (record) dimension
for record variables, and storing the results as the product vector
for each variable.

For example:
@example
Non-record variable:

        dimension lengths:      [  5  3  2 7]
        product vector:         [210 42 14 7]

Record variable:

        dimension lengths:      [0  2  9 4]
        product vector:         [0 72 36 4]
@end example
At this point, the leftmost product, when rounded up to the next
multiple of 4, is the variable size, @code{vsize}, in the grammar above. For
example, in the non-record variable above, the value of the @code{vsize}
field is 212 (210 rounded up to a multiple of 4). For the record
variable, the value of @code{vsize} is just 72, since this is already a
multiple of 4.

Let coord be the array of coordinates (dimension indices, zero-based)
of the desired data value.  Then the offset of the value from the
beginning of the file is just the file offset of the first data value
of the desired variable (its @code{begin} field) added to the inner product
of the coord and product vectors times the size, in bytes, of each
datum for the variable. Finally, if the variable is a record variable,
the product of the record number, 'coord[0]', and the record size,
@code{recsize}, is added to yield the final offset value.

A special case: Where there is exactly one record variable, we drop
the requirement that each record be four-byte aligned, so in this case
there is no record padding.

@heading Examples

By using the grammar above, we can derive the smallest valid netCDF
file, having no dimensions, no variables, no attributes, and hence, no
data. A CDL representation of the empty netCDF file is
@example
netcdf empty @{ @}
@end example
This empty netCDF file has 32 bytes if it is in CDF-1 or CDF-2 format.
If the file is in CDF-5 formatm the size is 48 bytes.
For CDF-1 and CDF-2 format, the file begins with the four-byte
``magic number'' that identifies it as a netCDF version 1 file:
@samp{C}, @samp{D}, @samp{F}, @samp{\x01}. Following are seven 32-bit
integer zeros representing the number of records, an empty list of
dimensions, an empty list of global attributes, and an empty list of
variables.
The layout is similar for CDF-5, but the NON_NEG and ZERO64 integers are 64-bits.

Let's use an example file named tiny.nc created from a CDL file shown below.
@example
% cat tiny.cdl
netcdf tiny @{
dimensions:
        dim = 5;
variables:
        short vx(dim);
data:
        vx = 3, 1, 4, 1, 5 ;
@}
@end example

@html
To create a netCDF binary file in <span style="color:blue">CDF-5</span> format, one can use command:
@end html
@example
% ncgen -v 5 -b tiny.cdl
@end example
@html
Similarly, the command to create a <span style="color:red">CDF-2</span> file is
@end html
@example
% ncgen -v 2 -b tiny.cdl
@end example

Below is an (edited) dump of tiny.nc produced using the Unix command
@example
% od -c tiny.nc
@end example
@html
Each 16-byte portion of the file is displayed with 2 lines. The first
line displays the bytes as characters. The second line (added by human)
presents the interpretation of the bytes in terms of CDF format specification
components and values. The dump corresponds to a 140-byte netCDF file in
<span style="color:blue">CDF-5</span> format.
@end html

@example
0000000    C   D   F 005  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \n
          [ magic number] [    numrecs = 0 records      ] [NC_DIMENSION ]
0000020   \0  \0  \0  \0  \0  \0  \0 001  \0  \0  \0  \0  \0  \0  \0 003
          [     nelems = 1 dimension    ] [  dimension name has 3 chars  ]
0000040    d   i   m  \0  \0  \0  \0  \0  \0  \0  \0 005  \0  \0  \0  \0
          [ name="dim"  ] [       dim_length = 5        ] [ 0 global att-
0000060   \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \v  \0  \0  \0  \0
          ribute (ABSENT = ZERO ZERO64) ] [ NC_VARIABLE ] [  nelems =
0000100   \0  \0  \0 001  \0  \0  \0  \0  \0  \0  \0 002   v   x  \0  \0
           1 variable   ] [ variable name has 2 chars   ] [ name = "vx" ]
0000120   \0  \0  \0  \0  \0  \0  \0 001  \0  \0  \0  \0  \0  \0  \0  \0
          [ variable has 1 dimension    ] [  first dimension has ID 0   ]
0000140   \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0 003
          [ var has 0 attributes (ABSENT = ZERO ZERO64) ] [type=NC_SHORT]
0000160   \0  \0  \0  \0  \0  \0  \0  \f  \0  \0  \0  \0  \0  \0  \0 200
          [  var size, vsize = 12 bytes ] [var's file offset begin = 128]
0000200   \0 003  \0 001  \0 004  \0 001  \0 005 200 001
          [    3] [    1] [    4] [    1] [    5][padding]
0000214
@end example

@html
Below is the dump corresponds to a 96-byte <span style="color:red">CDF-2</span> file generated from the same CDL file, tiny.cdl.
@end html
@example
0000000    C   D   F 002  \0  \0  \0  \0  \0  \0  \0  \n  \0  \0  \0 001
          [ magic number] [ numrecs = 0 ] [NC_DIMENSION ] [ 1 dimension ]
0000020   \0  \0  \0 003   d   i   m  \0  \0  \0  \0 005  \0  \0  \0  \0
          [  3 chars    ] [ name="dim"  ] [dim_length=5 ] [ 0 global atts
0000040   \0  \0  \0  \0  \0  \0  \0  \v  \0  \0  \0 001  \0  \0  \0 002
          (ABSENT)      ] [ NC_VARIABLE ] [  1 variable ] [   2 chars   ]
0000060    v   x  \0  \0  \0  \0  \0 001  \0  \0  \0  \0  \0  \0  \0  \0
          [ name = "vx" ] [ 1 dimension ] [ 1st dim ID 0] [ 0 attributes
0000100   \0  \0  \0  \0  \0  \0  \0 003  \0  \0  \0  \f  \0  \0  \0  \0
           (ABSENT)     ] [type=NC_SHORT] [vsize=12bytes] [ var's file offset
0000120   \0  \0  \0   T  \0 003  \0 001  \0 004  \0 001  \0 005 200 001
           begin = 84   ] [    3] [    1] [    4] [    1] [    5][padding]
0000140
@end example

Note that if the netCDF files were generated by utility "ncmpigen" instead
of "ncgen", the file size and the value of variable's begin will be different.
This is because PnetCDF uses a default minimum file header size of 512 bytes.
Thus the last three lines of the dump will become:
@example
0000120   \0  \0 002  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0
          begin = 512   ] [    skip ....
0000140   \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0
*
0001000   \0 003  \0 001  \0 004  \0 001  \0 005
         ][    3] [    1] [    4] [    1] [    5]
0001012
@end example

@bye
End:
